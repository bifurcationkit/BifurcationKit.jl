<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · Bifurcation Analysis in Julia</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Bifurcation Analysis in Julia</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../guidelines/">Overview</a></li><li><a class="tocitem" href="../tutorials/">Tutorials</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Functionalities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../Predictors/">Predictors / correctors</a></li><li><a class="tocitem" href="../detectionBifurcation/">Bifurcation detection</a></li><li><a class="tocitem" href="../codim2Continuation/">Fold / Hopf Continuation (codim 2)</a></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Normal form</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../simplebp/">Simple branch point</a></li><li><a class="tocitem" href="../nonsimplebp/">Non-simple branch point</a></li><li><a class="tocitem" href="../simplehopf/">Simple Hopf point</a></li></ul></li><li><a class="tocitem" href="../branchswitching/">Branch switching</a></li><li><a class="tocitem" href="../BifurcationDiagram/">Bifurcation diagram</a></li><li><a class="tocitem" href="../DeflatedContinuation/">Deflated Continuation</a></li><li><a class="tocitem" href="../deflatedproblem/">Deflated problem</a></li><li><a class="tocitem" href="../constrainedproblem/">Constrained problem</a></li><li><input class="collapse-toggle" id="menuitem-4-11" type="checkbox"/><label class="tocitem" for="menuitem-4-11"><span class="docs-label">Periodic Orbits</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../periodicOrbit/">Introduction</a></li><li><a class="tocitem" href="../periodicOrbitTrapeze/">Finite Differences</a></li><li><a class="tocitem" href="../periodicOrbitShooting/">Shooting</a></li></ul></li><li><a class="tocitem" href="../diffeq/">DiffEq wrapper</a></li><li><a class="tocitem" href="../iterator/">Iterator Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Options</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../linearsolver/">Linear Solvers</a></li><li><a class="tocitem" href="../borderedlinearsolver/">Bordered linear solvers</a></li><li><a class="tocitem" href="../eigensolver/">Eigen Solvers</a></li><li><a class="tocitem" href="../Borderedarrays/">Bordered arrays</a></li></ul></li><li><a class="tocitem" href="../faq/">Frequently Asked Questions</a></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#Parameters-1"><span>Parameters</span></a></li><li><a class="tocitem" href="#Results-1"><span>Results</span></a></li><li><a class="tocitem" href="#Problems-1"><span>Problems</span></a></li><li><a class="tocitem" href="#Misc.-1"><span>Misc.</span></a></li><li><a class="tocitem" href="#Newton-1"><span>Newton</span></a></li><li><a class="tocitem" href="#Continuation-1"><span>Continuation</span></a></li><li><a class="tocitem" href="#Bifurcation-diagram-1"><span>Bifurcation diagram</span></a></li><li><a class="tocitem" href="#Utils-for-periodic-orbits-1"><span>Utils for periodic orbits</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/rveltz/BifurcationKit.jl/blob/master/docs/src/library.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library-1"><a class="docs-heading-anchor" href="#Library-1">Library</a><a class="docs-heading-anchor-permalink" href="#Library-1" title="Permalink"></a></h1><h2 id="Parameters-1"><a class="docs-heading-anchor" href="#Parameters-1">Parameters</a><a class="docs-heading-anchor-permalink" href="#Parameters-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.NewtonPar" href="#BifurcationKit.NewtonPar"><code>BifurcationKit.NewtonPar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">options = NewtonPar(tol = 1e-4,...)</code></pre><p>Returns a variable containing parameters to affect the <code>newton</code> algorithm when solving <code>F(x) = 0</code>.</p><p><strong>Arguments (with default values):</strong></p><ul><li><code>tol = 1e-10</code>: absolute tolerance for <code>F(x)</code></li><li><code>maxIter = 50</code>: number of Newton iterations</li><li><code>verbose = false</code>: display Newton iterations?</li><li><code>linsolver = DefaultLS()</code>: linear solver, must be <code>&lt;: AbstractLinearSolver</code></li><li><code>eigsolver = DefaultEig()</code>: eigen solver, must be <code>&lt;: AbstractEigenSolver</code></li></ul><p><strong>Arguments only used in <code>newtonPALC</code></strong></p><ul><li><code>linesearch = false</code>: use line search algorithm</li><li><code>alpha = 1.0</code>: alpha (damping) parameter for line search algorithm</li><li><code>almin  = 0.001</code>: minimal vslue of the damping <code>alpha</code></li></ul><div class="admonition is-success"><header class="admonition-header">Mutating</header><div class="admonition-body"><p>For performance reasons, we decided to use an immutable structure to hold the parameters. One can use the package <code>Setfield.jl</code> to drastically simplify the mutation of different fields. See the tutorials for examples.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.ContinuationPar" href="#BifurcationKit.ContinuationPar"><code>BifurcationKit.ContinuationPar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">options = ContinuationPar(dsmin = 1e-4,...)</code></pre><p>Returns a variable containing parameters to affect the <code>continuation</code> algorithm used to solve <code>F(x,p) = 0</code>.</p><p><strong>Arguments</strong></p><ul><li><code>dsmin, dsmax</code> are the minimum, maximum arclength allowed value. It controls the density of points in the computed branch of solutions.</li><li><code>ds</code> is the initial arclength.</li><li><code>theta</code> is a parameter in the arclength constraint. It is very <strong>important</strong> to tune it. See the docs of <a href="#BifurcationKit.continuation"><code>continuation</code></a>.</li><li><code>pMin, pMax</code> allowed parameter range for <code>p</code></li><li><code>maxSteps</code> maximum number of continuation steps</li><li><code>newtonOptions::NewtonPar</code>: options for the Newton algorithm</li><li><code>saveToFile = false</code>: save to file. A name is automatically generated.</li><li><code>saveSolEveryStep::Int64 = 0</code> at which continuation steps do we save the current solution`</li><li><code>plotEveryStep = 3</code></li></ul><p><strong>Handling eigen elements, their computation is triggered by the argument <code>detectBifurcation</code> (see below)</strong></p><ul><li><code>nev = 3</code> number of eigenvalues to be computed. It is automatically increased to have at least <code>nev</code> unstable eigenvalues. To be set for proper  bifurcation detection. See <a href="../detectionBifurcation/#Detection-of-bifurcation-points-1">Detection of bifurcation points</a> for more informations.</li><li><code>saveEigEveryStep = 1</code>	record eigen vectors every specified steps. <strong>Important</strong> for memory limited ressource, <em>e.g.</em> GPU.</li><li><code>saveEigenvectors	= true</code>	<strong>Important</strong> for memory limited ressource, <em>e.g.</em> GPU.</li></ul><p><strong>Handling bifurcation detection</strong></p><ul><li><code>precisionStability = 1e-10</code> lower bound on the real part of the eigenvalues to test for stability of equilibria and periodic orbits</li><li><code>detectFold = true</code> detect Fold bifurcations? It is a useful option although the detection of Fold is cheap. Indeed, it may happen that there is a lot of Fold points and this can saturate the memory in memory limited devices (e.g. on GPU)</li><li><code>detectBifurcation::Int</code> ∈ {0, 1, 2, 3} If set to 0, nothing is done. If set to 1, the eigen-elements are computed. If set to 2, the bifurcations points are detected during the continuation run, but not located precisely. If set to 3, a bisection algorithm is used to locate the bifurcations points (slower). The possibility to switch off detection is a useful option. Indeed, it may happen that there are a lot of bifurcation points and this can saturate the memory of memory limited devices (e.g. on GPU)</li><li><code>dsminBisection</code> dsmin for the bisection algorithm for locating bifurcation points</li><li><code>nInversion</code> number of sign inversions in bisection algorithm</li><li><code>maxBisectionSteps</code> maximum number of bisection steps</li><li><code>tolBisectionEigenvalue</code> tolerance on real part of eigenvalue to detect bifurcation points in the bisection steps</li></ul><p><strong>Handling <code>ds</code> adaptation (see <a href="#BifurcationKit.continuation"><code>continuation</code></a> for more information)</strong></p><ul><li><code>a  = 0.5</code> aggressiveness factor. It is used to adapt <code>ds</code> in order to have a number of newton iterations per continuation step roughly constant. The higher <code>a</code> is, the larger the step size <code>ds</code> is changed at each continuation step.</li><li><code>thetaMin = 1.0e-3</code> minimum value of <code>theta</code></li><li><code>doArcLengthScaling</code> trigger further adaptation of <code>theta</code></li></ul><p><strong>Misc</strong></p><ul><li><code>finDiffEps::T  = 1e-9</code> ε used in finite differences computations</li></ul><div class="admonition is-success"><header class="admonition-header">Mutating</header><div class="admonition-body"><p>For performance reasons, we decided to use an immutable structure to hold the parameters. One can use the package <code>Setfield.jl</code> to drastically simplify the mutation of different fields. See tutorials for more examples.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0-L40">source</a></section></article><h2 id="Results-1"><a class="docs-heading-anchor" href="#Results-1">Results</a><a class="docs-heading-anchor-permalink" href="#Results-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.ContResult" href="#BifurcationKit.ContResult"><code>BifurcationKit.ContResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ContResult{Ta, Teigvals, Teigvec, Biftype, Ts, Tfunc, Tpar, Tl&lt;:Setfield.Lens} &lt;: BifurcationKit.AbstractBranchResult</code></pre><p>Structure which holds the results after a call to <a href="#BifurcationKit.continuation"><code>continuation</code></a>.</p><p>You can see the propertynames of a result by using <code>propertynames(::ContResult)</code> or by typing <code>br.</code> + TAB where <code>br::ContResult</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>branch::StructArrays.StructArray{Ta,N,C,I} where I where C&lt;:Union{Tuple, NamedTuple} where N where Ta</code></p><p>holds the low-dimensional information about the branch. More precisely, <code>branch[:, i+1]</code> contains the following information <code>(printSolution(u, param), param, itnewton, itlinear, ds, theta, n_unstable, n_imag, stable, step)</code> for each continuation step <code>i</code>.</p><ul><li><code>itnewton</code> number of Newton iterations</li><li><code>itlinear</code> total number of linear iterations during corrector</li><li><code>n_unstable</code> number of eigenvalues with positive real part for each continuation step (to detect stationary bifurcation)</li><li><code>n_imag</code> number of eigenvalues with positive real part and non zero imaginary part for each continuation step (to detect Hopf bifurcation).</li><li><code>stable</code>  stability of the computed solution for each continuation step. Hence, <code>stable</code> should match <code>eig[step]</code> which corresponds to <code>branch[k]</code> for a given <code>k</code>.</li><li><code>step</code> continuation step (here equal <code>i</code>)</li></ul></li><li><p><code>eig::Array{NamedTuple{(:eigenvals, :eigenvec, :step),Tuple{Teigvals,Teigvec,Int64}},1} where Teigvec where Teigvals</code></p><p>A vector with eigen-elements at each continuation step.</p></li><li><p><code>sol::Any</code></p><p>Vector of solutions sampled along the branch. This is set by the argument <code>saveSolEveryNsteps::Int64</code> (default 0) in <a href="#BifurcationKit.ContinuationPar"><code>ContinuationPar</code></a>.</p></li><li><p><code>contparams::ContinuationPar</code></p><p>The parameters used for the call to <code>continuation</code> which produced this branch.</p></li><li><p><code>type::Symbol</code></p><p>Type of solutions computed in this branch. Default: :Equilibrium</p></li><li><p><code>functional::Any</code></p><p>Structure associated to the functional, useful for branch switching. For example, when computing periodic orbits, the functional <code>PeriodicOrbitTrapProblem</code>, <code>ShootingProblem</code>... will be saved here. Default: nothing</p></li><li><p><code>params::Any</code></p><p>Parameters passed to continuation and used in the equation <code>F(x, par) = 0</code>. Default: nothing</p></li><li><p><code>lens::Setfield.Lens</code></p><p>Parameter axis used for computing the branch</p></li><li><p><code>bifpoint::Array{Biftype,1} where Biftype</code></p><p>A vector holding the set of detected bifurcation points. See <a href="#BifurcationKit.GenericBifPoint"><code>GenericBifPoint</code></a> for a description of the fields.</p></li></ul><p><strong>Associated methods</strong></p><ul><li><code>length(br)</code> number of the continuation steps</li><li><code>eigenvals(br, ind)</code> returns the eigenvalues for the ind-th continuation step</li><li><code>eigenvec(br, ind, indev)</code> returns the indev-th eigenvector for the ind-th continuation step</li><li><code>br[k+1]</code> gives information about the k-th step</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0">source</a></section></article><h2 id="Problems-1"><a class="docs-heading-anchor" href="#Problems-1">Problems</a><a class="docs-heading-anchor-permalink" href="#Problems-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.DeflationOperator" href="#BifurcationKit.DeflationOperator"><code>BifurcationKit.DeflationOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>DeflationOperator. It is used to handle the following situation. Assume you want to solve <code>F(x)=0</code> with a Newton algorithm but you want to avoid the process to return some already known solutions <span>$roots_i$</span>. The deflation operator penalizes these roots ; the algorithm works very well despite its simplicity. You can use <code>DeflationOperator</code> to define a function <code>M(u)</code> used to find, with Newton iterations, the zeros of the following function <span>$F(u) \cdot Π_i(dot(u - roots_i, u - roots_i)^{-p} + shift) := F(u) \cdot M(u)$</span>. The fields of the struct <code>DeflationOperator</code> are as follows:</p><ul><li>power <code>p</code></li><li><code>dot</code> function, this function has to be bilinear and symmetric for the linear solver to work well</li><li>shift</li><li>roots</li></ul><p>The deflation operator is is <span>$M(u) = \prod_{i=1}^{n_{roots}}(shift + norm(u-roots_i)^{-p})$</span> where <span>$norm(u) = dot(u,u)$</span>.</p><p>Given <code>defOp::DeflationOperator</code>, one can access its roots as <code>defOp[n]</code> as a shortcut for <code>defOp.roots[n]</code>. Also, one can add (resp.remove) a new root by using <code>push!(defOp, newroot)</code> (resp. <code>pop!(defOp)</code>). Finally <code>length(defOp)</code> is a shortcut for <code>length(defOp.roots)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/efbbc550819c59e67e558e5e626a8db46b7183f2/src/DeflationOperator.jl#L4-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.DeflatedProblem" href="#BifurcationKit.DeflatedProblem"><code>BifurcationKit.DeflatedProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">pb = DeflatedProblem(F, J, M::DeflationOperator)</code></pre><p>This creates a deflated problem <span>$M(u) \cdot F(u) = 0$</span> where <code>M</code> is a <code>DeflationOperator</code> which encodes the penalization term. <code>J</code> is the jacobian of <code>F</code>. Can be used to call <code>newton</code> and <code>continuation</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/efbbc550819c59e67e558e5e626a8db46b7183f2/src/DeflationOperator.jl#L62-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.PeriodicOrbitTrapProblem" href="#BifurcationKit.PeriodicOrbitTrapProblem"><code>BifurcationKit.PeriodicOrbitTrapProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">pb = PeriodicOrbitTrapProblem(F, J, ϕ, xπ, M::Int)</code></pre><p>This composite type implements Finite Differences based on a Trapezoidal rule to locate periodic orbits. More details (maths, notations, linear systems) can be found <a href="https://rveltz.github.io/BifurcationKit.jl/dev/periodicOrbitFD/">here</a>. The arguments are as follows</p><ul><li><code>F(x,p)</code> vector field</li><li><code>J</code> is the jacobian of <code>F</code> at <code>(x, p)</code>. It can assume three forms.<ol><li>Either <code>J</code> is a function and <code>J(x,p)</code> returns a <code>::AbstractMatrix</code>. In this case, the default arguments of <code>contParams::ContinuationPar</code> will make <code>continuation</code> work.</li><li>Or <code>J</code> is a function and <code>J(x, p)</code> returns a function taking one argument <code>dx</code> and returning <code>dr</code> of the same type as <code>dx</code>. In our notation, <code>dr = J * dx</code>. In this case, the default parameters of <code>contParams::ContinuationPar</code> will not work and you have to use a Matrix Free linear solver, for example <code>GMRESIterativeSolvers</code>,</li><li>Or <code>J</code> is a function and <code>J(x, p)</code> returns a variable <code>j</code> which can assume any type. Then, you must implement a linear solver <code>ls</code> as a composite type, subtype of <code>AbstractLinearSolver</code> which is called like <code>ls(j, rhs)</code> and which returns the solution of the jacobian linear system. See for example <code>examples/SH2d-fronts-cuda.jl</code>. This linear solver is passed to <code>NewtonPar(linsolver = ls)</code> which itself passed to <code>ContinuationPar</code>. Similarly, you have to implement an eigensolver <code>eig</code> as a composite type, subtype of <code>AbstractEigenSolver</code>.</li></ol></li><li><code>Jᵗ = nothing</code> jacobian tranpose of <code>F</code> (optional), useful for continuation of Fold of periodic orbits. it should not be passed in case the jacobian is a (sparse) matrix as it is computed internally, and it would be computed twice in that case.</li><li><code>d2F = nothing</code> second derivative of F (optional), useful for continuation of Fold of periodic orbits. It has the definition <code>d2F(x,p,dx1,dx2)</code>.`</li><li><code>ϕ</code> used to set a section for the phase constraint equation</li><li><code>xπ</code> used in the section for the phase constraint equation</li><li><code>M::Int</code> number of time slices</li><li><code>linsolver: = DefaultLS()</code> linear solver for each time slice, i.e. to solve <code>J⋅sol = rhs</code>. This is only needed for the computation of the Floquet multipliers.</li><li><code>isinplace::Bool</code> whether <code>F</code> and <code>J</code> are inplace functions (Experimental). In this case, the functions <code>F</code> and <code>J</code> must have the following definitions <code>(o, x, p) -&gt;  F(o, x, p)</code> and <code>(o, x, p, dx) -&gt; J(o, x, p, dx)</code>.</li><li><code>ongpu::Bool</code> whether the computation takes place on the gpu (Experimental)</li></ul><p>The scheme is as follows. We first consider a partition of <span>$[0,1]$</span> given by <span>$0&lt;s_0&lt;\cdots&lt;s_m=1$</span> and one looks for <code>T = x[end]</code> such that</p><p><span>$\left(x_{i} - x_{i-1}\right) - \frac{T\cdot h_i}{2} \left(F(x_{i}) + F(x_{i-1})\right) = 0,\ i=1,\cdots,m-1$</span></p><p>with <span>$u_{0} := u_{m-1}$</span> and the periodicity condition <span>$u_{m} - u_{1} = 0$</span> and</p><p>where <span>$h_1 = s_i-s_{i-1}$</span>. Finally, the phase of the periodic orbit is constrained by using a section (but you could use your own)</p><p><span>$\sum_i\langle x_{i} - x_{\pi,i}, \phi_{i}\rangle=0.$</span></p><p><strong>Orbit guess</strong></p><p>You will see below that you can evaluate the residual of the functional (and other things) by calling <code>pb(orbitguess, p)</code> on an orbit guess <code>orbitguess</code>. Note that <code>orbitguess</code> must be of size M * N + 1 where N is the number of unknowns in the state space and <code>orbitguess[M*N+1]</code> is an estimate of the period <span>$T$</span> of the limit cycle. More precisely, using the above notations, <code>orbitguess</code> must be <span>$orbitguess = [x_{1},x_{2},\cdots,x_{M}, T]$</span>.</p><p><strong>Functional</strong></p><p>A functional, hereby called <code>G</code>, encodes this problem. The following methods are available</p><ul><li><code>pb(orbitguess, p)</code> evaluates the functional G on <code>orbitguess</code></li><li><code>pb(orbitguess, p, du)</code> evaluates the jacobian <code>dG(orbitguess).du</code> functional at <code>orbitguess</code> on <code>du</code></li><li><code>pb(Val(:JacFullSparse), orbitguess, p)</code> return the sparse matrix of the jacobian <code>dG(orbitguess)</code> at <code>orbitguess</code> without the constraints. It is called <code>A_γ</code> in the docs.</li><li><code>pb(Val(:JacFullSparseInplace), J, orbitguess, p)</code>. Same as <code>pb(Val(:JacFullSparse), orbitguess, p)</code> but overwrites <code>J</code> inplace. Note that the sparsity pattern must be the same independantly of the values of the parameters or of <code>orbitguess</code>. In this case, this is significantly faster than <code>pb(Val(:JacFullSparse), orbitguess, p)</code>.</li><li><code>pb(Val(:JacCyclicSparse), orbitguess, p)</code> return the sparse cyclic matrix Jc (see the docs) of the jacobian <code>dG(orbitguess)</code> at <code>orbitguess</code></li><li><code>pb(Val(:BlockDiagSparse), orbitguess, p)</code> return the diagonal of the sparse matrix of the jacobian <code>dG(orbitguess)</code> at <code>orbitguess</code>. This allows to design Jacobi preconditioner. Use <code>blockdiag</code>.</li></ul><div class="admonition is-info"><header class="admonition-header">GPU call</header><div class="admonition-body"><p>For these methods to work on the GPU, for example with <code>CuArrays</code> in mode <code>allowscalar(false)</code>, we face the issue that the function <code>extractPeriodFDTrap</code> won&#39;t be well defined because it is a scalar operation. One may have to redefine it like <code>extractPeriodFDTrap(x::CuArray) = x[end:end]</code> or something else. Also, note that you must pass the option <code>ongpu = true</code> for the functional to be evaluated efficiently on the gpu.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.ShootingProblem" href="#BifurcationKit.ShootingProblem"><code>BifurcationKit.ShootingProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">pb = ShootingProblem(flow::Flow, ds, section; parallel = false)</code></pre><p>Create a problem to implement the Standard Simple / Parallel Multiple Standard Shooting method to locate periodic orbits. More details (maths, notations, linear systems) can be found <a href="https://rveltz.github.io/BifurcationKit.jl/dev/periodicOrbitShooting/">here</a>. The arguments are as follows</p><ul><li><code>flow::Flow</code>: implements the flow of the Cauchy problem though the structure <a href="#BifurcationKit.Flow"><code>Flow</code></a>.</li><li><code>ds</code>: vector of time differences for each shooting. Its length is written <code>M</code>. If <code>M==1</code>, then the simple shooting is implemented and the multiple one otherwise.</li><li><code>section</code>: implements a phase condition. The evaluation <code>section(x, T)</code> must return a scalar number where <code>x</code> is a guess for <strong>one point</strong> the periodic orbit and <code>T</code> is the period of the guess. The type of <code>x</code> depends on what is passed to the newton solver. See <a href="#BifurcationKit.SectionSS"><code>SectionSS</code></a> for a type of section defined as a hyperplane.</li><li><code>parallel</code> whether the shooting are computed in parallel (threading). Available through the use of Flows defined by <code>EnsembleProblem</code>.</li></ul><p>A functional, hereby called <code>G</code>, encodes the shooting problem. For example, the following methods are available:</p><ul><li><code>pb(orbitguess, par)</code> evaluates the functional G on <code>orbitguess</code></li><li><code>pb(orbitguess, par, du; δ = 1e-9)</code> evaluates the jacobian <code>dG(orbitguess).du</code> functional at <code>orbitguess</code> on <code>du</code>. The optional argument <code>δ</code> is used to compute a finite difference approximation of the derivative of the section.</li><li><code>pb</code>(Val(:JacobianMatrixInplace), J, x, par)` compute the jacobian of the functional analytically. This is based on ForwardDiff.jl. Useful mainly for ODEs.</li><li><code>pb(Val(:JacobianMatrix), x, par)</code> same as above but out-of-place.</li></ul><p>You can then call <code>pb(orbitguess, par)</code> to apply the functional to a guess. Note that <code>orbitguess::AbstractVector</code> must be of size M * N + 1 where N is the number of unknowns of the state space and <code>orbitguess[M * N + 1]</code> is an estimate of the period <code>T</code> of the limit cycle. This form of guess is convenient for the use of the linear solvers in <code>IterativeSolvers.jl</code> (for example) which accepts only <code>AbstractVector</code>s. Another accepted guess is of the form <code>BorderedArray(guess, T)</code> where <code>guess[i]</code> is the state of the orbit at the <code>i</code>th time slice. This last form allows for non-vector state space which can be convenient for 2d problems for example, use <code>GMRESKrylovKit</code> for the linear solver in this case.</p><p><strong>Simplified constructors</strong></p><ul><li>A simpler way to build the functional is to use</li></ul><pre><code class="language-none">pb = ShootingProblem(F, p, prob::Union{ODEProblem, EnsembleProblem}, alg, centers::AbstractVector; kwargs...)</code></pre><p>where <code>F(x,p)</code> is the vector field, <code>p</code> is a parameter (to be passed to the vector field and the flow), <code>prob</code> is an <code>ODEProblem</code> (resp. <code>EnsembleProblem</code>) which is used to create a flow using the ODE solver <code>alg</code> (for example <code>Tsit5()</code>). <code>centers</code> is list of <code>M</code> points close to the periodic orbit, they will be used to build a constraint for the phase. <code>parallel = false</code> is an option to use Parallel simulations (Threading) to simulate the multiple trajectories in the case of multiple shooting. This is efficient when the trajectories are relatively long to compute. Finally, the arguments <code>kwargs</code> are passed to the ODE solver defining the flow. Look at <code>DifferentialEquations.jl</code> for more information. Note that, in this case, the derivative of the flow is computed internally using Finite Differences.</p><ul><li>Another way to create a Shooting problem with more options is the following where in particular, one can provide its own scalar constraint <code>section(x)::Number</code> for the phase</li></ul><pre><code class="language-none">pb = ShootingProblem(F, p, prob::Union{ODEProblem, EnsembleProblem}, alg, M::Int, section; parallel = false, kwargs...)</code></pre><p>or</p><pre><code class="language-none">pb = ShootingProblem(F, p, prob::Union{ODEProblem, EnsembleProblem}, alg, ds, section; parallel = false, kwargs...)</code></pre><ul><li>The next way is an elaboration of the previous one</li></ul><pre><code class="language-none">pb = ShootingProblem(F, p, prob1::Union{ODEProblem, EnsembleProblem}, alg1, prob2::Union{ODEProblem, EnsembleProblem}, alg2, M::Int, section; parallel = false, kwargs...)</code></pre><p>or</p><pre><code class="language-none">pb = ShootingProblem(F, p, prob1::Union{ODEProblem, EnsembleProblem}, alg1, prob2::Union{ODEProblem, EnsembleProblem}, alg2, ds, section; parallel = false, kwargs...)</code></pre><p>where we supply now two <code>ODEProblem</code>s. The first one <code>prob1</code>, is used to define the flow associated to <code>F</code> while the second one is a problem associated to the derivative of the flow. Hence, <code>prob2</code> must implement the following vector field <span>$\tilde F(x,y,p) = (F(x,p),dF(x,p)\cdot y)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.PoincareShootingProblem" href="#BifurcationKit.PoincareShootingProblem"><code>BifurcationKit.PoincareShootingProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>pb = PoincareShootingProblem(flow::Flow, M, sections; δ = 1e-8, interp_points = 50, parallel = false)</code></p><p>This composite type implements the Poincaré Shooting method to locate periodic orbits by relying on Poincaré return maps. More details (maths, notations, linear systems) can be found <a href="https://rveltz.github.io/BifurcationKit.jl/dev/periodicOrbitShooting/">here</a>. The arguments are as follows</p><ul><li><code>flow::Flow</code>: implements the flow of the Cauchy problem though the structure <a href="#BifurcationKit.Flow"><code>Flow</code></a>.</li><li><code>M</code>: the number of Poincaré sections. If <code>M==1</code>, then the simple shooting is implemented and the multiple one otherwise.</li><li><code>sections</code>: function or callable struct which implements a Poincaré section condition. The evaluation <code>sections(x)</code> must return a scalar number when <code>M==1</code>. Otherwise, one must implement a function <code>section(out, x)</code> which populates <code>out</code> with the <code>M</code> sections. See <a href="#BifurcationKit.SectionPS"><code>SectionPS</code></a> for type of section defined as a hyperplane.</li><li><code>δ = 1e-8</code> used to compute the jacobian of the fonctional by finite differences. If set to <code>0</code>, an analytical expression of the jacobian is used instead.</li><li><code>interp_points = 50</code> number of interpolation point used to define the callback (to compute the hitting of the hyperplan section)</li><li><code>parallel = false</code> whether the shooting are computed in parallel (threading). Only available through the use of Flows defined by <code>EnsembleProblem</code>.</li></ul><p><strong>Simplified constructors</strong></p><ul><li>A simpler way is to create a functional is</li></ul><p><code>pb = PoincareShootingProblem(F, p, prob::ODEProblem, alg, section; kwargs...)</code></p><p>for simple shooting or</p><p><code>pb = PoincareShootingProblem(F, p, prob::Union{ODEProblem, EnsembleProblem}, alg, M::Int, section; kwargs...)</code></p><p>for multiple shooting . Here <code>F(x,p)</code> is the vector field, <code>p</code> is a parameter (to be passed to the vector and the flow), <code>prob</code> is an <code>Union{ODEProblem, EnsembleProblem}</code> which is used to create a flow using the ODE solver <code>alg</code> (for example <code>Tsit5()</code>). Finally, the arguments <code>kwargs</code> are passed to the ODE solver defining the flow. We refere to <code>DifferentialEquations.jl</code> for more information.</p><ul><li>Another convenient call is</li></ul><p><code>pb = PoincareShootingProblem(F, p, prob::Union{ODEProblem, EnsembleProblem}, alg, normals::AbstractVector, centers::AbstractVector; δ = 1e-8, kwargs...)</code></p><p>where <code>normals</code> (resp. <code>centers</code>) is a list of normals (resp. centers) which defines a list of hyperplanes <span>$\Sigma_i$</span>. These hyperplanes are used to define partial Poincaré return maps.</p><p><strong>Computing the functionals</strong></p><p>A functional, hereby called <code>G</code> encodes this shooting problem. You can then call <code>pb(orbitguess, par)</code> to apply the functional to a guess. Note that <code>orbitguess::AbstractVector</code> must be of size M * N where N is the number of unknowns in the state space and <code>M</code> is the number of Poincaré maps. Another accepted <code>guess</code> is such that <code>guess[i]</code> is the state of the orbit on the <code>i</code>th section. This last form allows for non-vector state space which can be convenient for 2d problems for example.</p><ul><li><code>pb(orbitguess, par)</code> evaluates the functional G on <code>orbitguess</code></li><li><code>pb(orbitguess, par, du)</code> evaluates the jacobian <code>dG(orbitguess).du</code> functional at <code>orbitguess</code> on <code>du</code></li><li><code>pb</code>(Val(:JacobianMatrixInplace), J, x, par)` compute the jacobian of the functional analytically. This is based on ForwardDiff.jl. Useful mainly for ODEs.</li><li><code>pb(Val(:JacobianMatrix), x, par)</code> same as above but out-of-place.</li></ul><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>You can use the function <code>getPeriod(pb, sol, par)</code> to get the period of the solution <code>sol</code> for the problem with parameters <code>par</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0-L40">source</a></section></article><h2 id="Misc.-1"><a class="docs-heading-anchor" href="#Misc.-1">Misc.</a><a class="docs-heading-anchor-permalink" href="#Misc.-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.PrecPartialSchurKrylovKit" href="#BifurcationKit.PrecPartialSchurKrylovKit"><code>BifurcationKit.PrecPartialSchurKrylovKit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">PrecPartialSchurKrylovKit(J, x0, nev, which = :LM; krylovdim = max(2nev, 20), verbosity = 0)</code></pre><p>Builds a preconditioner based on deflation of <code>nev</code> eigenvalues chosen according to <code>which</code>. A partial Schur decomposition is computed (Matrix-Free), using the package <code>KrylovKit.jl</code>, from which a projection is built. The options are similar to the ones of <code>EigKrylovKit()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/efbbc550819c59e67e558e5e626a8db46b7183f2/src/Preconditioner.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.PrecPartialSchurArnoldiMethod" href="#BifurcationKit.PrecPartialSchurArnoldiMethod"><code>BifurcationKit.PrecPartialSchurArnoldiMethod</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">PrecPartialSchurArnoldiMethod(J, N, nev, which = LM(); tol = 1e-9, kwargs...)</code></pre><p>Builds a preconditioner based on deflation of <code>nev</code> eigenvalues chosen according to <code>which</code>. A partial Schur decomposition is computed (Matrix-Free), using the package <code>ArnoldiMethod.jl</code>, from which a projection is built. See the package <code>ArnoldiMethod.jl</code> for how to pass the proper options.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/efbbc550819c59e67e558e5e626a8db46b7183f2/src/Preconditioner.jl#L50-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.Flow" href="#BifurcationKit.Flow"><code>BifurcationKit.Flow</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Flow{TF, Tf, Tts, Tff, Td, Tse, Tprob, TprobMono, Tfs}</code></pre><ul><li><p><code>F::Any</code></p><p>The vector field <code>(x, p) -&gt; F(x, p)</code> associated to a Cauchy problem, Default: nothing</p></li><li><p><code>flow::Any</code></p><p>The flow (or semigroup) associated to the Cauchy problem <code>(x, p, t) -&gt; flow(x, p, t)</code>. Only the last time point must be returned. Default: nothing</p></li><li><p><code>flowTimeSol::Any</code></p><p>Flow which returns the tuple (t, u(t)). Optional, mainly used for plotting on the user side. Please use <code>nothing</code> as default. Default: nothing</p></li><li><p><code>flowFull::Any</code></p><p>The flow (or semigroup) associated to the Cauchy problem <code>(x, p, t) -&gt; flow(x, p, t)</code>. The whole solution on the time interval [0,t] must be returned. It is not strictly necessary to provide this, mainly used for plotting on the user side. Please use <code>nothing</code> as default. Default: nothing</p></li><li><p><code>dflow::Any</code></p><p>The differential <code>dflow</code> of the flow w.r.t. <code>x</code>, <code>(x, p, dx, t) -&gt; dflow(x, p, dx, t)</code>. One important thing is that we require <code>dflow(x, dx, t)</code> to return a Named Tuple: <code>(t = t, u = flow(x, p, t), du = dflow(x, p, dx, t))</code>, the last composant being the value of the derivative of the flow. Default: nothing</p></li><li><p><code>dfSerial::Any</code></p><p>Serial version of dflow. Used internally when using parallel multiple shooting. Please use <code>nothing</code> as default. Default: nothing</p></li><li><p><code>prob::Any</code></p><p>[Internal] store the ODEProblem associated to the flow of the Cauchy problem Default: nothing</p></li><li><p><code>probMono::Any</code></p><p>[Internal] store the ODEProblem associated to the flow of the variational problem Default: nothing</p></li><li><p><code>flowSerial::Any</code></p><p>[Internal] Serial version of the flow Default: nothing</p></li></ul><p><strong>Simplified constructor(s)</strong></p><p>We provide a simple constructor where you only pass the vector field <code>F</code>, the flow <code>ϕ</code> and its differential <code>dϕ</code>:</p><pre><code class="language-none">fl = Flow(F, ϕ, dϕ)</code></pre><p><strong>Simplified constructors for DifferentialEquations.jl</strong></p><p>There are some simple constructors for which you only have to pass a <code>prob::ODEProblem</code> or <code>prob::EnsembleProblem</code> (for parallel computation) from <code>DifferentialEquations.jl</code> and an ODE time stepper like <code>Tsit5()</code>. Hence, you can do for example</p><pre><code class="language-none">fl = Flow(F, prob, Tsit5(); kwargs...)</code></pre><p>where <code>kwargs</code> is passed to <code>DiffEqBase::solve</code>. If your vector field depends on parameters <code>p</code>, you can define a <code>Flow</code> using</p><pre><code class="language-none">fl = Flow(F, p, prob, Tsit5(); kwargs...)</code></pre><p>Finally, you can pass two <code>ODEProblem</code> where the second one is used to compute the variational equation:</p><pre><code class="language-none">fl = Flow(F, p, prob1::ODEProblem, alg1, prob2::ODEProblem, alg2; kwargs...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.FloquetQaD" href="#BifurcationKit.FloquetQaD"><code>BifurcationKit.FloquetQaD</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">floquet = FloquetQaD(eigsolver::AbstractEigenSolver)</code></pre><p>This composite type implements the computation of the eigenvalues of the monodromy matrix in the case of periodic orbits problems (based on the Shooting method or Finite Differences (Trapeze method)), also called the Floquet multipliers. The method, dubbed Quick and Dirty (QaD), is not numerically very precise for large / small Floquet exponents. It allows, nevertheless, to detect bifurcations. The arguments are as follows:</p><ul><li><code>eigsolver::AbstractEigenSolver</code> solver used to compute the eigenvalues.</li></ul><p>If <code>eigsolver == DefaultEig()</code>, then the monodromy matrix is formed and its eigenvalues are computed. Otherwise, a Matrix-Free version of the monodromy is used.</p><div class="admonition is-danger"><header class="admonition-header">Floquet multipliers computation</header><div class="admonition-body"><p>The computation of Floquet multipliers is necessary for the detection of bifurcations of periodic orbits (which is done by analyzing the Floquet exponents obtained from the Floquet multipliers). Hence, the eigensolver <code>eigsolver</code> needs to compute the eigenvalues with largest modulus (and not with largest real part which is their default behavior). This can be done by changing the option <code>which = :LM</code> of <code>eigsolver</code>. Nevertheless, note that for most implemented eigensolvers in the current Package, the proper option is set.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/efbbc550819c59e67e558e5e626a8db46b7183f2/src/periodicorbit/Floquet.jl#L37-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.guessFromHopf-Tuple{Any,Any,AbstractEigenSolver,Any,Any}" href="#BifurcationKit.guessFromHopf-Tuple{Any,Any,AbstractEigenSolver,Any,Any}"><code>BifurcationKit.guessFromHopf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">guessFromHopf(br, ind_hopf, eigsolver::AbstractEigenSolver, M, amplitude; phase = 0)</code></pre><p>This function returns several useful quantities regarding a Hopf bifurcation point. More precisely, it returns:</p><ul><li>the parameter value at which a Hopf bifurcation occurs</li><li>the period of the bifurcated periodic orbit</li><li>a guess for the bifurcated periodic orbit</li><li>the equilibrium at the Hopf bifurcation point</li><li>the eigenvector at the Hopf bifurcation point.</li></ul><p>The arguments are</p><ul><li><code>br</code>: the continuation branch which lists the Hopf bifurcation points</li><li><code>ind_hopf</code>: index of the bifurcation branch, as in <code>br.bifpoint</code></li><li><code>eigsolver</code>: the eigen solver used to find the eigenvectors</li><li><code>M</code> number of time slices in the periodic orbit guess</li><li><code>amplitude</code>: amplitude of the periodic orbit guess</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/efbbc550819c59e67e558e5e626a8db46b7183f2/src/periodicorbit/PeriodicOrbitUtils.jl#L2-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.computeNormalForm" href="#BifurcationKit.computeNormalForm"><code>BifurcationKit.computeNormalForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">computeNormalForm(F, dF, d2F, d3F, br, id_bif; δ, nev, Jᵗ, verbose, ζs, lens, issymmetric, Teigvec, scaleζ)
</code></pre><p>Compute the normal form of the bifurcation point located at <code>br.bifpoint[ind_bif]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>F, dF, d2F, d3F</code> vector field <code>(x, p) -&gt; F(x, p)</code> and its derivatives w.r.t. <code>x</code>.</li><li><code>br</code> result from a call to <a href="#BifurcationKit.continuation"><code>continuation</code></a></li><li><code>ind_bif</code> index of the bifurcation point in <code>br.bifpoint</code></li></ul><p><strong>Optional arguments</strong></p><ul><li><code>δ</code> used to compute ∂pF with finite differences</li><li><code>nev</code> number of eigenvalues used to compute the spectral projection. This number has to be adjusted when used with iterative methods.</li><li><code>Jᵗ = (x,p) -&gt; ...</code> jacobian adjoint, it should be implemented in an efficient manner. For matrix-free methods, <code>transpose</code> is not readily available and the user must provide a dedicated method. In the case of sparse based jacobian, <code>Jᵗ</code> should not be passed as it is computed internally more efficiently, i.e. it avoid recomputing the jacobian as it would be if you pass <code>Jᵗ = (x, p) -&gt; transpose(dF(x, p))</code>.</li><li><code>verbose</code> whether to display information</li><li><code>ζs</code> list of vectors spanning the kernel of <code>dF</code> at the bifurcation point. Useful to enforce the basis for the normal form.</li><li><code>lens::Lens</code> specify which parameter to take the partial derivative ∂pF</li><li><code>issymmetric</code> whether the Jacobian is Symmetric, avoid computing the left eigenvectors.</li><li><code>scaleζ</code> function to normalise the kernel basis. Indeed, when used with large vectors and <code>norm</code>, it results in ζs and the normal form coeffocient being super small.</li></ul><p>Based on Golubitsky, Martin, David G Schaeffer, and Ian Stewart. Singularities and Groups in Bifurcation Theory. New York: Springer-Verlag, 1985, VI.1.d page 295.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/efbbc550819c59e67e558e5e626a8db46b7183f2/src/NormalForms.jl#L344">source</a></section></article><h2 id="Newton-1"><a class="docs-heading-anchor" href="#Newton-1">Newton</a><a class="docs-heading-anchor-permalink" href="#Newton-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.newton" href="#BifurcationKit.newton"><code>BifurcationKit.newton</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">	newton(F, J, x0, p0, options::NewtonPar; normN = norm, callback = (x, f, J, res, iteration, itlinear, optionsN; kwargs...) -&gt; true, kwargs...)</code></pre><p>This is the Newton-Krylov Solver for <code>F(x, p0) = 0</code> with Jacobian w.r.t. <code>x</code> written <code>J(x, p0)</code> and initial guess <code>x0</code>. The function <code>normN</code> allows to specify a norm for the convergence criteria. It is important to set the linear solver <code>options.linsolver</code> properly depending on your problem. This linear solver is used to solve <span>$J(x, p_0)u = -F(x, p_0)$</span> in the Newton step. You can for example use <code>linsolver = DefaultLS()</code> which is the operator backslash: it works well for Sparse / Dense matrices. See <a href="../linearsolver/#Linear-solvers-(LS)-1">Linear solvers (LS)</a> for more informations.</p><p><strong>Arguments:</strong></p><ul><li><code>F</code> is a function with input arguments <code>(x, p)</code> returning a vector <code>r</code> that represents the functional and for type stability, the types of <code>x</code> and <code>r</code> should match. In particular, it is not <strong>inplace</strong>.</li><li><code>J</code> is the jacobian of <code>F</code> at <code>(x, p)</code>. It can assume two forms. Either <code>J</code> is a function and <code>J(x, p)</code> returns a <code>::AbstractMatrix</code>. In this case, the default arguments of <code>NewtonPar</code> will make <code>newton</code> work. Or <code>J</code> is a function and <code>J(x, p)</code> returns a function taking one argument <code>dx</code> and returns <code>dr</code> of the same type of <code>dx</code>. In our notation, <code>dr = J * dx</code>. In this case, the default parameters of <code>NewtonPar</code> will not work and you have to use a Matrix Free linear solver, for example <code>GMRESIterativeSolvers</code>.</li><li><code>x0</code> initial guess</li><li><code>p0</code> set of parameters to be passed to <code>F</code> and <code>J</code></li><li><code>options</code> variable holding the internal parameters used by the <code>newton</code> method</li><li><code>callback</code> function passed by the user which is called at the end of each iteration. Can be used to update a preconditionner for example. The arguments passed to the callback are as follows<ul><li><code>x</code> current solution</li><li><code>f</code> current residual</li><li><code>J</code> current jacobian</li><li><code>res</code> current norm of the residual</li><li><code>iteration</code> current newton iteration</li><li><code>itlinear</code> number of iterations to solve the linear system</li><li><code>optionsN</code> a copy of the argument <code>options</code> passed to <code>newton</code></li><li><code>kwargs</code> kwargs arguments, contain your initial guess <code>x0</code></li></ul></li><li><code>kwargs</code> arguments passed to the callback. Useful when <code>newton</code> is called from <code>continuation</code></li></ul><p><strong>Output:</strong></p><ul><li>solution:</li><li>history of residuals</li><li>flag of convergence</li><li>number of iterations</li></ul><p><strong>Simplified calls</strong></p><p>When <code>J</code> is not passed, the jacobian <strong>matrix</strong> is then computed with finite differences (beware of large systems of equations!). The call is as follows:</p><pre><code class="language-none">newton(F, x0, p0, options::NewtonPar; kwargs...)</code></pre><p>You can also pass functions which do not have parameters <code>x -&gt; F(x)</code>, <code>x -&gt; J(x)</code> as follows</p><pre><code class="language-none">newton(F, J, x0, options::NewtonPar;  kwargs...)</code></pre><p>or</p><pre><code class="language-none">newton(F, x0, options::NewtonPar;  kwargs...)</code></pre><p><strong>Example</strong></p><pre><code class="language-none">julia&gt; F(x, p) = x.^3 .- 1
julia&gt; Jac(x, p) = spdiagm(0 =&gt; 3 .* x.^2) # sparse jacobian
julia&gt; x0 = rand(1_000)
julia&gt; opts = NewtonPar()
julia&gt; sol, hist, flag, _ = newton(F, Jac, x0, nothing, opts, normN = x-&gt;norm(x, Inf))</code></pre><div class="admonition is-success"><header class="admonition-header">Other formulation</header><div class="admonition-body"><p>If you don&#39;t have parameters, you can still use <code>newton</code> as follows <code>newton((x,p) -&gt; F(x), (x,p)-&gt; J(x), x0, nothing, options)</code></p></div></div><div class="admonition is-warning"><header class="admonition-header">Linear solver</header><div class="admonition-body"><p>Make sure that the linear solver (Matrix-Free...) corresponds to your jacobian (Matrix-Free vs. Matrix based).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/efbbc550819c59e67e558e5e626a8db46b7183f2/src/Newton.jl#L33-L89">source</a></section><section><div><pre><code class="language-none">function newton(F, J, x0::vectype, p0, options:: NewtonPar{T}, defOp::DeflationOperator{T, Tf, vectype}, linsolver = DeflatedLinearSolver(); kwargs...) where {T, Tf, vectype}</code></pre><p>This is the deflated version of the Krylov-Newton Solver for <code>F(x, p0) = 0</code> with Jacobian <code>J(x, p0)</code>. We refer to <a href="#BifurcationKit.newton"><code>newton</code></a> for more information. It penalises the roots saved in <code>defOp.roots</code>. The other arguments are as for <code>newton</code>. See <a href="#BifurcationKit.DeflationOperator"><code>DeflationOperator</code></a> for more information.</p><p><strong>Arguments</strong></p><p>Compared to <a href="#BifurcationKit.newton"><code>newton</code></a>, the only different arguments are</p><ul><li><code>defOp</code> deflation operator</li><li><code>linsolver</code> linear solver used to invert the Jacobian of the deflated functional. We have a custom solver <code>DeflatedLinearSolver()</code> with requires solving two linear systems <code>J⋅x = rhs</code>. For other linear solvers, a matrix free method is used for the deflated functional.</li></ul><p><strong>Output:</strong></p><ul><li>solution:</li><li>history of residuals</li><li>flag of convergence</li><li>number of iterations</li></ul><p><strong>Simplified call</strong></p><p>When <code>J</code> is not passed. It then computed with finite differences. The call is as follows:</p><pre><code class="language-none">newton(F, x0, p0, options, defOp; kwargs...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/efbbc550819c59e67e558e5e626a8db46b7183f2/src/DeflationOperator.jl#L154-L174">source</a></section><section><div><p>This specific Newton-Kyrlov method first tries to converge to a solution <code>sol0</code> close the guess <code>x0</code>. It then attempts to converge to the guess <code>x1</code> while avoiding the previous solution <code>sol0</code>. This is very handy for branch switching. The method is based on a deflated Newton-Krylov solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/efbbc550819c59e67e558e5e626a8db46b7183f2/src/DeflationOperator.jl#L204">source</a></section><section><div><pre><code class="language-julia">newton(F, J, br, ind_bif; Jᵗ, d2F, normN, options, startWithEigen, kwargs...)
</code></pre><p>This function turns an initial guess for a Fold/Hopf point into a solution to the Fold/Hopf problem based on a Minimally Augmented formulation. The arguments are as follows</p><ul><li><code>F  = (x, p) -&gt; F(x, p)</code> where <code>p</code> is a set of parameters.</li><li><code>J  = (x, p) -&gt; d_xF(x, p)</code> associated jacobian</li><li><code>br</code> results returned after a call to <a href="#BifurcationKit.continuation"><code>continuation</code></a></li><li><code>ind_bif</code> bifurcation index in <code>br</code></li><li><code>lens</code> parameter axis used to locate the Fold/Hopf point.</li><li><code>options::NewtonPar</code></li></ul><p><strong>Optional arguments:</strong></p><ul><li><code>Jᵗ = (x, p) -&gt; transpose(d_xF(x, p))</code> jacobian adjoint, it should be implemented in an efficient manner. For matrix-free methods, <code>transpose</code> is not readily available and the user must provide a dedicated method. In the case of Matrix / Sparse based jacobian, <code>Jᵗ</code> should not be passed as it is computed internally more efficiently, i.e. it avoid recomputing the jacobian as it would be if you pass <code>Jᵗ = (x, p) -&gt; transpose(dF(x, p))</code></li><li><code>d2F = (x, p, v1, v2) -&gt;  d2F(x, p, v1, v2)</code> a bilinear operator representing the hessian of <code>F</code>. It has to provide an expression for <code>d2F(x,p)[v1,v2]</code>.</li><li><code>normN = norm</code></li><li><code>options</code> You can pass newton parameters different from the ones stored in <code>br</code> by using this argument <code>options</code>.</li><li><code>bdlinsolver</code> bordered linear solver for the constraint equation</li><li><code>startWithEigen = false</code> whether to start thr Minimally Augmented probblem with information from eigen elements</li><li><code>kwargs</code> keywords arguments to be passed to the regular Newton-Krylov solver</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/efbbc550819c59e67e558e5e626a8db46b7183f2/src/codim2/codim2.jl#L1">source</a></section><section><div><pre><code class="language-julia">newton(prob, orbitguess, par, options; linearPO, δ, kwargs...)
</code></pre><p>This is the Newton-Krylov Solver for computing a periodic orbit using (Standard / Poincaré) Shooting method. Note that the linear solver has to be apropriately set up in <code>options</code>.</p><p><strong>Arguments</strong></p><p>Similar to <a href="#BifurcationKit.newton"><code>newton</code></a> except that <code>prob</code> is either a <a href="#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a> or a <a href="#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a>. These two problems have specific options to be tuned, we refer to their link for more information and to the tutorials.</p><ul><li><code>prob</code> a problem of type <code>&lt;: AbstractShootingProblem</code> encoding the shooting functional G.</li><li><code>orbitguess</code> a guess for the periodic orbit. See <a href="#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a> and See <a href="#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a> for information regarding the shape of <code>orbitguess</code>.</li><li><code>par</code> parameters to be passed to the functional</li><li><code>options</code> same as for the regular <a href="#BifurcationKit.newton"><code>newton</code></a> method.</li></ul><p><strong>Optional argument</strong></p><ul><li><code>linearPO</code> Specify the choice of the linear algorithm, which must belong to <code>[:autodiffMF, :MatrixFree, :autodiffDense, :FiniteDifferences]</code>. This is used to select a way of inverting the jacobian dG<ul><li>For <code>:MatrixFree</code>, we use an iterative solver (e.g. GMRES) to solve the linear system. The jacobian was specified by the user in <code>prob</code>.</li><li>For <code>:autodiffMF</code>, we use iterative solver (e.g. GMRES) to solve the linear system. We use Automatic Differentiation to compute the (matrix-free) derivative of <code>x -&gt; prob(x, p)</code>.</li><li>For <code>:autodiffDense</code>. Same as for <code>:autodiffMF</code> but the jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one using <code>options</code>.</li><li>For <code>:FiniteDifferencesDense</code>, same as for <code>:autodiffDense</code> but we use Finite Differences to compute the jacobian of <code>x -&gt; prob(x, p)</code> using the <code>δ = 1e-8</code> which can be passed as an argument.</li></ul></li></ul><p><strong>Output:</strong></p><ul><li>solution</li><li>history of residuals</li><li>flag of convergence</li><li>number of iterations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/efbbc550819c59e67e558e5e626a8db46b7183f2/src/periodicorbit/PeriodicOrbits.jl#L72">source</a></section><section><div><pre><code class="language-julia">newton(prob, orbitguess, par, options, defOp; linearPO, kwargs...)
</code></pre><p>This is the deflated Newton-Krylov Solver for computing a periodic orbit using a (Standard / Poincaré) Shooting method.</p><p><strong>Arguments</strong></p><p>Similar to <a href="#BifurcationKit.newton"><code>newton</code></a> except that <code>prob</code> is either a <a href="#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a> or a <a href="#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a>.</p><p><strong>Optional argument</strong></p><ul><li><code>linearPO</code> Specify the choice of the linear algorithm, which must belong to <code>[:autodiffMF, :MatrixFree, :autodiffDense, :FiniteDifferences]</code>. This is used to select a way of inverting the jacobian dG<ul><li>For <code>:MatrixFree</code>, we use an iterative solver (e.g. GMRES) to solve the linear system. The jacobian was specified by the user in <code>prob</code>.</li><li>For <code>:autodiffMF</code>, we use iterative solver (e.g. GMRES) to solve the linear system. We use Automatic Differentiation to compute the (matrix-free) derivative of <code>x -&gt; prob(x, p)</code>.</li><li>For <code>:autodiffDense</code>. Same as for <code>:autodiffMF</code> but the jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one using <code>options</code>.</li><li>For <code>:FiniteDifferencesDense</code>, same as for <code>:autodiffDense</code> but we use Finite Differences to compute the jacobian of <code>x -&gt; prob(x, p)</code> using the <code>δ = 1e-8</code> which can be passed as an argument.</li></ul></li></ul><p><strong>Output:</strong></p><ul><li>solution</li><li>history of residuals</li><li>flag of convergence</li><li>number of iterations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/efbbc550819c59e67e558e5e626a8db46b7183f2/src/periodicorbit/PeriodicOrbits.jl#L116">source</a></section><section><div><pre><code class="language-julia">newton(probPO, orbitguess, par, options; linearPO, kwargs...)
</code></pre><p>This is the Newton-Krylov Solver for computing a periodic orbit using a functional G based on Finite Differences and a Trapezoidal rule.</p><p><strong>Arguments:</strong></p><ul><li><code>prob</code> a problem of type <a href="#BifurcationKit.PeriodicOrbitTrapProblem"><code>PeriodicOrbitTrapProblem</code></a> encoding the functional G</li><li><code>orbitguess</code> a guess for the periodic orbit where <code>orbitguess[end]</code> is an estimate of the period of the orbit. It should be a vector of size <code>N * M + 1</code> where <code>M</code> is the number of time slices, <code>N</code> is the dimension of the phase space. This must be compatible with the numbers <code>N,M</code> in <code>prob</code>.</li><li><code>par</code> parameters to be passed to the functional</li><li><code>options</code> same as for the regular <code>newton</code> method</li><li><code>linearPO = :BorderedLU</code>. Specify the choice of the linear algorithm, which must belong to <code>[:FullLU, :FullSparseInplace, :BorderedLU, :FullMatrixFree, :BorderedMatrixFree, :FullSparseInplace]</code>. This is used to select a way of inverting the jacobian <code>dG</code> of the functional G.<ul><li>For <code>:FullLU</code>, we use the default linear solver based on a sparse matrix representation of <code>dG</code>. This matrix is assembled at each newton iteration. This is the default algorithm.</li><li>For <code>:FullSparseInplace</code>, this is the same as for <code>:FullLU</code> but the sparse matrix <code>dG</code> is updated inplace. This method allocates much less. In some cases, this is significantly faster than using <code>:FullLU</code>. Note that this method can only be used if the sparsity pattern of the jacobian is always the same.</li><li>For <code>:Dense</code>, same as above but the matrix <code>dG</code> is dense. It is also updated inplace. This option is useful to study ODE of small dimension.</li><li>For <code>:BorderedLU</code>, we take advantage of the bordered shape of the linear solver and use a LU decomposition to invert <code>dG</code> using a bordered linear solver. This is the default algorithm.</li><li>For <code>:BorderedSparseInplace</code>, this is the same as for <code>:BorderedLU</code> but the cyclic matrix <code>dG</code> is updated inplace. This method allocates much less. In some cases, this is significantly faster than using <code>:FullLU</code>. Note that this method can only be used if the sparsity pattern of the jacobian is always the same.</li><li>For <code>:FullMatrixFree</code>, a matrix free linear solver is used for <code>dG</code>: note that a preconditioner is very likely required here because of the cyclic shape of <code>dG</code> which affects negatively the convergence properties of GMRES.</li><li>For <code>:BorderedMatrixFree</code>, a matrix free linear solver is used but for <code>Jc</code> only (see docs): it means that <code>options.linsolver</code> is used to invert <code>Jc</code>. These two Matrix-Free options thus expose different part of the jacobian <code>dG</code> in order to use specific preconditioners. For example, an ILU preconditioner on <code>Jc</code> could remove the constraints in <code>dG</code> and lead to poor convergence. Of course, for these last two methods, a preconditioner is likely to be required.</li></ul></li></ul><p><strong>Output:</strong></p><ul><li>solution</li><li>history of residuals</li><li>flag of convergence</li><li>number of iterations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/efbbc550819c59e67e558e5e626a8db46b7183f2/src/periodicorbit/PeriodicOrbitTrapeze.jl#L792">source</a></section><section><div><pre><code class="language-none">newton(probPO::PeriodicOrbitTrapProblem, orbitguess, options::NewtonPar, defOp::DeflationOperator{T, Tf, vectype}, linearPO = :BorderedLU; kwargs...) where {T, Tf, vectype}</code></pre><p>This function is similar to <code>newton(probPO, orbitguess, options, linearPO; kwargs...)</code> except that it uses deflation in order to find periodic orbits different from the ones stored in <code>defOp</code>. We refer to the mentioned method for a full description of the arguments. The current method can be used in the vicinity of a Hopf bifurcation to prevent the Newton-Krylov algorithm from converging to the equilibrium point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/efbbc550819c59e67e558e5e626a8db46b7183f2/src/periodicorbit/PeriodicOrbitTrapeze.jl#L819-L823">source</a></section></article><h2 id="Continuation-1"><a class="docs-heading-anchor" href="#Continuation-1">Continuation</a><a class="docs-heading-anchor-permalink" href="#Continuation-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.continuation" href="#BifurcationKit.continuation"><code>BifurcationKit.continuation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">continuation(F, J, x0, par, lens::Lens, contParams::ContinuationPar; plot = false, normC = norm, dotPALC = (x,y) -&gt; dot(x,y) / length(x), printSolution = norm, plotSolution = (x, p; kwargs...)-&gt;nothing, finaliseSolution = (z, tau, step, contResult; kwargs...) -&gt; true, callbackN = (x, f, J, res, iteration, itlinear, options; kwargs...) -&gt; true, linearAlgo = BorderingBLS(), tangentAlgo = SecantPred(), verbosity = 0)</code></pre><p>Compute the continuation curve associated to the functional <code>F</code> and its jacobian <code>J</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>F</code> is a function with input arguments <code>(x, p)</code>, where <code>p</code> is the set of parameters passed to <code>F</code>, and returning a vector <code>r</code> that represents the functional. For type stability, the types of <code>x</code> and <code>r</code> should match. In particular, it is not <strong>inplace</strong>,</li><li><code>J</code> is the jacobian of <code>F</code> at <code>(x, p)</code>. It can assume three forms.<ol><li>Either <code>J</code> is a function and <code>J(x,p)</code> returns a <code>::AbstractMatrix</code>. In this case, the default arguments of <code>contParams::ContinuationPar</code> will make <code>continuation</code> work.</li><li>Or <code>J</code> is a function and <code>J(x, p)</code> returns a function taking one argument <code>dx</code> and returning <code>dr</code> of the same type as <code>dx</code>. In our notation, <code>dr = J * dx</code>. In this case, the default parameters of <code>contParams::ContinuationPar</code> will not work and you have to use a Matrix Free linear solver, for example <code>GMRESIterativeSolvers</code>,</li><li>Or <code>J</code> is a function and <code>J(x, p)</code> returns a variable <code>j</code> which can assume any type. Then, you must implement a linear solver <code>ls</code> as a composite type, subtype of <code>AbstractLinearSolver</code> which is called like <code>ls(j, rhs)</code> and which returns the solution of the jacobian linear system. See for example <code>examples/SH2d-fronts-cuda.jl</code>. This linear solver is passed to <code>NewtonPar(linsolver = ls)</code> which itself passed to <code>ContinuationPar</code>. Similarly, you have to implement an eigensolver <code>eig</code> as a composite type, subtype of <code>AbstractEigenSolver</code>.</li></ol></li><li><code>x0</code> initial guess,</li><li><code>par</code> initial set of parameters,</li><li><code>lens::Lens</code> specifies which parameter axis among <code>par</code> is used for continuation. For example, if <code>par = (α = 1.0, β = 1)</code>, we can perform continuation w.r.t. <code>α</code> by using <code>lens = (@lens _.α)</code>. If you have an array <code>par = [ 1.0, 2.0]</code> and want to perform continuation w.r.t. the first variable, you can use <code>lens = (@lens _[1])</code>. For more information, we refer to <code>SetField.jl</code>.</li><li><code>contParams</code> parameters for continuation. See <a href="#BifurcationKit.ContinuationPar"><code>ContinuationPar</code></a> for more information about the options</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>plot = false</code> whether to plot the solution while computing</li><li><code>printSolution = (x, p) -&gt; norm(x)</code> function used to plot in the continuation curve. It is also used in the way results are saved. It could be <code>norm</code> or <code>(x, p) -&gt; x[1]</code>. This is also useful when saving several huge vectors is not possible for memory reasons (for example on GPU...). This function can return pretty much everything but you should keep it small. For example, you can do <code>(x, p) -&gt; (x1 = x[1], x2 = x[2], nrm = norm(x))</code> or simply <code>(x, p) -&gt; (sum(x), 1)</code>. This will be stored in <code>contres.branch</code> (see below).</li><li><code>plotSolution = (x, p; kwargs...) -&gt; nothing</code> function implementing the plot of the solution.</li><li><code>finaliseSolution = (z, tau, step, contResult; kwargs...) -&gt; true</code> Function called at the end of each continuation step. Can be used to alter the continuation procedure (stop it by returning false), saving personal data, plotting... The notations are <span>$z=(x,p)$</span>, <code>tau</code> is the tangent at <code>z</code> (see below), <code>step</code> is the index of the current continuation step and <code>ContResult</code> is the current branch. Note that you can have a better control over the continuation procedure by using an iterator, see <a href="../iterator/#Iterator-Interface-1">Iterator Interface</a>.</li><li><code>callbackN</code> callback for newton iterations. see docs for <a href="#BifurcationKit.newton"><code>newton</code></a>. Can be used to change preconditioners</li><li><code>tangentAlgo = SecantPred()</code> controls the algorithm used to predict the tangents along the curve of solutions or the corrector. Can be <code>NaturalPred</code>, <code>SecantPred</code> or <code>BorderedPred</code>. See below for more information.</li><li><code>linearAlgo = BorderingBLS()</code>. Used to control the way the extended linear system associated to the continuation problem is solved. Can be <code>MatrixBLS</code>, <code>BorderingBLS</code> or <code>MatrixFreeBLS</code>.</li><li><code>verbosity::Int</code> controls the amount of information printed during the continuation process. Must belong to <code>{0,1,2,3}</code></li><li><code>normC = norm</code> norm used in the different Newton solves</li><li><code>dotPALC = (x, y) -&gt; dot(x, y) / length(x)</code>, dot product used to define the weighted dot product (resp. norm) <span>$\|(x, p)\|^2_\theta$</span> in the constraint <span>$N(x, p)$</span> (see below). This arguement can be used to remove the factor <code>1/length(x)</code> for example in problems where the dimension of the state space changes (mesh adaptation, ...)</li><li><code>filename</code> name of a file to save the computed branch during continuation. The identifier .jld2 will be appended to this filename</li><li><code>bothside=true</code> compute the branches on the two sides of <code>p0</code>, merge them and return it.</li></ul><p><strong>Outputs:</strong></p><ul><li><code>contres::ContResult</code> composite type which contains the computed branch. See <a href="#BifurcationKit.ContResult"><code>ContResult</code></a> for more information.</li><li><code>u::BorderedArray</code> the last solution computed on the branch</li></ul><div class="admonition is-success"><header class="admonition-header">Controlling the argument `linearAlgo`</header><div class="admonition-body"><p>In this simplified interface to <code>continuation</code>, the argument <code>linearAlgo</code> is internally overwritten to provide a valid argument to the algorithm. If you do not want this to happen, call directly <code>continuation(F, J, x0, par, lens, contParams, linearAlgo; kwargs...)</code>.</p></div></div><div class="admonition is-success"><header class="admonition-header">Continuing the branch in the opposite direction</header><div class="admonition-body"><p>Just change the sign of <code>ds</code> in <code>ContinuationPar</code>.</p></div></div><p><strong>Simplified call:</strong></p><p>You can also use the following call for which the jacobian <strong>matrix</strong> (beware of large systems of equations!) is computed internally using Finite Differences</p><pre><code class="language-none">continuation(Fhandle, x0, par, lens, contParams::ContinuationPar; kwargs...)</code></pre><p><strong>Method</strong></p><p><strong>Bordered system of equations</strong></p><p>In what follows, we abuse of notations, <code>p</code> refers to the scalar value of the parameter we perform continuation with. Hence, it should be <code>p = get(par, lens)</code>.</p><p>The pseudo-arclength continuation method solves the equation <span>$F(x, p) = 0$</span> (of dimension N) together with the pseudo-arclength constraint <span>$N(x, p) = \frac{\theta}{length(x)} \langle x - x_0, dx_0\rangle + (1 - \theta)\cdot(p - p_0)\cdot dp_0 - ds = 0$</span> and <span>$\theta\in[0,1]$</span> (see Keller, Herbert B. Lectures on Numerical Methods in Bifurcation Problems. Springer, 1988). In practice, a curve <span>$\gamma$</span> of solutions is sought and is parametrised by <span>$s$</span>: <span>$\gamma(s) = (x(s), p(s))$</span> is a curve of solutions to <span>$F(x, p)$</span>. This formulation allows to pass turning points (where the implicit theorem fails). In the previous formula, <span>$(x_0, p_0)$</span> is a solution for a given <span>$s_0$</span>, <span>$\tau_0\equiv(dx_0, dp_0)$</span> is the tangent to the curve <span>$\gamma$</span> at <span>$s_0$</span>. Hence, to compute the curve of solutions, we need to solve an equation of dimension N+1 which is called a Bordered system.</p><div class="admonition is-warning"><header class="admonition-header">Parameter `theta`</header><div class="admonition-body"><p>The parameter <code>theta</code> in the struct <code>ContinuationPar</code>is very important. It should be tuned for the continuation to work properly especially in the case of large problems where the <span>$\langle x - x_0, dx_0\rangle$</span> component in the constraint might be favoured too much. Also, large <code>theta</code>s favour <code>p</code> as the corresponding term in <span>$N$</span> involves the term <span>$1-\theta$</span>.</p></div></div><p>The parameter ds is adjusted internally depending on the number of Newton iterations and other factors. See the function <code>stepSizeControl</code> for more information. An important parameter to adjust the magnitude of this adaptation is the parameter <code>a</code> in the struct <code>ContinuationPar</code>.</p><p><strong>Algorithm</strong></p><p>The algorithm works as follows:</p><ol><li>Start from a known solution <span>$(x_0, p_0)$</span> with tangent to the curve of solutions: <span>$(dx_0 ,dp_0)$</span></li><li><strong>Predictor:</strong> set <span>$(x_1, p_1) = (x_0, p_0) + ds\cdot (dx_0, dp_0)$</span>. Note that a different predictor can be used.</li><li><strong>Corrector:</strong> solve <span>$F(x, p)=0,\ N(x, p)=0$</span> with a (Bordered) Newton Solver with initial guess <span>$(x_1, p_1)$</span>.<ul><li>if Newton in 3. did not converge, update ds/2 ⟶ ds in <span>$N$</span> and go to 1.</li></ul></li><li><strong>New tangent:</strong> Compute a new tangent (see below) <span>$(dx_1, dp_1)$</span> and update <span>$N$</span> with it. Set <span>$(x_0, p_0, dx_0, dp_0) = (x_1, p_1, dx_1, dp_1)$</span> and return to step 2</li></ol><p><strong>Natural continuation</strong></p><p>We speak of <em>natural</em> continuation when we do not consider the constraint <span>$N(x, p)=0$</span>. Knowing <span>$(x_0, p_0)$</span>, we use <span>$x_0$</span> as a guess for solving <span>$F(x, p_1)=0$</span> with <span>$p_1$</span> close to <span>$p_0$</span>. Again, this fails at Turning points but it can be faster to compute than the constrained case. This is set by the option <code>tangentAlgo = NaturalPred()</code> in <code>continuation</code>.</p><p><strong>Tangent computation (step 4)</strong></p><p>There are various ways to compute <span>$(dx_1, dp_1)$</span>. The first one is called secant and is parametrised by the option <code>tangentAlgo = SecantPred()</code>. It is computed by <span>$(dx_1, dp_1) = (z_1, p_1) - (z_0, p_0)$</span> and normalised by the norm <span>$\|(x, p)\|^2_\theta = \frac{\theta}{length(x)} \langle x,x\rangle + (1 - \theta)\cdot p^2$</span>. Another method is to compute <span>$(dx_1, dp_1)$</span> by solving solving the bordered linear system <span>$\begin{bmatrix} F_x &amp; F_p	; \ \frac{\theta}{length(x)}dx_0 &amp; (1-\theta)dp_0\end{bmatrix}\begin{bmatrix}dx_1 ;  dp_1\end{bmatrix} =\begin{bmatrix}0 ; 1\end{bmatrix}$</span> ; it is set by the option <code>tangentAlgo = BorderedPred()</code>.</p><p><strong>Bordered linear solver</strong></p><p>When solving the Bordered system <span>$F(x, p) = 0,\ N(x, p)=0$</span>, one faces the issue of solving the Bordered linear system <span>$\begin{bmatrix} J &amp; a	; b^T &amp; c\end{bmatrix}\begin{bmatrix}X ;  y\end{bmatrix} =\begin{bmatrix}R ; n\end{bmatrix}$</span>. This can be solved in many ways via bordering (which requires two Jacobian inverses), by forming the bordered matrix (which works well for sparse matrices) or by using a full Matrix Free formulation. The choice of method is set by the argument <code>linearAlgo</code>. Have a look at the struct <code>linearBorderedSolver</code> for more information.</p><p><strong>Linear Algebra</strong></p><p>Let us discuss here more about the norm and dot product. First, the option <code>normC</code> gives a norm that is used to evaluate the residual in the following way: <span>$max(normC(F(x,p)), \|N(x,p)\|)&lt;tol$</span>. It is thus used as a stopping criterion for a Newton algorithm. The dot product (resp. norm) used in <span>$N$</span> and in the (iterative) linear solvers is <code>LinearAlgebra.dot</code> (resp. <code>LinearAlgebra.norm</code>). It can be changed by importing these functions and redefining it. Not that by default, the <span>$L^2$</span> norm is used. These details are important because of the constraint <span>$N$</span> which incorporates the factor <code>length</code>. For some custom composite type implementing a Vector space, the dot product could already incorporates the <code>length</code> factor in which case you should either redefine the dot product or change <span>$\theta$</span>.</p><p><strong>Step size control</strong></p><p>As explained above, each time the corrector phased failed, the step size <span>$ds$</span> is halved. This has the disavantage of having lost Newton iterations (which costs time) and impose small steps (which can be slow as well). To prevent this, the step size is controlled internally with the idea of having a constant number of Newton iterations per point. This is in part controlled by the aggressiveness factor <code>a</code> in <code>ContinuationPar</code>. Further tuning is performed by using <code>doArcLengthScaling=true</code> in <code>ContinuationPar</code>. This adjusts internally <span>$\theta$</span> so that the relative contributions of <span>$x$</span> and <span>$p$</span> are balanced in the constraint <span>$N$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/efbbc550819c59e67e558e5e626a8db46b7183f2/src/Continuation.jl#L395-L480">source</a></section><section><div><pre><code class="language-julia">continuation(Fhandle, Jhandle, x0, par0, x1, p1, lens, contParams; linearAlgo, kwargs...)
</code></pre><p>This function is the analog of <a href="#BifurcationKit.continuation"><code>continuation</code></a> when the two first points on the branch are passed (instead of a single one). Hence <code>x0</code> is the first point on the branch (with palc <code>s=0</code>) with parameter <code>par0</code> and <code>x1</code> is the second point with parameter <code>set(par0, lens, p1)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/efbbc550819c59e67e558e5e626a8db46b7183f2/src/bifdiagram/BranchSwitching.jl#L1">source</a></section><section><div><pre><code class="language-julia">continuation(F, dF, d2F, d3F, br, ind_bif, optionsCont; Jᵗ, δ, δp, ampfactor, nev, issymmetric, usedeflation, Teigvec, scaleζ, verbosedeflation, maxIterDeflation, perturb, kwargs...)
</code></pre><p>Automatic branch switching at branch points based on a computation of the normal form. More information is provided in <a href="@ref">Branch switching</a>. An example of use is provided in <a href="../mittelmann/#A-generalized-Bratu–Gelfand-problem-in-two-dimensions-1">A generalized Bratu–Gelfand problem in two dimensions</a>.</p><p><strong>Arguments</strong></p><ul><li><code>F, dF, d2F, d3F</code>: function <code>(x, p) -&gt; F(x, p)</code> and its differentials <code>(x, p, dx) -&gt; d1F(x, p, dx)</code>, <code>(x, p, dx1, dx2) -&gt; d2F(x, p, dx1, dx2)</code>...</li><li><code>br</code> branch result from a call to <a href="#BifurcationKit.continuation"><code>continuation</code></a></li><li><code>ind_bif</code> index of the bifurcation point in <code>br</code> from which you want to branch from</li><li><code>optionsCont</code> options for the call to <a href="#BifurcationKit.continuation"><code>continuation</code></a></li></ul><p><strong>Optional arguments</strong></p><ul><li><code>Jᵗ</code> associated jacobian transpose, it should be implemented in an efficient manner. For matrix-free methods, <code>transpose</code> is not readily available and the user must provide a dedicated method. In the case of sparse based jacobian, <code>Jᵗ</code> should not be passed as it is computed internally more efficiently, i.e. it avoid recomputing the jacobian as it would be if you pass <code>Jᵗ = (x, p) -&gt; transpose(dF(x, p))</code>.</li><li><code>δ</code> used internally to compute derivatives w.r.t the parameter <code>p</code>.</li><li><code>δp</code> used to specify a particular guess for the parameter on the bifurcated branch which is otherwise determined by <code>optionsCont.ds</code>. This allows to use a step larger than <code>optionsCont.dsmax</code>.</li><li><code>ampfactor = 1</code> factor which alter the amplitude of the bifurcated solution. Useful to magnify the bifurcated solution when the bifurcated branch is very steep.</li><li><code>nev</code> number of eigenvalues to be computed to get the right eigenvector</li><li><code>issymmetric</code> whether the Jacobian is Symmetric, avoid computing the left eigenvectors in the computation of the reduced equation.</li><li><code>usedeflation = true</code> whether to use nonlinear deflation (see <a href="../deflatedproblem/#Deflated-problems-1">Deflated problems</a>) to help finding the guess on the bifurcated branch</li><li><code>kwargs</code> optional arguments to be passed to <a href="#BifurcationKit.continuation"><code>continuation</code></a>, the regular <code>continuation</code> one.</li></ul><div class="admonition is-success"><header class="admonition-header">Advanced use</header><div class="admonition-body"><p>In the case of a very large model and use of special hardware (GPU, cluster), we suggest to discouple the computation of the reduced equation, the predictor and the bifurcated branches. Have a look at <code>methods(BifurcationKit.multicontinuation)</code> to see how to call these versions. It has been tested on GPU with very high memory pressure.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/efbbc550819c59e67e558e5e626a8db46b7183f2/src/bifdiagram/BranchSwitching.jl#L35">source</a></section><section><div><pre><code class="language-julia">continuation(F, J, par, lens, contParams, defOp; verbosity, maxBranches, seekEveryStep, showplot, tangentAlgo, linearAlgo, dotPALC, printSolution, 377, plotSolution, perturbSolution, 380, callbackN, acceptSolution, normN)
</code></pre><p>The function computes the set of curves of solutions <code>γ(s) = (x(s), p(s))</code> to the equation <code>F(x,p)=0</code> based on the algorithm of <strong>deflated continuation</strong> as described in Farrell, Patrick E., Casper H. L. Beentjes, and Ásgeir Birkisson. “The Computation of Disconnected Bifurcation Diagrams.” ArXiv:1603.00809 [Math], March 2, 2016. http://arxiv.org/abs/1603.00809.</p><p>Depending on the options in <code>contParams</code>, it can locate the bifurcation points on each branch. Note that you can specify different predictors using <code>tangentAlgo</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>F</code> is a function with input arguments <code>(x, p)</code>, where <code>p</code> is the set of parameters passed to <code>F</code>, and returning a vector <code>r</code> that represents the functional. For type stability, the types of <code>x</code> and <code>r</code> should match. In particular, it is not <strong>inplace</strong>,</li><li><code>J</code> is the jacobian of <code>F</code> at <code>(x, p)</code>. It can assume three forms.<ol><li>Either <code>J</code> is a function and <code>J(x,p)</code> returns a <code>::AbstractMatrix</code>. In this case, the default arguments of <code>contParams::ContinuationPar</code> will make <code>continuation</code> work.</li><li>Or <code>J</code> is a function and <code>J(x, p)</code> returns a function taking one argument <code>dx</code> and returning <code>dr</code> of the same type as <code>dx</code>. In our notation, <code>dr = J * dx</code>. In this case, the default parameters of <code>contParams::ContinuationPar</code> will not work and you have to use a Matrix Free linear solver, for example <code>GMRESIterativeSolvers</code>,</li><li>Or <code>J</code> is a function and <code>J(x, p)</code> returns a variable <code>j</code> which can assume any type. Then, you must implement a linear solver <code>ls</code> as a composite type, subtype of <code>AbstractLinearSolver</code> which is called like <code>ls(j, rhs)</code> and which returns the solution of the jacobian linear system. See for example <code>examples/SH2d-fronts-cuda.jl</code>. This linear solver is passed to <code>NewtonPar(linsolver = ls)</code> which itself passed to <code>ContinuationPar</code>. Similarly, you have to implement an eigensolver <code>eig</code> as a composite type, subtype of <code>AbstractEigenSolver</code>.</li></ol></li><li><code>par</code> initial set of parameters,</li><li><code>lens::Lens</code> specifies which parameter axis among <code>par</code> is used for continuation. For example, if <code>par = (α = 1.0, β = 1)</code>, we can perform continuation w.r.t. <code>α</code> by using <code>lens = (@lens _.α)</code>. If you have an array <code>par = [ 1.0, 2.0]</code> and want to perform continuation w.r.t. the first variable, you can use <code>lens = (@lens _[1])</code>. For more information, we refer to <code>SetField.jl</code>,</li><li><code>contParams</code> parameters for continuation. See <a href="#BifurcationKit.ContinuationPar"><code>ContinuationPar</code></a> for more information about the options,</li><li><code>defOp::DeflationOperator</code> a Deflation Operator (see <a href="#BifurcationKit.DeflationOperator"><code>DeflationOperator</code></a>) which contains the set of solution guesses for the parameter <code>par</code>.</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>seekEveryStep::Int = 1</code> we look for additional solution, using deflated newton, every <code>seekEveryStep</code> step,</li><li><code>maxBranches::Int = 100</code> maximum number of branches considered,</li><li><code>showplot = false</code> whether to plot the solution while computing,</li><li><code>printSolution = (x, p) -&gt; norm(x)</code> function used to plot in the continuation curve. It is also used in the way results are saved. It could be <code>norm</code> or <code>(x, p) -&gt; x[1]</code>. This is also useful when saving several huge vectors is not possible for memory reasons (for example on GPU...),</li><li><code>plotSolution = (x, p; kwargs...) -&gt; nothing</code> function implementing the plot of the solution,</li><li><code>callbackN</code> callback for newton iterations. see docs for <code>newton</code>. Can be used to change preconditioners or affect the newton iterations. In the deflation part of the algorithm, when seeking for new branches, the callback is passed the keyword argument <code>fromDeflatedNewton = true</code> to tell the user can it is not in the continuation part (regular newton) of the algorithm,</li><li><code>tangentAlgo = NaturalPred()</code> controls the algorithm used to predict the tangents along the curve of solutions or the corrector. Can be <code>NaturalPred</code>, <code>SecantPred</code> or <code>BorderedPred</code>,</li><li><code>verbosity::Int</code> controls the amount of information printed during the continuation process. Must belong to <code>{0,⋯,5}</code>,</li><li><code>normN = norm</code> norm used in the different Newton solves,</li><li><code>dotPALC = (x, y) -&gt; dot(x, y) / length(x)</code>, dot product used to define the weighted dot product (resp. norm) <span>$\|(x, p)\|^2_\theta$</span> in the constraint <span>$N(x, p)$</span> (see below). This arguement can be used to remove the factor <code>1/length(x)</code> for example in problems where the dimension of the state space changes (mesh adaptation, ...),</li><li><code>perturbSolution = (x, p, id) -&gt; x</code> perturbation applied to the solution when trying to fimnd new solutions using Deflated Newton. You can use for example <code>(x, p, id) -&gt; x .+ (1 .+ 0.001 * rand(size(x)...))</code></li></ul><p><strong>Outputs:</strong></p><ul><li><code>contres::Vector{ContResult}</code> composite type which contains the computed branches. See <a href="#BifurcationKit.ContResult"><code>ContResult</code></a> for more information,</li><li>the solutions at the last parameter value,</li><li>current parameter value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/efbbc550819c59e67e558e5e626a8db46b7183f2/src/DeflatedContinuation.jl#L61">source</a></section><section><div><pre><code class="language-julia">continuation(prob, orbitguess, par, lens, _contParams; linearAlgo, kwargs...)
</code></pre><p>This is the continuation routine for computing a periodic orbit using a (Standard / Poincaré) Shooting method.</p><p><strong>Arguments</strong></p><p>Similar to <a href="#BifurcationKit.continuation"><code>continuation</code></a> except that <code>prob</code> is either a <a href="#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a> or a <a href="#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a>.</p><ul><li><code>printPeriod</code> boolean to print the period of the solution. This is useful for <code>prob::PoincareShootingProblem</code> as this information is not easily available.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/efbbc550819c59e67e558e5e626a8db46b7183f2/src/periodicorbit/PeriodicOrbits.jl#L224">source</a></section><section><div><pre><code class="language-julia">continuation(F, dF, d2F, d3F, br, ind_bif, _contParams, prob; Jᵗ, δ, δp, ampfactor, usedeflation, nev, updateSectionEveryStep, kwargs...)
</code></pre><p>Perform automatic branch switching from a Hopf bifurcation point labelled <code>ind_bif</code> in the list of the bifurcated points on a previously computed branch <code>br::ContResult</code>. It first computes a Hopf normal form.</p><p><strong>Arguments</strong></p><ul><li><code>F, dF, d2F, d3F</code>: function <code>(x,p) -&gt; F(x,p)</code> and its differentials <code>(x,p,dx) -&gt; d1F(x,p,dx)</code>, <code>(x,p,dx1,dx2) -&gt; d2F(x,p,dx1,dx2)</code>... These are used to compute the Hopf normal form.</li><li><code>br</code> branch result from a call to <code>continuation</code></li><li><code>ind_hopf</code> index of the bifurcation point in <code>br</code></li><li><code>contParams</code> parameters for the call to <code>continuation</code></li><li><code>prob</code> problem used to specify the way the periodic orbit is computed. It can be <a href="#BifurcationKit.PeriodicOrbitTrapProblem"><code>PeriodicOrbitTrapProblem</code></a>, <a href="#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a> or <a href="#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a> .</li></ul><p><strong>Optional arguments</strong></p><ul><li><code>linearPO</code> linear algorithm used for the computation of periodic orbits when <code>prob</code> is <a href="#BifurcationKit.PeriodicOrbitTrapProblem"><code>PeriodicOrbitTrapProblem</code></a>)</li><li><code>Jᵗ</code> is the jacobian adjoint, used for computation of the eigen-elements of the jacobian adjoint, needed to compute the spectral projector for the Hopf normal form. For matrix-free methods, <code>transpose</code> is not readily available and the user must provide a dedicated method. In the case of Matrix / Sparse based jacobian, <code>Jᵗ</code> should not be passed as it is computed internally more efficiently, i.e. it avoid recomputing the jacobian as it would be if you pass <code>Jᵗ = (x, p) -&gt; transpose(dF(x, p))</code></li><li><code>δ = 1e-8</code> used for finite differences</li><li><code>δp</code> used to specify a particular guess for the parameter on the bifurcated branch which is otherwise determined by <code>contParams.ds</code>. This allows to use a step larger than <code>contParams.dsmax</code>.</li><li><code>ampfactor = 1</code> factor which alter the amplitude of the bifurcated solution. Useful to magnify the bifurcated solution when the bifurcated branch is very steep.</li><li><code>usedeflation = true</code> whether to use nonlinear deflation (see <a href="../deflatedproblem/#Deflated-problems-1">Deflated problems</a>) to help finding the guess on the bifurcated branch</li><li><code>updateSectionEveryStep = 0</code> updates the section every <code>updateSectionEveryStep</code> step during continuation</li><li><code>linearPO</code> specify the way the jacobian is computed.</li><li>all <code>kwargs</code> from <a href="#BifurcationKit.continuation"><code>continuation</code></a></li></ul><p>A modified version of <code>prob</code> is passed to <code>plotSolution</code> and <code>finaliseSolution</code>.</p><div class="admonition is-info"><header class="admonition-header">Linear solver</header><div class="admonition-body"><p>You have to be carefull about the options <code>contParams.newtonOptions.linsolver</code>. In the case of Matrix-Free solver, you have to pass the right number of unknowns <code>N * M + 1</code>. Note that the options for the preconditioner are not accessible yet.</p></div></div><div class="admonition is-success"><header class="admonition-header">Jacobian tranpose</header><div class="admonition-body"><p>The adjoint of the jacobian <code>J</code> is computed internally when <code>Jᵗ = nothing</code> by using <code>tranpose(J)</code> which works fine when <code>J</code> is an <code>AbstractArray</code>. In this case, do not pass the jacobian adjoint like <code>Jᵗ = (x, p) -&gt; transpose(d_xF(x, p))</code> otherwise the jacobian would be computed twice!</p></div></div><div class="admonition is-warning"><header class="admonition-header">Hessian</header><div class="admonition-body"><p>The hessian of <code>F</code>, when <code>d2F</code> is not <code>nothing</code>, is computed with Finite differences.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/efbbc550819c59e67e558e5e626a8db46b7183f2/src/periodicorbit/PeriodicOrbits.jl#L241">source</a></section><section><div><pre><code class="language-julia">continuation(prob, orbitguess, par, lens, _contParams; linearPO, printSolution, linearAlgo, updateSectionEveryStep, kwargs...)
</code></pre><p>This is the continuation routine for computing a periodic orbit using a functional G based on Finite Differences and a Trapezoidal rule.</p><p><strong>Arguments</strong></p><ul><li><code>prob::PeriodicOrbitTrapProblem</code> encodes the functional G</li><li><code>orbitguess</code> a guess for the periodic orbit where <code>orbitguess[end]</code> is an estimate of the period of the orbit. It could be a vector of size <code>N * M + 1</code> where <code>M</code> is the number of time slices, <code>N</code> is the dimension of the phase space. This must be compatible with the numbers <code>N, M</code> in <code>prob</code>.</li><li><code>p0</code> set of parameters passed to the vector field</li><li><code>contParams</code> same as for the regular <a href="#BifurcationKit.continuation"><code>continuation</code></a> method</li><li><code>linearAlgo</code> same as in <a href="#BifurcationKit.continuation"><code>continuation</code></a></li><li><code>linearPO = :BorderedLU</code>. Same as <code>newton</code> when applied to a <code>PeriodicOrbitTrapProblem</code>. More precisely:<ul><li>For <code>:FullLU</code>, we use the default linear solver on a sparse matrix representation of <code>dG</code>. This matrix is assembled at each newton iteration.</li><li>For <code>:FullSparseInplace</code>, this is the same as <code>:FullLU</code> but the sparse matrix <code>dG</code> is updated inplace. This method thus allocates much less. In some cases, this is significantly faster than using <code>:FullLU</code>. Note that this method can only be used if the sparsity pattern of the jacobian is always the same.</li><li>For <code>:Dense</code>, same as above but the matrix <code>dG</code> is dense. It is also updated inplace. This option is useful to study ODE of small dimension.</li><li>For <code>:BorderedLU</code>, we take advantage of the bordered shape of the linear solver and use LU decomposition to invert <code>dG</code> using a bordered linear solver. This is the default algorithm.</li><li>For <code>:FullMatrixFree</code>, a matrix free linear solver is used for <code>dG</code>: note that a preconditioner is very likely required here because of the cyclic shape of <code>dG</code> which affects negatively the convergence properties of GMRES.</li><li>For <code>:BorderedMatrixFree</code>, a matrix free linear solver is used but for <code>Jc</code> only (see docs): it means that <code>options.linsolver</code> is used to invert <code>Jc</code>. These two Matrix-Free options thus expose different part of the jacobian <code>dG</code> in order to use specific preconditioners. For example, an ILU preconditioner on <code>Jc</code> could remove the constraints in <code>dG</code> and lead to poor convergence. Of course, for these last two methods, a preconditioner is likely to be required.</li></ul></li><li><code>updateSectionEveryStep = 1</code> updates the section every when <code>mod(step, updateSectionEveryStep) == 1</code> during continuation</li></ul><p>Note that by default, the method prints the period of the periodic orbit as function of the parameter. This can be changed by providing your <code>printSolution</code> argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/efbbc550819c59e67e558e5e626a8db46b7183f2/src/periodicorbit/PeriodicOrbitTrapeze.jl#L938">source</a></section></article><h2 id="Bifurcation-diagram-1"><a class="docs-heading-anchor" href="#Bifurcation-diagram-1">Bifurcation diagram</a><a class="docs-heading-anchor-permalink" href="#Bifurcation-diagram-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.bifurcationdiagram" href="#BifurcationKit.bifurcationdiagram"><code>BifurcationKit.bifurcationdiagram</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bifurcationdiagram(F, dF, d2F, d3F, x0, par0, lens, level, options; usedeflation, kwargs...)
</code></pre><p>Compute the bifurcation diagram associated with the problem <code>F(x, p) = 0</code> recursively.</p><p><strong>Arguments</strong></p><ul><li><code>F, dF, d2F, d3F</code> functional and its derivatives</li><li><code>x0</code> initial guess</li><li><code>par0</code> parameter values at <code>x0</code></li><li><code>lens</code> lens to select the parameter axis</li><li><code>level</code> maximum branching (or recursion) level for computing the bifurcation diagram</li><li><code>options = (x, p, level) -&gt; contparams</code> this function allows to change the <a href="#BifurcationKit.continuation"><code>continuation</code></a> options depending on the branching <code>level</code>. The argument <code>x, p</code> denotes the current solution to <code>F(x,p)=0</code>.</li><li><code>kwargs</code> optional arguments as for <a href="#BifurcationKit.continuation"><code>continuation</code></a> but also for the different versions listed in <a href="https://rveltz.github.io/BifurcationKit.jl/dev/library/#Continuation-1">Continuation</a>.</li></ul><p><strong>Simplified call:</strong></p><p>We also provide the call</p><p><code>bifurcationdiagram(F, dF, d2F, d3F, br::ContResult, level::Int, options; usedeflation = false, kwargs...)</code></p><p>where <code>br</code> is a branch computed after a call to <a href="#BifurcationKit.continuation"><code>continuation</code></a> from which we want to compute the bifurcating branches recursively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/efbbc550819c59e67e558e5e626a8db46b7183f2/src/bifdiagram/BifurcationDiagram.jl#L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.bifurcationdiagram!" href="#BifurcationKit.bifurcationdiagram!"><code>BifurcationKit.bifurcationdiagram!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bifurcationdiagram!(F, dF, d2F, d3F, node, level, options; code, usedeflation, kwargs...)
</code></pre><p>Same as <a href="#BifurcationKit.bifurcationdiagram"><code>bifurcationdiagram</code></a> but you pass a previously computed bifurcation diagram <code>node</code> from which you want to further compute the bifurcated branches. It is usually used with <code>node = getBranch(diagram, code)</code> from a previously computed bifurcation <code>diagram</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/efbbc550819c59e67e558e5e626a8db46b7183f2/src/bifdiagram/BifurcationDiagram.jl#L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.getBranch" href="#BifurcationKit.getBranch"><code>BifurcationKit.getBranch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getBranch(tree, code)
</code></pre><p>Return the part of the tree (bifurcation diagram) by recursively descending the tree using the <code>Int</code> valued tuple <code>code</code>. For example <code>getBranch(tree, (1,2,3,))</code> returns <code>tree.child[1].child[2].child[3]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/efbbc550819c59e67e558e5e626a8db46b7183f2/src/bifdiagram/BifurcationDiagram.jl#L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.getBranchesFromBP" href="#BifurcationKit.getBranchesFromBP"><code>BifurcationKit.getBranchesFromBP</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getBranchesFromBP(tree, indbif)
</code></pre><p>Return the part of the tree corresponding to the indbith-th bifurcation point on the root branch.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/efbbc550819c59e67e558e5e626a8db46b7183f2/src/bifdiagram/BifurcationDiagram.jl#L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.GenericBifPoint" href="#BifurcationKit.GenericBifPoint"><code>BifurcationKit.GenericBifPoint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct GenericBifPoint{T, Tp, Tv} &lt;: BifurcationKit.BifurcationPoint</code></pre><p>Structure to record a generic bifurcation point which was only detected by a change in the number of stable eigenvalues.</p><ul><li><p><code>type::Symbol</code></p><p>Bifurcation type, <code>:hopf, :bp...</code>. Default: :none</p></li><li><p><code>idx::Int64</code></p><p>Index in <code>br.eig</code> (see <a href="#BifurcationKit.ContResult"><code>ContResult</code></a>) for which the bifurcation occurs. Default: 0</p></li><li><p><code>param::Any</code></p><p>Parameter value at the bifurcation point, this is an estimate. Default: 0.0</p></li><li><p><code>norm::Any</code></p><p>Norm of the equilibrium at the bifurcation point Default: 0.0</p></li><li><p><code>printsol::Any</code></p><p><code>printsol = printSolution(x, param)</code> where <code>printSolution</code> is one of the arguments to <a href="#BifurcationKit.continuation"><code>continuation</code></a> Default: 0.0</p></li><li><p><code>x::Any</code></p><p>Equilibrium at the bifurcation point Default: Vector{T}(undef, 0)</p></li><li><p><code>tau::BorderedArray{Tv,T} where Tv where T</code></p><p>Tangent along the branch at the bifurcation point Default: BorderedArray(x, T(0))</p></li><li><p><code>ind_ev::Int64</code></p><p>Eigenvalue index responsible for the bifurcation (if applicable) Default: 0</p></li><li><p><code>step::Int64</code></p><p>Continuation step at which the bifurcation occurs Default: 0</p></li><li><p><code>status::Symbol</code></p><p><code>status ∈ {:converged, :guess}</code> indicates whether the bisection algorithm was successful in detecting the bifurcation point Default: :guess</p></li><li><p><code>δ::Tuple{Int64,Int64}</code></p><p><code>δ = (δr, δi)</code> where δr indicates the change in the number of unstable eigenvalues and δi indicates the change in the number of unstable eigenvalues with nonzero imaginary part. <code>abs(δr)</code> is thus an estimate of the dimension of the kernel of the Jacobian at the bifurcation point. Default: (0, 0)</p></li><li><p><code>precision::Any</code></p><p>Precision in the location of the bifurcation point Default: -1</p></li><li><p><code>interval::Tuple{T,T} where T</code></p><p>Interval containing the bifurcation point Default: (0, 0)</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0">source</a></section></article><h2 id="Utils-for-periodic-orbits-1"><a class="docs-heading-anchor" href="#Utils-for-periodic-orbits-1">Utils for periodic orbits</a><a class="docs-heading-anchor-permalink" href="#Utils-for-periodic-orbits-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.getPeriod" href="#BifurcationKit.getPeriod"><code>BifurcationKit.getPeriod</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getPeriod(prob, x, p)
</code></pre><p>Compute the period of the periodic orbit associated to <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/efbbc550819c59e67e558e5e626a8db46b7183f2/src/periodicorbit/PeriodicOrbitTrapeze.jl#L573">source</a></section><section><div><pre><code class="language-julia">getPeriod(sh, x)
getPeriod(sh, x, par)
</code></pre><p>Compute the period of the periodic orbit associated to <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/efbbc550819c59e67e558e5e626a8db46b7183f2/src/periodicorbit/StandardShooting.jl#L115">source</a></section><section><div><pre><code class="language-julia">getPeriod(psh, x_bar, par)
</code></pre><p>Compute the period of the periodic orbit associated to <code>x_bar</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/efbbc550819c59e67e558e5e626a8db46b7183f2/src/periodicorbit/PoincareShooting.jl#L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.getAmplitude" href="#BifurcationKit.getAmplitude"><code>BifurcationKit.getAmplitude</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getAmplitude(prob, x, p; ratio)
</code></pre><p>Compute the amplitude of the periodic orbit associated to <code>x</code>. The keyword argument <code>ratio = 1</code> is used as follows. If <code>length(x) = 1 + ratio * n</code>, the call returns the amplitude over <code>x[1:n]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/efbbc550819c59e67e558e5e626a8db46b7183f2/src/periodicorbit/PeriodicOrbitTrapeze.jl#L551">source</a></section><section><div><pre><code class="language-julia">getAmplitude(prob, x, p; ratio)
</code></pre><p>Compute the amplitude of the periodic orbit associated to <code>x</code>. The keyword argument <code>ratio = 1</code> is used as follows. If <code>length(x) = ratio * n</code>, the call returns the amplitude over <code>x[1:n]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/efbbc550819c59e67e558e5e626a8db46b7183f2/src/periodicorbit/StandardShooting.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.getMaximum" href="#BifurcationKit.getMaximum"><code>BifurcationKit.getMaximum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getMaximum(prob, x, p; ratio)
</code></pre><p>Compute the maximum of the periodic orbit associated to <code>x</code>. The keyword argument <code>ratio = 1</code> is used as follows. If <code>length(x) = 1 + ratio * n</code>, the call returns the amplitude over <code>x[1:n]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/efbbc550819c59e67e558e5e626a8db46b7183f2/src/periodicorbit/PeriodicOrbitTrapeze.jl#L563">source</a></section><section><div><pre><code class="language-julia">getMaximum(prob, x, p; ratio)
</code></pre><p>Compute the maximum of the periodic orbit associated to <code>x</code>. The keyword argument <code>ratio = 1</code> is used as follows. If <code>length(x) = ratio * n</code>, the call returns the amplitude over <code>x[1:n]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/efbbc550819c59e67e558e5e626a8db46b7183f2/src/periodicorbit/StandardShooting.jl#L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.SectionSS" href="#BifurcationKit.SectionSS"><code>BifurcationKit.SectionSS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct SectionSS{Tn, Tc} &lt;: BifurcationKit.AbstractSection</code></pre><p>This composite type (named for Section Standard Shooting) encodes a type of section implemented by a hyperplane. It can be used in conjunction with <a href="#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a>. The hyperplane is defined by a point <code>center</code> and a <code>normal</code>.</p><ul><li><p><code>normal::Any</code></p><p>Normal to define hyperplane</p></li><li><p><code>center::Any</code></p><p>Representative point on hyperplane</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/efbbc550819c59e67e558e5e626a8db46b7183f2/src/periodicorbit/Sections.jl#L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.SectionPS" href="#BifurcationKit.SectionPS"><code>BifurcationKit.SectionPS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct SectionPS{Tn, Tc, Tnb, Tcb} &lt;: BifurcationKit.AbstractSection</code></pre><p>This composite type (named for SectionPoincaréShooting) encodes a type of Poincaré sections implemented by hyperplanes. It can be used in conjunction with <a href="#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a>. Each hyperplane is defined par a point (one example in <code>centers</code>) and a normal (one example in <code>normals</code>).</p><ul><li><p><code>M::Int64</code></p></li><li><p><code>normals::Any</code></p></li><li><p><code>centers::Any</code></p></li><li><p><code>indices::Array{Int64,1}</code></p></li><li><p><code>normals_bar::Any</code></p></li><li><p><code>centers_bar::Any</code></p></li></ul><p><strong>Constructor(s)</strong></p><pre><code class="language-none">SectionPS(normals::Vector{Tv}, centers::Vector{Tv})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/efbbc550819c59e67e558e5e626a8db46b7183f2/src/periodicorbit/Sections.jl#L51">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../faq/">« Frequently Asked Questions</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 1 February 2021 14:42">Monday 1 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
