var documenterSearchIndex = {"docs":
[{"location":"tutorials1/#Temperature-model-(Simplest-example)","page":"Temperature model (Simplest example)","title":"Temperature model (Simplest example)","text":"","category":"section"},{"location":"tutorials1/","page":"Temperature model (Simplest example)","title":"Temperature model (Simplest example)","text":"Pages = [\"tutorials1.md\"]\nDepth = 3","category":"page"},{"location":"tutorials1/","page":"Temperature model (Simplest example)","title":"Temperature model (Simplest example)","text":"This is a classical example from the Trilinos library.","category":"page"},{"location":"tutorials1/","page":"Temperature model (Simplest example)","title":"Temperature model (Simplest example)","text":"This is a simple example in which we aim at solving Delta T+alpha N(Tbeta)=0 with boundary conditions T(0) = T(1)=beta. This example is coded in examples/chan.jl. We start with some imports:","category":"page"},{"location":"tutorials1/","page":"Temperature model (Simplest example)","title":"Temperature model (Simplest example)","text":"using BifurcationKit, LinearAlgebra, Plots, Parameters, Setfield\n# Setfield.jl is used to provide the parameter axis @lens\nconst BK = BifurcationKit\n\nN(x; a = 0.5, b = 0.01) = 1 + (x + a*x^2)/(1 + b*x^2)\nnothing #hide","category":"page"},{"location":"tutorials1/","page":"Temperature model (Simplest example)","title":"Temperature model (Simplest example)","text":"We then write our functional:","category":"page"},{"location":"tutorials1/","page":"Temperature model (Simplest example)","title":"Temperature model (Simplest example)","text":"function F_chan(x, p)\n\t@unpack α, β = p\n\tf = similar(x)\n\tn = length(x)\n\tf[1] = x[1] - β\n\tf[n] = x[n] - β\n\tfor i=2:n-1\n\t\tf[i] = (x[i-1] - 2 * x[i] + x[i+1]) * (n-1)^2 + α * N(x[i], b = β)\n\tend\n\treturn f\nend\t\nnothing #hide","category":"page"},{"location":"tutorials1/","page":"Temperature model (Simplest example)","title":"Temperature model (Simplest example)","text":"We want to call a Newton solver. We first need an initial guess:","category":"page"},{"location":"tutorials1/","page":"Temperature model (Simplest example)","title":"Temperature model (Simplest example)","text":"n = 101\nsol = [(i-1)*(n-i)/n^2+0.1 for i=1:n]\n\n# set of parameters\npar = (α = 3.3, β = 0.01)\nnothing #hide","category":"page"},{"location":"tutorials1/","page":"Temperature model (Simplest example)","title":"Temperature model (Simplest example)","text":"Finally, we need to provide some parameters for the Newton iterations. This is done by calling","category":"page"},{"location":"tutorials1/","page":"Temperature model (Simplest example)","title":"Temperature model (Simplest example)","text":"optnewton = NewtonPar(tol = 1e-11, verbose = true)\nnothing #hide","category":"page"},{"location":"tutorials1/","page":"Temperature model (Simplest example)","title":"Temperature model (Simplest example)","text":"We call the Newton solver:","category":"page"},{"location":"tutorials1/","page":"Temperature model (Simplest example)","title":"Temperature model (Simplest example)","text":"out, = newton( F_chan, sol, par, @set optnewton.verbose=false) # hide\nout, = @time newton( F_chan, sol, par, optnewton)\nnothing #hide","category":"page"},{"location":"tutorials1/","page":"Temperature model (Simplest example)","title":"Temperature model (Simplest example)","text":"Note that, in this case, we did not give the Jacobian. It was computed internally using Finite Differences. ","category":"page"},{"location":"tutorials1/","page":"Temperature model (Simplest example)","title":"Temperature model (Simplest example)","text":"This is not as bad as it looks despite the fact that there are so many allocations even with Finite Differences Jacobian. Using BenchmarkTools.jl, one actually finds 1.153 ms (2067 allocations: 2.04 MiB). This is reasonable as we did not code the problem with much care...","category":"page"},{"location":"tutorials1/","page":"Temperature model (Simplest example)","title":"Temperature model (Simplest example)","text":"We can perform numerical continuation w.r.t. the parameter alpha. This time, we need to provide additional parameters, but now for the continuation method:","category":"page"},{"location":"tutorials1/","page":"Temperature model (Simplest example)","title":"Temperature model (Simplest example)","text":"optcont = ContinuationPar(dsmin = 0.01, dsmax = 0.2, ds= 0.1, pMin = 0., pMax = 4.1, newtonOptions = NewtonPar(maxIter = 10, tol = 1e-9))\nnothing #hide","category":"page"},{"location":"tutorials1/","page":"Temperature model (Simplest example)","title":"Temperature model (Simplest example)","text":"Next, we call the continuation routine as follows.","category":"page"},{"location":"tutorials1/","page":"Temperature model (Simplest example)","title":"Temperature model (Simplest example)","text":"br, = continuation(F_chan, out, par, (@lens _.α),\n\t\toptcont; plot = true, verbosity = 0,\n\t\t# function to plot the solution\n\t\tplotSolution = (x, p; k...) -> plot!(x; ylabel=\"solution\", label=\"\", k...))\nnothing #hide\t\t","category":"page"},{"location":"tutorials1/","page":"Temperature model (Simplest example)","title":"Temperature model (Simplest example)","text":"The parameter axis lens = @lens _.α is used to extract the component of par corresponding to α. Internally, it is used as get(par, lens) which returns 3.3.","category":"page"},{"location":"tutorials1/","page":"Temperature model (Simplest example)","title":"Temperature model (Simplest example)","text":"tip: Tip\nWe don't need to call newton first in order to use continuation.","category":"page"},{"location":"tutorials1/","page":"Temperature model (Simplest example)","title":"Temperature model (Simplest example)","text":"You should see (Image: )","category":"page"},{"location":"tutorials1/","page":"Temperature model (Simplest example)","title":"Temperature model (Simplest example)","text":"The left figure is the norm of the solution as function of the parameter p=alpha, the y-axis can be changed by passing a different recordFromSolution to continuation. The top right figure is the value of alpha as function of the iteration number. The bottom right is the solution for the current value of the parameter. This last plot can be modified by changing the argument plotSolution to continuation.","category":"page"},{"location":"tutorials1/","page":"Temperature model (Simplest example)","title":"Temperature model (Simplest example)","text":"note: Bif. point detection\nTwo Fold points were detected. This can be seen by looking at br.specialpoint, by the black\tdots on the continuation plots when doing plot(br, plotfold=true) or by typing br in the REPL. Note that the bifurcation points are located in br.specialpoint.","category":"page"},{"location":"tutorials1/#Continuation-of-Fold-points","page":"Temperature model (Simplest example)","title":"Continuation of Fold points","text":"","category":"section"},{"location":"tutorials1/","page":"Temperature model (Simplest example)","title":"Temperature model (Simplest example)","text":"We get a summary of the branch by doing","category":"page"},{"location":"tutorials1/","page":"Temperature model (Simplest example)","title":"Temperature model (Simplest example)","text":"julia> br\nBranch number of points: 78\nBranch of Equilibrium\nFold points:\n- #  1,    fold at p ≈ 4.03926020, step =   6, eigenelements in eig[  6], ind_ev =   0 [    guess]\n- #  2,    fold at p ≈ 3.15599445, step =  24, eigenelements in eig[ 24], ind_ev =   0 [    guess]","category":"page"},{"location":"tutorials1/","page":"Temperature model (Simplest example)","title":"Temperature model (Simplest example)","text":"We can take the first Fold point, which has been guessed during the previous continuation run and locate it precisely. However, this only works well when the jacobian is computed analytically. We use automatic differentiation for that","category":"page"},{"location":"tutorials1/","page":"Temperature model (Simplest example)","title":"Temperature model (Simplest example)","text":"using ForwardDiff\n\n# Jacobian of F_chan\nJac_mat = (x,p) -> ForwardDiff.jacobian(z -> F_chan(z,p),x)\n\n# index of the Fold bifurcation point in br.specialpoint\nindfold = 2\n\noutfold, _, flag = newton(F_chan, Jac_mat,\n\t#index of the fold point\n\tbr, indfold)\nflag && printstyled(color=:red, \"--> We found a Fold Point at α = \", outfold.p, \", β = 0.01, from \", br.specialpoint[indfold].param,\"\\n\")","category":"page"},{"location":"tutorials1/","page":"Temperature model (Simplest example)","title":"Temperature model (Simplest example)","text":"We can finally continue this fold point in the plane (ab) by performing a Fold Point continuation. In the present case, we find a Cusp point.","category":"page"},{"location":"tutorials1/","page":"Temperature model (Simplest example)","title":"Temperature model (Simplest example)","text":"tip: Tip\nWe don't need to call newton first in order to use continuation for the codim 2 curve of bifurcation points.","category":"page"},{"location":"tutorials1/","page":"Temperature model (Simplest example)","title":"Temperature model (Simplest example)","text":"outfoldco, = continuation(\n\tF_chan, Jac_mat,\n\tbr, indfold, \n\t# parameter axis to trace to codim 2 curve\n\t(@lens _.β),\n\tplot = true, verbosity = 2)\nscene = plot(outfoldco, plotfold=true, legend = :bottomright)","category":"page"},{"location":"tutorials1/#Using-GMRES-or-another-linear-solver","page":"Temperature model (Simplest example)","title":"Using GMRES or another linear solver","text":"","category":"section"},{"location":"tutorials1/","page":"Temperature model (Simplest example)","title":"Temperature model (Simplest example)","text":"We continue the previous example but now using Matrix Free methods. The user can pass its own solver by implementing a version of LinearSolver. Some linear solvers have been implemented from KrylovKit.jl and IterativeSolvers.jl (see Linear solvers (LS) for more information), we can use them here. Note that we can also use preconditioners as shown below. The same functionality is present for the eigensolver.","category":"page"},{"location":"tutorials1/","page":"Temperature model (Simplest example)","title":"Temperature model (Simplest example)","text":"# derivative of N\ndN(x; a = 0.5, b = 0.01) = (1-b*x^2+2*a*x)/(1+b*x^2)^2\n\n# Matrix Free version of the differential of F_chan\n# Very easy to write since we have F_chan. \n# We could use Automatic Differentiation as well\nfunction dF_chan(x, dx, p)\n\t@unpack α, β = p\n\tout = similar(x)\n\tn = length(x)\n\tout[1] = dx[1]\n\tout[n] = dx[n]\n\tfor i=2:n-1\n\t\tout[i] = (dx[i-1] - 2 * dx[i] + dx[i+1]) * (n-1)^2 + α * dN(x[i], b = β) * dx[i]\n\tend\n\treturn out\nend\n\n# we create a new linear solver\nls = GMRESKrylovKit(dim = 100)\n\n# and pass it to the newton parameters\noptnewton_mf = NewtonPar(verbose = true, linsolver = ls)\n\n# we can then call the newton solver\nout_mf, = @time newton(\n\tF_chan,\n\t# we pass the differential a x, \n\t# which is a linear operator in dx\n\t(x, p) -> (dx -> dF_chan(x, dx, p)),\n\tsol, par,\n\toptnewton_mf)\nnothing #hide","category":"page"},{"location":"tutorials1/","page":"Temperature model (Simplest example)","title":"Temperature model (Simplest example)","text":"We can improve this computation, i.e. reduce the number of Linear-Iterations, by using a preconditioner","category":"page"},{"location":"tutorials1/","page":"Temperature model (Simplest example)","title":"Temperature model (Simplest example)","text":"using SparseArrays\n\n# define preconditioner which is basically Δ\nP = spdiagm(0 => -2 * (n-1)^2 * ones(n), -1 => (n-1)^2 * ones(n-1), 1 => (n-1)^2 * ones(n-1))\nP[1,1:2] .= [1, 0.];P[end,end-1:end] .= [0, 1.]\n\n# define gmres solver with left preconditioner\nls = GMRESIterativeSolvers(reltol = 1e-4, N = length(sol), restart = 10, maxiter = 10, Pl = lu(P))\n\toptnewton_mf = NewtonPar(verbose = true, linsolver = ls)\n\tout_mf, = @time newton(F_chan,\n\t(x, p) -> (dx -> dF_chan(x, dx, p)),\n\tsol, par, optnewton_mf)\nnothing #hide","category":"page"},{"location":"tutorials2/#d-Swift-Hohenberg-equation:-snaking,-Finite-Differences","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"","category":"section"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"Pages = [\"tutorials2.md\"]\nDepth = 3","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"We study the following PDE","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"-(I+Delta)^2 u+lcdot u +nu u^2-u^3 = 0","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"with Neumann boundary conditions. This full example is in the file example/SH2d-fronts.jl. This example is also treated in the MATLAB package pde2path. We use a Sparse Matrix to express the operator L_1=(I+Delta)^2.","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"using DiffEqOperators, Setfield, Parameters\nusing BifurcationKit, LinearAlgebra, Plots, SparseArrays\nconst BK = BifurcationKit\n\n# helper function to plot solution\nheatmapsol(x) = heatmap(reshape(x,Nx,Ny)',color=:viridis)\n\nNx = 151\nNy = 100\nlx = 4*2pi\nly = 2*2pi/sqrt(3)\n\n# we use DiffEqOperators to compute the Laplacian operator\nfunction Laplacian2D(Nx, Ny, lx, ly)\n\thx = 2lx/Nx\n\thy = 2ly/Ny\n\tD2x = CenteredDifference(2, 2, hx, Nx)\n\tD2y = CenteredDifference(2, 2, hy, Ny)\n\tQx = Neumann0BC(hx)\n\tQy = Neumann0BC(hy)\n\t\n\tA = kron(sparse(I, Ny, Ny), sparse(D2x * Qx)[1]) + kron(sparse(D2y * Qy)[1], sparse(I, Nx, Nx))\n\treturn A, D2x\nend","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"We also write the functional and its Jacobian which is a Sparse Matrix","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"function F_sh(u, p)\n\t@unpack l, ν, L1 = p\n\treturn -L1 * u .+ (l .* u .+ ν .* u.^2 .- u.^3)\nend\n\nfunction dF_sh(u, p)\n\t@unpack l, ν, L1 = p\n\treturn -L1 .+ spdiagm(0 => l .+ 2 .* ν .* u .- 3 .* u.^2)\nend","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"We first look for hexagonal patterns. This is done with","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"X = -lx .+ 2lx/(Nx) * collect(0:Nx-1)\nY = -ly .+ 2ly/(Ny) * collect(0:Ny-1)\n\n# initial guess for hexagons\nsol0 = [(cos(x) + cos(x/2) * cos(sqrt(3) * y/2) ) for x in X, y in Y]\n\tsol0 .= sol0 .- minimum(vec(sol0))\n\tsol0 ./= maximum(vec(sol0))\n\tsol0 = sol0 .- 0.25\n\tsol0 .*= 1.7\n\theatmap(sol0',color=:viridis)\n\n# define parameters for the PDE\nΔ, _ = Laplacian2D(Nx, Ny, lx, ly)\nL1 = (I + Δ)^2\npar = (l = -0.1, ν = 1.3, L1 = L1)\n\n# newton corrections of the initial guess\noptnewton = NewtonPar(verbose = true, tol = 1e-8, maxIter = 20)\n\tsol_hexa, = @time newton(F_sh, dF_sh, vec(sol0), par, optnewton)\n\tprintln(\"--> norm(sol) = \",norm(sol_hexa,Inf64))\n\theatmapsol(sol_hexa)","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"which produces the results","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"┌────────────────────-────────────────────────────────┐\n│ Newton Iterations      f(x)      Linear Iterations  │\n├─────────────┐──────────────────────┐────────────────┤\n│       0     │       1.7391e+02     │        0       │\n│       1     │       5.0465e+03     │        1       │\n│       2     │       1.4878e+03     │        1       │\n│       3     │       4.3529e+02     │        1       │\n│       4     │       1.2560e+02     │        1       │\n│       5     │       3.5512e+01     │        1       │\n│       6     │       9.5447e+00     │        1       │\n│       7     │       2.1763e+00     │        1       │\n│       8     │       3.3503e-01     │        1       │\n│       9     │       7.7259e-02     │        1       │\n│      10     │       7.4767e-03     │        1       │\n│      11     │       7.9505e-05     │        1       │\n│      12     │       8.8395e-09     │        1       │\n└─────────────┴──────-───────────────┴────────────────┘\n  1.441525 seconds (1.74 k allocations: 659.488 MiB, 1.25% gc time)","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"with sol_hexa being","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"(Image: )","category":"page"},{"location":"tutorials2/#Continuation-and-bifurcation-points","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"Continuation and bifurcation points","text":"","category":"section"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"We can now continue this solution as follows. We want to detect bifurcations along the branches. We thus need an eigensolver. However, if we use an iterative eigensolver, like eig = EigArpack(), it has trouble computing the eigenvalues. One can see that using ","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"# compute the jacobian\nJ0 = dF_sh(sol_hexa, par)\n\n# compute 10 eigenvalues\neig(J0, 10)","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"The reason is that the jacobian operator is not very well conditioned unlike its inverse. We thus opt for the shift-invert method (see Eigen solvers (Eig) for more information) with shift 0.1:","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"eig = EigArpack(0.1, :LM)","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"If we want to compute the bifurcation points along the branches, we have to tell the solver by setting detectBifurcation = 2. However, this won't be very precise and each bifurcation point will be located at best at the step size precision. We can use bisection to locate this points more precisely using the option detectBifurcation = 3 (see Detection of bifurcation points for more information).","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"We are now ready to compute the branches:","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"optcont = ContinuationPar(dsmin = 0.0001, dsmax = 0.005, ds= -0.001, pMax = 0.00, pMin = -1.0,\n\tnewtonOptions = setproperties(optnewton; tol = 1e-9, maxIter = 15), maxSteps = 125,\n\tdetectBifurcation = 3, nev = 40, detectFold = false, \n\tdsminBisection =1e-7, saveSolEveryStep = 4)\n\toptcont = @set optcont.newtonOptions.eigsolver = EigArpack(0.1, :LM)\n\n\tbr, u1 = @time BK.continuation(F_sh, dF_sh,\n\t\tsol_hexa, par, (@lens _.l), optcont;\t\tplot = true, verbosity = 3,\n\t\ttangentAlgo = BorderedPred(),\n\t\tplotSolution = (x, p; kwargs...) -> (heatmap!(X, Y, reshape(x, Nx, Ny)'; color=:viridis, label=\"\", kwargs...);ylims!(-1,1,subplot=4);xlims!(-.5,.3,subplot=4)),\n\t\trecordFromSolution = (x, p) -> norm(x),\n\t\tnormC = x -> norm(x, Inf))","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"Note that we can get some information about the branch as follows. The [converged] indicates if the bisection routine was successful, otherwise it shows [guess]. Finally δ = ( 2,  0) says that the bifurcation point has been detected by 2 new eigenvalues with zero real part among which zero have non zero imaginary part. A Hopf bifurcation point would thus have δ = ( 2,  2) or δ = ( -2,  2).","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"julia> br\nBranch number of points: 98\nBranch of Equilibrium\nBifurcation points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1,    bp at p ≈ -0.21554724 ∈ (-0.21554697, -0.21554724), |δp|=3e-07, [converged], δ = ( 1,  0), step =  35, eigenelements in eig[ 36], ind_ev =   1\n- #  2,    bp at p ≈ -0.21551263 ∈ (-0.21552148, -0.21551263), |δp|=9e-06, [converged], δ = ( 1,  0), step =  36, eigenelements in eig[ 37], ind_ev =   2\n- #  3,    bp at p ≈ -0.21499087 ∈ (-0.21506402, -0.21499087), |δp|=7e-05, [converged], δ = ( 1,  0), step =  38, eigenelements in eig[ 39], ind_ev =   3\n- #  4,    bp at p ≈ -0.21289710 ∈ (-0.21297786, -0.21289710), |δp|=8e-05, [converged], δ = ( 1,  0), step =  41, eigenelements in eig[ 42], ind_ev =   4\n- #  5,    nd at p ≈ -0.20993438 ∈ (-0.21016342, -0.20993438), |δp|=2e-04, [converged], δ = ( 2,  0), step =  43, eigenelements in eig[ 44], ind_ev =   6\n- #  6,    nd at p ≈ -0.20628011 ∈ (-0.20685136, -0.20628011), |δp|=6e-04, [converged], δ = ( 2,  0), step =  45, eigenelements in eig[ 46], ind_ev =   8\n- #  7,    bp at p ≈ -0.19981594 ∈ (-0.19990625, -0.19981594), |δp|=9e-05, [converged], δ = ( 1,  0), step =  48, eigenelements in eig[ 49], ind_ev =   9\n- #  8,    bp at p ≈ -0.18868881 ∈ (-0.18890987, -0.18868881), |δp|=2e-04, [converged], δ = ( 1,  0), step =  52, eigenelements in eig[ 53], ind_ev =  10\n- #  9,    bp at p ≈ -0.18103471 ∈ (-0.18104224, -0.18103471), |δp|=8e-06, [converged], δ = ( 1,  0), step =  55, eigenelements in eig[ 56], ind_ev =  11\n- # 10,    bp at p ≈ -0.14472469 ∈ (-0.14531146, -0.14472469), |δp|=6e-04, [converged], δ = (-1,  0), step =  64, eigenelements in eig[ 65], ind_ev =  11\n- # 11,    bp at p ≈ -0.13818751 ∈ (-0.13878837, -0.13818751), |δp|=6e-04, [converged], δ = (-1,  0), step =  66, eigenelements in eig[ 67], ind_ev =  10\n- # 12,    bp at p ≈ -0.11129701 ∈ (-0.11161442, -0.11129701), |δp|=3e-04, [converged], δ = (-1,  0), step =  72, eigenelements in eig[ 73], ind_ev =   9\n- # 13,    nd at p ≈ -0.08963860 ∈ (-0.08980136, -0.08963860), |δp|=2e-04, [converged], δ = (-2,  0), step =  77, eigenelements in eig[ 78], ind_ev =   8\n- # 14,    bp at p ≈ -0.07000271 ∈ (-0.07132120, -0.07000271), |δp|=1e-03, [converged], δ = (-1,  0), step =  81, eigenelements in eig[ 82], ind_ev =   6\n- # 15,    bp at p ≈ -0.06076609 ∈ (-0.06208899, -0.06076609), |δp|=1e-03, [converged], δ = (-1,  0), step =  83, eigenelements in eig[ 84], ind_ev =   5\n- # 16,    bp at p ≈ -0.05300195 ∈ (-0.05316683, -0.05300195), |δp|=2e-04, [converged], δ = (-1,  0), step =  85, eigenelements in eig[ 86], ind_ev =   4\n- # 17,    bp at p ≈ -0.02461821 ∈ (-0.02527709, -0.02461821), |δp|=7e-04, [converged], δ = (-1,  0), step =  91, eigenelements in eig[ 92], ind_ev =   3\n- # 18,    bp at p ≈ -0.00632774 ∈ (-0.00632901, -0.00632774), |δp|=1e-06, [converged], δ = (-1,  0), step =  95, eigenelements in eig[ 96], ind_ev =   2\n\n","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"We get the following plot during computation:","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"(Image: )","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"tip: Tip\nWe don't need to call newton first in order to use continuation.","category":"page"},{"location":"tutorials2/#Snaking-computed-with-deflation","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"Snaking computed with deflation","text":"","category":"section"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"We know that there is snaking near the left fold. Let us look for other solutions like fronts. The problem is that if the guess is not precise enough, the newton iterations will converge to the solution with hexagons sol_hexa. We appeal to the technique initiated by P. Farrell and use a deflated problem (see DeflationOperator and DeflatedProblem for more information). More precisely, we apply the newton iterations to the following functional uto Pi_i=1^n_sleft( u-sol_hexai^-p + sigmaright)F_sh(u) which penalizes sol_hexa.","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"# this define the above penalizing factor with p=2, sigma=1, norm associated to dot\n# and the set of sol_{hexa} is of length ns=1\ndeflationOp = DeflationOperator(2.0,dot,1.0,[sol_hexa])\noptnewton = @set optnewton.maxIter = 250\noutdef, _, flag, _ = @time newton(F_sh, dF_sh,\n\t\t\t\t0.2vec(sol_hexa) .* vec([exp.(-(x+lx)^2/25) for x in X, y in Y]),\n\t\t\t\tpar, optnewton, deflationOp, normN = x -> norm(x,Inf64))\n\t\theatmapsol(outdef) |> display\n\t\tflag && push!(deflationOp, outdef)","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"which gives:","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"(Image: )","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"Note that push!(deflationOp, outdef) deflates the newly found solution so that by repeating the process we find another one:","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"outdef, _, flag, _ = @time newton(F_sh, dF_sh,\n\t\t\t\t0.2vec(sol_hexa) .* vec([exp.(-(x)^2/25) for x in X, y in Y]),\n\t\t\t\tpar, optnewton, deflationOp, normN = x -> norm(x,Inf64))\n\t\theatmapsol(outdef) |> display\n\t\tflag && push!(deflationOp, outdef)","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"(Image: )","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"Again, repeating this from random guesses, we find several more solutions, like for example","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"(Image: )","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"(Image: )","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"We can now continue the solutions located in deflationOp.roots","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"br1, = @time continuation(F_sh, dF_sh,\n\tdeflationOp[2], par, (@lens _.l), optcont;\n\tplot = true, \n\tplotSolution = (x, p; kwargs...) -> (heatmap!(X,Y,reshape(x,Nx,Ny)'; color=:viridis, label=\"\", kwargs...)))","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"and using plot(br, br1), we obtain:","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"(Image: )","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"Note that the plot provides the stability of solutions and bifurcation points. Interested readers should consult the associated file example/SH2d-fronts.jl in the example folder.","category":"page"},{"location":"tutorials2/#Automatic-branch-switching","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"Automatic branch switching","text":"","category":"section"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"Instead of relying on deflated newton, we can use Branch switching to compute the different branches emanating from the bifurcation point. For example, the following code will perform automatic branch switching from the second bifurcation point of br:","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"# we compute the differentials\nd2F_sh(u, p, dx1, dx2) = (2 .* p.ν .* dx2 .- 6 .* dx2 .* u) .* dx1\nd3F_sh(u, p, dx1, dx2, dx3) = (-6 .* dx2 .* dx3) .* dx1\njet = (F_sh, dF_sh, d2F_sh, d3F_sh)\n\nbr2, = continuation(jet..., br, 2, setproperties(optcont; ds = -0.001, detectBifurcation = 3, plotEveryStep = 5, maxSteps = 170);  nev = 30,\n\tplot = true, verbosity = 2,\n\tplotSolution = (x, p; kwargs...) -> (heatmapsol!(x; label=\"\", kwargs...);plot!(br; subplot=1,plotfold=false)),\n\trecordFromSolution = (x, p) -> norm(x),\n\tnormC = x -> norm(x, Inf))","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"We can then plot the branches using plot(br, br2, br3) and get","category":"page"},{"location":"tutorials2/","page":"2d Swift-Hohenberg equation: snaking, Finite Differences","title":"2d Swift-Hohenberg equation: snaking, Finite Differences","text":"(Image: )","category":"page"},{"location":"tutorialsSH3d/#d-Swift-Hohenberg-equation,-Finite-differences","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"","category":"section"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"Pages = [\"tutorialsSH3d.md\"]\nDepth = 3","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"info: Why this example?\nThis example is challenging because we cannot employ the easy to use \\ sparse linear solver which takes to much time/memory to do the LU decomposition. Hence, one has to be tricky to devise a preconditioned linear solver that does not explode the memory budget. But then, one has to also devise a specific eigensolver. This is done in this tutorial. It also shows how this can be used for automatic branch switching. Hence, if you are not happy with the linear / eigen solvers in BifurcationKit.jl, this is perhaps the example you are looking for.","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"We look at the following PDE on a 3d domain, e.g. a cube:","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"-(I+Delta)^2 u+lcdot u +nu u^2-u^3 = 0tagE","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"with Neumann boundary conditions. We use a Sparse Matrix to express the operator L_1equiv(I+Delta)^2. However, compared to the 2d case (see 2d Swift-Hohenberg equation: snaking, Finite Differences), we cannot use directly \\ to solve linear systems because the LU décomposition is a bit slow, it uses a lot of memory.","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"We start by defining the associated functional to encode (E).","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"using Revise, Parameters, KrylovKit\nusing GLMakie\nusing BifurcationKit\nusing LinearAlgebra, SparseArrays, LinearMaps, DiffEqOperators, Setfield\nconst BK = BifurcationKit\n\nfunction Laplacian3D(Nx, Ny, Nz, lx, ly, lz, bc = :Neumann)\n\tspeye(n) = sparse(I, n, n)\n\thx = 2lx/Nx; hy = 2ly/Ny; hz = 2lz/Nz\n\tD2x = CenteredDifference{1}(2, 2, hx, Nx)\n\tD2y = CenteredDifference{1}(2, 2, hy, Ny)\n\tD2z = CenteredDifference{1}(2, 2, hz, Nz)\n\tQx = Neumann0BC(hx); Qy = Neumann0BC(hy); Qz = Neumann0BC(hz)\n\n\t_A = kron(speye(Ny), sparse(D2x * Qx)[1]) + kron(sparse(D2y * Qy)[1], speye(Nx))\n\tA = kron(speye(Nz), _A) + kron(kron(sparse(D2z * Qz)[1], speye(Ny)), speye(Nx))\n\treturn sparse(A), D2x\nend\n\n# main functional\nfunction F_sh(u, p)\n\t@unpack l, ν, L1 = p\n\treturn -(L1 * u) .+ (l .* u .+ ν .* u.^2 .- u.^3)\nend\n\n# differential of the functional\nfunction dF_sh(u, p, du)\n\t@unpack l, ν, L1 = p\n\treturn -(L1 * du) .+ (l .+ 2 .* ν .* u .- 3 .* u.^2) .* du\nend\n\n# various differentials\nd2F_sh(u, p, dx1, dx2) = (2 .* p.ν .* dx2 .- 6 .* dx2 .* u) .* dx1\nd3F_sh(u, p, dx1, dx2, dx3) = (-6 .* dx2 .* dx3) .* dx1\njet = (F_sh, (x, p) -> (dx -> dF_sh(x, p, dx)), d2F_sh, d3F_sh)\n\n# these types are useful to switch to GPU\nTY = Float64\nAF = Array{TY}","category":"page"},{"location":"tutorialsSH3d/#Plotting-with-Makie","page":"3d Swift-Hohenberg equation, Finite differences","title":"Plotting with Makie","text":"","category":"section"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"In most tutorials, we have used Plots.jl for the figures. However, it appears that Makie.jl is more convenient for 3d plots. We thus define the following convenience functions to display the solutions of (E).","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"contour3dMakie(x; k...) = AbstractPlotting.contour(x;  k...)\ncontour3dMakie(x::AbstractVector; k...) = contour3dMakie(reshape(x,Nx,Ny,Nz); k...)\n\ncontour3dMakie(ax, x; k...) = (AbstractPlotting.contour(ax, x;  k...))\ncontour3dMakie(ax, x::AbstractVector; k...) = contour3dMakie(ax, reshape(x,Nx,Ny,Nz); k...)\n\ncontour3dMakie!(ax, x; k...) = (AbstractPlotting.contour!(ax, x;  k...))\ncontour3dMakie!(ax, x::AbstractVector; k...) = contour3dMakie!(ax, reshape(x,Nx,Ny,Nz); k...)","category":"page"},{"location":"tutorialsSH3d/#Setting-up-the-problem","page":"3d Swift-Hohenberg equation, Finite differences","title":"Setting up the problem","text":"","category":"section"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"We provide the parameters defining the PDE:","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"Nx = Ny = Nz = 22; N = Nx*Ny*Nz\nlx = ly = lz = pi\n\nX = -lx .+ 2lx/(Nx) * collect(0:Nx-1)\nY = -ly .+ 2ly/(Ny) * collect(0:Ny-1)\nZ = -lz .+ 2lz/(Nz) * collect(0:Nz-1)\n\n# initial guess for newton\nsol0 = [(cos(x) .* cos(y )) for x in X, y in Y, z in Z]\n\tsol0 .= sol0 .- minimum(vec(sol0))\n\tsol0 ./= maximum(vec(sol0))\n\tsol0 = sol0 .- 0.0\n\tsol0 .*= 1.7\n\n# parameters for PDE\nΔ, D2x = Laplacian3D(Nx, Ny, Nz, lx, ly, lz, :Neumann)\nL1 = (I + Δ)^2\npar = (l = 0.1, ν = 1.2, L1 = L1)","category":"page"},{"location":"tutorialsSH3d/#Choice-of-linear-solver","page":"3d Swift-Hohenberg equation, Finite differences","title":"Choice of linear solver","text":"","category":"section"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"Let us run a quick benchmark to evaluate the direct linear solvers:","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"julia> @time cholesky(L1) \\ sol_hexa;\n  0.152849 seconds (54 allocations: 87.273 MiB)\n\njulia> @time lu(L1) \\ sol_hexa;\n  0.556157 seconds (87 allocations: 226.210 MiB, 0.49% compilation time)\n\njulia> @time qr(L1) \\ sol_hexa;\n  1.609175 seconds (8.96 k allocations: 989.285 MiB, 2.67% gc time, 0.67% compilation time)","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"Hence, cholesky is the big winner but it requires a positive matrix so let's see how to do that.","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"As said in the introduction, the LU linear solver does not scale well with dimension N. Hence, we do something else. We note that the matrix L_1 is hermitian positive and use it as a preconditioner. Thus, we pre-factorize it using a Cholesky decomposition:","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"Pr = cholesky(L1)\nusing SuiteSparse\n# we need this \"hack\" to be able to use Pr as a preconditioner.\nLinearAlgebra.ldiv!(P::SuiteSparse.CHOLMOD.Factor{Float64}, v) = -(P \\ v)\n\n# rtol must be small enough to pass the Fold points and to get precise eigenvalues\n# we know that the jacobian is symmetric so we tell the solver\nls = GMRESKrylovKit(verbose = 0, rtol = 1e-9, maxiter = 150, ishermitian = true, Pl = Pr)","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"Let's try this on a Krylov-Newton computation to refine the guess sol0:","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"optnew = NewtonPar(verbose = true, tol = 1e-8, maxIter = 20, linsolver = ls)\nsol_hexa, hist, flag = @time BK.newton(F_sh,\n\t(x, p) -> (dx -> dF_sh(x, p, dx)),\n\tvec(sol0), par, optnew)","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"which gives","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":" Newton Iterations      f(x)      Linear Iterations\n\n          0          2.6003e+02             0\n          1          1.5414e+02            24\n          2          2.6040e+02            23\n          3          7.3531e+01            21\n          4          2.0512e+01            20\n          5          6.4608e+00            17\n          6          1.3743e+00            17\n          7          1.7448e-01            17\n          8          4.0925e-03            17\n          9          2.4078e-06            17\n         10          1.7275e-10            17\n  2.054799 seconds (1.35 M allocations: 212.193 MiB, 6.63% gc time, 17.77% compilation time)","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"and contour3dMakie(sol_hexa) produces","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"(Image: )","category":"page"},{"location":"tutorialsSH3d/#Continuation-and-bifurcation-points","page":"3d Swift-Hohenberg equation, Finite differences","title":"Continuation and bifurcation points","text":"","category":"section"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"We now switch gears and compute the stability of the trivial solution u=0. We will then branch from the detected bifurcation points. However, we wish to show an example of computation of eigenvalues based on a custom preconditioned Shift-Invert strategy.","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"We thus define our eigensolver based on the previously defined pre-conditioned linear solver ls:","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"# structure to hold eigensolver\nstruct SH3dEig{Ts, Tσ} <: BK.AbstractEigenSolver\n\t# linear solver used for Shift-Invert strategy\n\tls::Ts\n\t# shift of the linear operator\n\tσ::Tσ\nend\n\n# function to extract eigenvectors, used for automatic branch switching\nBifurcationKit.geteigenvector(eigsolve::SH3dEig, vecs, n::Union{Int, Array{Int64,1}}) = vecs[n]\n\n# implementation of Shift-invert strategy\nfunction (sheig::SH3dEig)(J, nev::Int; verbosity = 0, kwargs...)\n\tσ = sheig.σ\n\tnv = 30\n\tJshift = du -> J(du) .- σ .* du\n\tA = du -> sheig.ls(Jshift, du)[1]\n\t# we adapt the krylov dimension as function of the requested eigenvalue number\n\tvals, vec, info = KrylovKit.eigsolve(A, AF(rand(Nx*Ny*Nz)), nev, :LM;\n\t\t tol = 1e-12, maxiter = 20, verbosity = verbosity, ishermitian = true, \n\t\t krylovdim = max(nv, nev + nv))\n\tvals2 = 1 ./vals .+ σ\n\tInd = sortperm(vals2, by = real, rev = true)\n\treturn vals2[Ind], vec[Ind], true, info.numops\nend","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"We can then declare our eigensolver and pass it to the newton parameters","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"eigSH3d = SH3dEig((@set ls.rtol = 1e-9), 0.1)\n@set! optnew.eigsolver = eigSH3d","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"We are now ready to perform continuation and detection of bifurcation points:","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"optcont = ContinuationPar(dsmin = 0.0001, dsmax = 0.005, ds= -0.001, pMax = 0.15, \n\tpMin = -.1, newtonOptions = setproperties(optnew; tol = 1e-9, maxIter = 15), \n\tmaxSteps = 146, detectBifurcation = 3, nev = 15, nInversion = 4, plotEveryStep = 1)\n\nbr, = continuation(\n\tF_sh, (x, p) -> (dx -> dF_sh(x, p, dx)),\n\tzeros(N), par, (@lens _.l), optcont;\n\tplot = true, verbosity = 3,\n\tplotSolution = (ax, x, p) -> contour3dMakie(ax, x),\n\trecordFromSolution = (x, p) -> (n2 = norm(x), n8 = norm(x, 8)),\n\tnormC = x -> norm(x, Inf))","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"The following result shows the detected bifurcation points (its takes ~300s)","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"julia> br\nBranch number of points: 34\nBranch of Equilibrium\nParameters l from 0.1 to -0.1\nBifurcation points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1,    bp at l ≈ +0.06243495 ∈ (+0.06243495, +0.06287689), |δp|=4e-04, [converged], δ = (-1,  0), step =   8, eigenelements in eig[  9], ind_ev =  10\n- #  2,    nd at l ≈ +0.06069653 ∈ (+0.06069653, +0.06069826), |δp|=2e-06, [converged], δ = (-6,  0), step =   9, eigenelements in eig[ 10], ind_ev =   9\n- #  3,    nd at l ≈ -0.00007046 ∈ (-0.00007046, +0.00015051), |δp|=2e-04, [converged], δ = (-3,  0), step =  18, eigenelements in eig[ 19], ind_ev =   3","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"We get the following plot during computation:","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"(Image: )","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"tip: Tip\nWe don't need to call newton first in order to use continuation.","category":"page"},{"location":"tutorialsSH3d/#Automatic-branch-switching","page":"3d Swift-Hohenberg equation, Finite differences","title":"Automatic branch switching","text":"","category":"section"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"warning: Computation time\nThe following computation takes ~1.5h ","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"We can use Branch switching to compute the different branches emanating from the bifurcation points. For example, the following code will perform automatic branch switching from the last bifurcation point of br. Note that this bifurcation point is 3d.","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"br1, = @time continuation(jet..., br, 3, setproperties(optcont; saveSolEveryStep = 10, \n\tdetectBifurcation = 0, pMax = 0.1, plotEveryStep = 5, dsmax = 0.02);\n\tplot = true, verbosity = 3,\n\t# to set initial point on the branch\n\tδp = 0.01,\n\t# remove display of deflated newton iterations \n\tverbosedeflation = false,\n\ttangentAlgo = BorderedPred(),\n\t# to compute the normal form, so we don't have to\n\t# compute the left eigenvectors\n\tissymmetric = true,\n\tplotSolution = (ax, x, p) -> contour3dMakie(ax, x),\n\trecordFromSolution = (x, p) -> (n2 = norm(x), n8 = norm(x, 8)),\n\tnormC = x -> norm(x, Inf))","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"We can then plot the branches using BK.plotBranch(br, branches...) where green (resp. red) means stable (resp. unstable) solution.","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"(Image: )","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"There are 19 banches that were discovered. You can plot the solutions on the branches using ","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"fig = Figure(resolution = (1200, 900))\n\tfor i=1:length(br1)\n\t\tix = div(i,5)+1; iy = i%5+1\n\t\t@show i, ix, iy\n\t\tax = Axis3(fig[ix, iy], title = \"$i\", aspect = (1, 1, 1))\n\t\thidedecorations!(ax, grid=false)\n\t\tcontour3dMakie!(ax, br1[i].sol[2].x)\n\t\tax.protrusions = (0, 0, 0, 10)\n\tend\n\tdisplay(fig)","category":"page"},{"location":"tutorialsSH3d/","page":"3d Swift-Hohenberg equation, Finite differences","title":"3d Swift-Hohenberg equation, Finite differences","text":"(Image: )","category":"page"},{"location":"borderedlinearsolver/#Bordered-linear-solvers-(BLS)","page":"Bordered linear solvers","title":"Bordered linear solvers (BLS)","text":"","category":"section"},{"location":"borderedlinearsolver/","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"The bordered linear solvers must be subtypes of AbstractBorderedLinearSolver <: AbstractLinearSolver. ","category":"page"},{"location":"borderedlinearsolver/","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"The methods provided here solve bordered linear equations. More precisely, one is interested in the solution u to Jcdot u = v where","category":"page"},{"location":"borderedlinearsolver/","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"tag E J=left(beginarrayll\nA  b \nc  d\nendarrayright) text  and  v=left(beginarrayl\nv_1 \nv_2\nendarrayright)","category":"page"},{"location":"borderedlinearsolver/","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"Such linear solver bdlsolve will be called like sol, success, itnumber = bdlsolve(A, b, c, d, v1, v2) throughout the package.","category":"page"},{"location":"borderedlinearsolver/#Full-matrix-MatrixBLS","page":"Bordered linear solvers","title":"Full matrix MatrixBLS","text":"","category":"section"},{"location":"borderedlinearsolver/","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"This easiest way to solve (E) is by forming the matrix J. In case it is sparse, it should be relatively efficient. You can create such bordered linear solver using bls = MatrixBLS(ls) where ls::AbstractLinearSolver is a linear solver (which defaults to \\) used to solve invert J.","category":"page"},{"location":"borderedlinearsolver/#Bordering-method-BorderingBLS","page":"Bordered linear solvers","title":"Bordering method BorderingBLS","text":"","category":"section"},{"location":"borderedlinearsolver/","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"The general solution to (E) when A is non singular is x_1=A^-1v_1 x_2=A^-1b, u_2 = frac1d - (cx_2)(v_2 - (cx_1)) and u_1=x_1-u_2x_2. This is the default method used in the package. It is very efficient for large scale problems because it is entirely Matrix-Free and one can use preconditioners. You can create such bordered linear solver using bls = BorderingBLS(ls) where ls::AbstractLinearSolver is a linear solver which defaults to \\. The intermediate solutions x_1=A^-1v_1 x_2=A^-1b are formed using ls.","category":"page"},{"location":"borderedlinearsolver/","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"Using such method with ls being a GMRES method is the main way to solve (E) in this package.\nIn the case where ls = DefaultLS(), the factorisation of A is cached so the second linear solve is very fast ","category":"page"},{"location":"borderedlinearsolver/#Full-Matrix-Free-MatrixFreeBLS","page":"Bordered linear solvers","title":"Full Matrix-Free MatrixFreeBLS","text":"","category":"section"},{"location":"borderedlinearsolver/","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"In cases where A is singular but J is not, the bordering method may fail. It can thus be advantageous to form the Matrix-Free version of J and call a generic linear solver to find the solution to (E). You can create such bordered linear solver using bls = MatrixFreeBLS(ls) where ls::AbstractLinearSolver is a (Matrix Free) linear solver which is used to invert J.","category":"page"},{"location":"borderedlinearsolver/","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"For now, this linear solver only works with AbstractArray","category":"page"},{"location":"constrainedproblem/#Constrained-problems","page":"Constrained problem","title":"Constrained problems","text":"","category":"section"},{"location":"constrainedproblem/","page":"Constrained problem","title":"Constrained problem","text":"compat: Experimental\nThis feature is still experimental. It has not been tested thoroughly, especially the case of multiple constraints and matrix-free functionals.","category":"page"},{"location":"constrainedproblem/","page":"Constrained problem","title":"Constrained problem","text":"This section is dedicated to the study of an equation (in x) F(x,p)=0 where one wishes to add a constraint g(x,p)=0. Hence, one is interested in solving in the couple (xp):","category":"page"},{"location":"constrainedproblem/","page":"Constrained problem","title":"Constrained problem","text":"left\nbeginarrayl\nF(xp)=0 \ng(xp)=0\nendarrayright","category":"page"},{"location":"constrainedproblem/","page":"Constrained problem","title":"Constrained problem","text":"There are several situations where this proves useful:","category":"page"},{"location":"constrainedproblem/","page":"Constrained problem","title":"Constrained problem","text":"the pseudo-arclength continuation method is such a constrained problem, see continuation for more details.\nwhen the equation F(x) has a continuous symmetry described by a Lie group G and action gcdot x for gin G. One can reduce the symmetry of the problem by considering the constrained problem:","category":"page"},{"location":"constrainedproblem/","page":"Constrained problem","title":"Constrained problem","text":"left\nbeginarrayl\nF(x) + pcdot Tcdot x=0 \nlangle Tcdot x_refx-x_refrangle=0\nendarrayright","category":"page"},{"location":"constrainedproblem/","page":"Constrained problem","title":"Constrained problem","text":"where T is a generator of the Lie algebra associated to G and x_ref is a reference solution. This is known as the freezing method.","category":"page"},{"location":"constrainedproblem/","page":"Constrained problem","title":"Constrained problem","text":"unknown: Reference\nSee Beyn and Thümmler, Phase Conditions, Symmetries and PDE Continuation. for more information on the freezing method.","category":"page"},{"location":"constrainedproblem/#Encoding-of-the-functional","page":"Constrained problem","title":"Encoding of the functional","text":"","category":"section"},{"location":"constrainedproblem/","page":"Constrained problem","title":"Constrained problem","text":"A composite type which implements this functional:","category":"page"},{"location":"constrainedproblem/","page":"Constrained problem","title":"Constrained problem","text":"BorderedProblem","category":"page"},{"location":"constrainedproblem/#BifurcationKit.BorderedProblem","page":"Constrained problem","title":"BifurcationKit.BorderedProblem","text":"pb = BorderedProblem(;F, dxF, dpF, g, ∇g, dpg)\n\nThis composite type encodes a bordered problem, one by which we add a scalar constraint g(x, p) = 0 to an equation F(x, p) = 0. This composite type thus allows to define the functional G((x, p)) = [F(x, p) g(x, p)] and solve G = 0.\n\nYou can then evaluate the functional using or pb(z) where z = BorderedArray(x, p) or z = vcat(x, p), i.e. the last component of the vector is the Lagrange Multiplier.\n\nArguments\n\nThe arguments correspond to the functions F, g and their derivatives.\n\nSimplified constructor\n\nYou can create such functional as pb = BorderedProblem(F, g).\n\nwarning: Multidimensional constraint (Really Experimental)\nIt is in fact possible, using this composite type, to define a bordered problem with constraint of dimension npar > 1. One has to pass the dimension to pb = BorderedProblem(F, g, npar) and possibly the derivatives as well. The second argument of F,g is npar dimensional (for now an AbstractVector). Finally, the only possible linear (bordered) solver in this case is ::MatrixBLS.\n\n\n\n\n\n","category":"type"},{"location":"deflatedproblem/#Deflated-problems","page":"Deflated problems","title":"Deflated problems","text":"","category":"section"},{"location":"deflatedproblem/","page":"Deflated problems","title":"Deflated problems","text":"unknown: References\nP. E. Farrell, A. Birkisson, and S. W. Funke. Deflation techniques for finding distinct solutions of nonlinear partial differential equations. SIAM J. Sci. Comput., 2015.,","category":"page"},{"location":"deflatedproblem/","page":"Deflated problems","title":"Deflated problems","text":"Assume you want to solve F(x)=0 with a Newton algorithm but you want to avoid the algorithm to return some already known solutions x_i i=1cdots n. ","category":"page"},{"location":"deflatedproblem/","page":"Deflated problems","title":"Deflated problems","text":"The idea proposed in the paper quoted above is to penalize these solutions by looking for the zeros of the function G(x)=F(x)M(x) where","category":"page"},{"location":"deflatedproblem/","page":"Deflated problems","title":"Deflated problems","text":"M(x) = prod_i=1^nleft(x - x_i^-p + alpharight)","category":"page"},{"location":"deflatedproblem/","page":"Deflated problems","title":"Deflated problems","text":"and alpha0. Obviously F and G have the same zeros away from the x_is but the factor M penalizes the residual of the Newton iterations of G, effectively producing zeros of F different from x_i.","category":"page"},{"location":"deflatedproblem/#Encoding-of-the-functional","page":"Deflated problems","title":"Encoding of the functional","text":"","category":"section"},{"location":"deflatedproblem/","page":"Deflated problems","title":"Deflated problems","text":"A composite type DeflationOperator implements this functional. Given a deflation operator M = DeflationOperator(p, dot, α, xis), you can build a deflated functional pb = DeflatedProblem(F, J, M) which you can use to access the values of G by doing pb(x). A Matrix-Free / Sparse linear solver is implemented which works on the GPU.","category":"page"},{"location":"deflatedproblem/","page":"Deflated problems","title":"Deflated problems","text":"the dot argument in DeflationOperator lets you specify a dot product from which the norm is derived in the expression of M.","category":"page"},{"location":"deflatedproblem/","page":"Deflated problems","title":"Deflated problems","text":"See example Snaking computed with deflation.","category":"page"},{"location":"deflatedproblem/","page":"Deflated problems","title":"Deflated problems","text":"Note that you can add new solution x0 to M by doing push!(M, x0). Also M[i] returns xi.","category":"page"},{"location":"deflatedproblem/#Computation-with-newton","page":"Deflated problems","title":"Computation with newton","text":"","category":"section"},{"location":"deflatedproblem/","page":"Deflated problems","title":"Deflated problems","text":"Most newton functions can be used with a deflated problem, see for example Snaking computed with deflation. The idea is to pass the deflation operator M. For example, we have the following overloaded method, which works on GPUs: ","category":"page"},{"location":"deflatedproblem/","page":"Deflated problems","title":"Deflated problems","text":"newton(F, J, x0, p0, options::NewtonPar, defOp::DeflationOperator, linsolver = DeflatedLinearSolver(); kwargs...)","category":"page"},{"location":"deflatedproblem/","page":"Deflated problems","title":"Deflated problems","text":"If you pass a linear solver other than the default one ::DeflatedLinearSolver, a Matrix-Free is used in place of the dedicated solver DeflatedLinearSolver which is akin to a Bordering method.","category":"page"},{"location":"deflatedproblem/","page":"Deflated problems","title":"Deflated problems","text":"We refer to newton for more information about the arguments.","category":"page"},{"location":"deflatedproblem/","page":"Deflated problems","title":"Deflated problems","text":"tip: Tip\nYou can use this method for periodic orbits as well by passing the deflation operator M to the newton method","category":"page"},{"location":"tutorials3/#d-Brusselator-(automatic)","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"","category":"section"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"Pages = [\"tutorials3.md\"]\nDepth = 3","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"unknown: References\nThis example is taken from Numerical Bifurcation Analysis of Periodic Solutions of Partial Differential Equations, Lust, 1997.","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"We look at the Brusselator in 1d. The equations are as follows","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"beginaligned frac  partial X   partial t   = frac  D _  1    l ^  2   frac  partial ^  2  X   partial z ^  2   + X ^  2  Y - ( β + 1 ) X + α  frac  partial Y   partial t   = frac  D _  2    l ^  2   frac  partial ^  2  Y   partial z ^  2   + β X - X ^  2  Y endaligned","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"with Dirichlet boundary conditions","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"beginarray  l   X ( t  z = 0 ) = X ( t  z = 1 ) = α    Y ( t  z = 0 ) = Y ( t  z = 1 ) = β  α  endarray","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"These equations have been introduced to reproduce an oscillating chemical reaction. There is an obvious equilibrium (α β  α). Here, we consider bifurcations with respect to the parameter l.","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"We start by writing the PDE","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"using Revise\nusing BifurcationKit, LinearAlgebra, Plots, SparseArrays, Setfield, Parameters\nconst BK = BifurcationKit\n\nf1(u, v) = u * u * v\nnorminf = x -> norm(x, Inf)\n\nfunction Fbru(x, p)\n\t@unpack α, β, D1, D2, l = p\n\tf = similar(x)\n\tn = div(length(x), 2)\n\th = 1.0 / n; h2 = h*h\n\tc1 = D1 / l^2 / h2\n\tc2 = D2 / l^2 / h2\n\n\tu = @view x[1:n]\n\tv = @view x[n+1:2n]\n\n\t# Dirichlet boundary conditions\n\tf[1]   = c1 * (α      - 2u[1] + u[2] ) + α - (β + 1) * u[1] + f1(u[1], v[1])\n\tf[end] = c2 * (v[n-1] - 2v[n] + β / α)\t\t\t + β * u[n] - f1(u[n], v[n])\n\n\tf[n]   = c1 * (u[n-1] - 2u[n] +  α  )  + α - (β + 1) * u[n] + f1(u[n], v[n])\n\tf[n+1] = c2 * (β / α  - 2v[1] + v[2])\t\t\t + β * u[1] - f1(u[1], v[1])\n\n\tfor i=2:n-1\n\t\t  f[i] = c1 * (u[i-1] - 2u[i] + u[i+1]) + α - (β + 1) * u[i] + f1(u[i], v[i])\n\t\tf[n+i] = c2 * (v[i-1] - 2v[i] + v[i+1])\t\t\t  + β * u[i] - f1(u[i], v[i])\n\tend\n\treturn f\nend","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"For computing periodic orbits, we will need a Sparse representation of the Jacobian:","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"function Jbru_sp(x, p)\n\t@unpack α, β, D1, D2, l = p\n\t# compute the Jacobian using a sparse representation\n\tn = div(length(x), 2)\n\th = 1.0 / n; h2 = h*h\n\n\tc1 = D1 / p.l^2 / h2\n\tc2 = D2 / p.l^2 / h2\n\n\tu = @view x[1:n]\n\tv = @view x[n+1:2n]\n\n\tdiag   = zeros(eltype(x), 2n)\n\tdiagp1 = zeros(eltype(x), 2n-1)\n\tdiagm1 = zeros(eltype(x), 2n-1)\n\n\tdiagpn = zeros(eltype(x), n)\n\tdiagmn = zeros(eltype(x), n)\n\n\t@. diagmn = β - 2 * u * v\n\t@. diagm1[1:n-1] = c1\n\t@. diagm1[n+1:end] = c2\n\n\t@. diag[1:n]    = -2c1 - (β + 1) + 2 * u * v\n\t@. diag[n+1:2n] = -2c2 - u * u\n\n\t@. diagp1[1:n-1] = c1\n\t@. diagp1[n+1:end] = c2\n\n\t@. diagpn = u * u\n\treturn spdiagm(0 => diag, 1 => diagp1, -1 => diagm1, n => diagpn, -n => diagmn)\nend","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"tip: Tip\nWe could have used DiffEqOperators.jl like for the Swift-Hohenberg tutorial.","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"Finally, it will prove useful to have access to the hessian and third derivative","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"# we group the differentials together\njet  = BK.getJet(Fbru, Jbru_sp)","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"We shall now compute the equilibria and their stability.","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"n = 300\n\n# parameters of the Brusselator model and guess for the stationary solution\npar_bru = (α = 2., β = 5.45, D1 = 0.008, D2 = 0.004, l = 0.3)\nsol0 = vcat(par_bru.α * ones(n), par_bru.β/par_bru.α * ones(n))","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"For the eigensolver, we use a Shift-Invert algorithm (see Eigen solvers (Eig))","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"eigls = EigArpack(1.1, :LM)","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"We continue the trivial equilibrium to find the Hopf points","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"opt_newton = NewtonPar(eigsolver = eigls, verbose = false)\nopts_br_eq = ContinuationPar(dsmin = 0.001, dsmax = 0.01, ds = 0.001,\n\tpMax = 1.9, detectBifurcation = 3, nev = 21, plotEveryStep = 50,\n\tnewtonOptions = NewtonPar(eigsolver = eigls, tol = 1e-9), maxSteps = 1060,\n\t# specific options for precise localization of Hopf points\n\tnInversion = 6)\n\n\tbr, = @time continuation(Fbru, Jbru_sp, sol0, par_bru, (@lens _.l),\n\t\topts_br_eq, verbosity = 0,\n\t\tplot = true,\n\t\trecordFromSolution = (x,p) -> x[n÷2], normC = norminf)","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"We obtain the following bifurcation diagram with 3 Hopf bifurcation points","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"(Image: )","category":"page"},{"location":"tutorials3/#Normal-form-computation","page":"1d Brusselator (automatic)","title":"Normal form computation","text":"","category":"section"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"We can compute the normal form of the Hopf points as follows","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"hopfpt = BK.computeNormalForm(jet..., br, 1)","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"and you should get","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"julia> hopfpt\nSuperCritical - Hopf bifurcation point at l ≈ 0.5113310149554013.\nPeriod of the periodic orbit ≈ 2.9367552006841753\nNormal form z⋅(a⋅δp + b⋅|z|²): \n(a = 0.8799941318427783 + 0.5689746667563035im, b = -0.0015608102901479592 + 0.0015634810970084371im)","category":"page"},{"location":"tutorials3/#Continuation-of-Hopf-points","page":"1d Brusselator (automatic)","title":"Continuation of Hopf points","text":"","category":"section"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"We use the bifurcation points guesses located in br.specialpoint to turn them into precise bifurcation points. For the second one, we have","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"# index of the Hopf point in br.specialpoint\nind_hopf = 2\nhopfpoint, _, flag = @time newton(Fbru, Jbru_sp,\n\tbr, ind_hopf; normN = norminf)\nflag && printstyled(color=:red, \"--> We found a Hopf Point at l = \", hopfpoint.p[1], \", ω = \", hopfpoint.p[2], \", from l = \", br.specialpoint[ind_hopf].param, \"\\n\")","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"which produces","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"--> We found a Hopf Point at l = 1.0239851696548035, ω = 2.1395092895339842, from l = 1.0353910524340078","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"We now perform a Hopf continuation with respect to the parameters l, β","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"tip: Tip\nYou don't need to call newton first in order to use continuation.","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"optcdim2 = ContinuationPar(dsmin = 0.001, dsmax = 0.05, ds= 0.01, pMax = 6.5, pMin = 0.0, newtonOptions = opt_newton)\nbr_hopf, = @time continuation(Fbru, Jbru_sp,\n\tbr, ind_hopf, (@lens _.β),\n\toptcdim2, verbosity = 2, \n\tnormC = norminf)","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"which gives using plot(br_hopf)","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"(Image: )","category":"page"},{"location":"tutorials3/#Computation-of-the-branch-of-periodic-orbits-(Finite-differences)","page":"1d Brusselator (automatic)","title":"Computation of the branch of periodic orbits (Finite differences)","text":"","category":"section"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"We now compute the bifurcated branches of periodic solutions from the Hopf points using Periodic orbits based on trapezoidal rule. One has just to pass a PeriodicOrbitTrapProblem.","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"We start by providing a linear solver and some options for the continuation to work","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"# automatic branch switching from Hopf point\nopt_po = NewtonPar(tol = 1e-10, verbose = true, maxIter = 15)\nopts_po_cont = ContinuationPar(dsmin = 0.001, dsmax = 0.04, ds = 0.03, pMax = 2.2, maxSteps = 200, newtonOptions = opt_po, saveSolEveryStep = 2,\n\tplotEveryStep = 1, nev = 11, precisionStability = 1e-6,\n\tdetectBifurcation = 3, dsminBisection = 1e-6, maxBisectionSteps = 15, tolBisectionEigenvalue = 0.)","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"# number of time slices for the periodic orbit\nM = 51\nprobFD = PeriodicOrbitTrapProblem(M = M)\nbr_po, = continuation(\n\t# arguments for branch switching from the first\n\t# Hopf bifurcation point\n\tjet..., br, 1,\n\t# arguments for continuation\n\topts_po_cont, probFD;\n\t# OPTIONAL parameters\n\t# we want to jump on the new branch at phopf + δp\n\t# ampfactor is a factor to increase the amplitude of the guess\n\tδp = 0.01, ampfactor = 1,\n\t# specific method for solving linear system\n\t# of Periodic orbits with trapeze method\n\t# You could use the default one :FullLU (slower here)\n\tlinearPO = :FullSparseInplace,\n\t# regular options for continuation\n\tverbosity = 3,\tplot = true,\n\tplotSolution = (x, p; kwargs...) -> heatmap!(reshape(x[1:end-1], 2*n, M)'; ylabel=\"time\", color=:viridis, kwargs...),\n\tnormC = norminf)","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"(Image: )","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"Using the above call, it is very easy to find the first branches:","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"(Image: )","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"We note that there are several branch points (blue points) on the above diagram. This means that there are additional branches in the neighborhood of these points. We now turn to automatic branch switching on these branches. This functionality, as we shall see, is only provided for PeriodicOrbitTrapProblem.","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"Let's say we want to branch from the first branch point of the first curve pink branch. The syntax is very similar to the previous one:","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"br_po2, = BK.continuationPOTrapBPFromPO(\n\t# arguments for branch switching\n\tbr_po, 1,\n\t# arguments for continuation\n\topts_po_cont; linearPO = :FullSparseInplace,\n\tampfactor = 1., δp = 0.01,\n\tverbosity = 3,\tplot = true,\n\tplotSolution = (x, p; kwargs...) -> heatmap!(reshape(x[1:end-1], 2*n, M)'; ylabel=\"time\", color=:viridis, kwargs...),\n\tnormC = norminf)","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"It is now straightforward to get the full following diagram","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"(Image: )","category":"page"},{"location":"tutorials3/#Computation-of-the-branch-of-periodic-orbits-(Standard-Shooting)","page":"1d Brusselator (automatic)","title":"Computation of the branch of periodic orbits (Standard Shooting)","text":"","category":"section"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"Note that what follows is not really optimized on the DifferentialEquations.jl side. Indeed, we do not use automatic differentiation, we do not pass the sparsity pattern, ...","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"We now turn to a different method based on the flow of the Brusselator. To compute this flow (time stepper), we need to be able to solve the differential equation (actually a PDE) associated to the vector field Fbru. We will show how to do this with an implicit method Rodas4P from DifferentialEquations.jl. Note that the user can pass its own time stepper but for convenience, we use the ones in DifferentialEquations.jl. More information regarding the shooting method is contained in Periodic orbits based on the shooting method. To define the flow, it is better to have an inplace version of the vector field:","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"function Fbru!(f, x, p)\n\t@unpack α, β, D1, D2, l = p\n\tn = div(length(x), 2)\n\th = 1.0 / n; h2 = h*h\n\tc1 = D1 / l^2 / h2\n\tc2 = D2 / l^2 / h2\n\n\tu = @view x[1:n]\n\tv = @view x[n+1:2n]\n\n\t# Dirichlet boundary conditions\n\tf[1]   = c1 * (α\t  - 2u[1] + u[2] ) + α - (β + 1) * u[1] + f1(u[1], v[1])\n\tf[end] = c2 * (v[n-1] - 2v[n] + β / α)\t\t\t + β * u[n] - f1(u[n], v[n])\n\n\tf[n]   = c1 * (u[n-1] - 2u[n] +  α   ) + α - (β + 1) * u[n] + f1(u[n], v[n])\n\tf[n+1] = c2 * (β / α  - 2v[1] + v[2])\t\t\t + β * u[1] - f1(u[1], v[1])\n\n\tfor i=2:n-1\n\t\t  f[i] = c1 * (u[i-1] - 2u[i] + u[i+1]) + α - (β + 1) * u[i] + f1(u[i], v[i])\n\t\tf[n+i] = c2 * (v[i-1] - 2v[i] + v[i+1])\t\t\t  + β * u[i] - f1(u[i], v[i])\n\tend\n\treturn f\nend\n\nFbru(x, p) = Fbru!(similar(x), x, p)","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"We then recompute the locus of the Hopf bifurcation points using the same method as above.","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"n = 100\n\n# different parameters to define the Brusselator model and guess for the stationary solution\npar_bru = (α = 2., β = 5.45, D1 = 0.008, D2 = 0.004, l = 0.3)\nsol0 = vcat(par_bru.α * ones(n), par_bru.β/par_bru.α * ones(n))\n\neigls = EigArpack(1.1, :LM)\nopts_br_eq = ContinuationPar(dsmin = 0.001, dsmax = 0.00615, ds = 0.0061, pMax = 1.9,\n\tdetectBifurcation = 3, nev = 21, plotEveryStep = 50,\n\tnewtonOptions = NewtonPar(eigsolver = eigls, tol = 1e-9), maxSteps = 200)\n\nbr, = @time continuation(Fbru, Jbru_sp,\n\tsol0, par_bru, (@lens _.l), opts_br_eq, verbosity = 0,\n\tplot = false,\n\trecordFromSolution = (x, p)->x[n÷2], normC = norminf)","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"We need to build a problem which encodes the Shooting functional. This done as follows where we first create the time stepper:","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"using DifferentialEquations, DiffEqOperators\n\nFOde(f, x, p, t) = Fbru!(f, x, p)\n\nu0 = sol0 .+ 0.01 .* rand(2n)\n\n# this is the ODE time stepper when used with `solve`\nprobsundials = ODEProblem(FOde, u0, (0., 1000.), par_bru;\n\tatol = 1e-10, rtol = 1e-8, jac = (J,u,p,t) -> J .= Jbru_sp(u,p), jac_prototype = Jbru_sp(u0, par_bru))","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"tip: Performance\nYou can really speed this up by using the improved ODEProblemusing SparseDiffTools, SparseArrays, DiffEqDiffTools\njac_prototype = Jbru_sp(ones(2n), par_bru)\njac_prototype.nzval .= ones(length(jac_prototype.nzval))\n_colors = matrix_colors(jac_prototype)\nvf = ODEFunction(FOde; jac_prototype = jac_prototype, colorvec = _colors)\nprobsundials = ODEProblem(vf,  u0, (0.0, 520.), par_bru) # gives 0.22s","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"We also compute with automatic differentiation, the differentials of the vector field. This is is needed for branch switching as it is based on the computation of the Hopf normal form:","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"using ForwardDiff\nfunction D(f, x, p, dx)\n\treturn ForwardDiff.derivative(t->f(x .+ t .* dx, p), 0.)\nend\nd1Fbru(x,p,dx1) = D((z, p0) -> Fbru(z, p0), x, p, dx1)\nd2Fbru(x,p,dx1,dx2) = D((z, p0) -> d1Fbru(z, p0, dx1), x, p, dx2)\nd3Fbru(x,p,dx1,dx2,dx3) = D((z, p0) -> d2Fbru(z, p0, dx1, dx2), x, p, dx3)\n\njet  = (Fbru, Jbru_sp, d2Fbru, d3Fbru)","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"We are now ready to call the automatic branch switching. Note how similar it is to the previous section based on finite differences. This case is more deeply studied in the tutorial 1d Brusselator (advanced user). We use a parallel Shooting.","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"# linear solvers\nls = GMRESIterativeSolvers(reltol = 1e-7, maxiter = 100, verbose = false)\neig = EigKrylovKit(tol= 1e-12, x₀ = rand(2n), verbose = 0, dim = 40)\n# newton parameters\noptn_po = NewtonPar(verbose = true, tol = 1e-7,  maxIter = 25, linsolver = ls, eigsolver = eig)\n# continuation parameters\nopts_po_cont = ContinuationPar(dsmax = 0.03, ds= 0.01, pMax = 2.5, maxSteps = 10,\n\tnewtonOptions = optn_po, nev = 15, precisionStability = 1e-3,\n\tdetectBifurcation = 0, plotEveryStep = 2)\n\nMt = 2 # number of shooting sections\nbr_po, = continuation(\n\tjet..., br, 1,\n\t# arguments for continuation\n\topts_po_cont,\n\t# this is where we tell that we want Parallel Standard Shooting\n\tShootingProblem(Mt, par_bru, probsundials, Rodas4P(), abstol = 1e-10, retol = 1e-8, parallel = true);\n\tampfactor = 1.0, δp = 0.0075,\n\t# the next option is not necessary\n\t# it speeds up the newton iterations\n\t# by combining the linear solves of the bordered linear system\n\tlinearAlgo = MatrixFreeBLS(@set ls.N = 2+2n*Mt),\n\tverbosity = 3,\tplot = true,\n\tplotSolution = (x, p; kwargs...) -> BK.plotPeriodicShooting!(x[1:end-1], Mt; kwargs...),\n\tnormC = norminf)","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"and you should see","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"(Image: )","category":"page"},{"location":"tutorials3/#Computation-of-the-branch-of-periodic-orbits-(Poincaré-Shooting)","page":"1d Brusselator (automatic)","title":"Computation of the branch of periodic orbits (Poincaré Shooting)","text":"","category":"section"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"We now turn to another Shooting method, namely the Poincaré one. We can provide this method thanks to the unique functionalities of DifferentialEquations.jl. More information is provided at PoincareShootingProblem and Periodic orbits based on the shooting method but basically, it is a shooting method between Poincaré sections Sigma_i (along the orbit) defined by hyperplanes. As a consequence, the dimension of the unknowns is M_shcdot(N-1) where N is the dimension of the phase space. Indeed, each time slice lives in an hyperplane Sigma_i. Additionally, the period T is not an unknown of the method but rather a by-product. However, the method requires the time stepper to find when the flow hits an hyperplane Sigma_i, something called event detection.","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"We show how to use this method, the code is very similar to the case of the Parallel Standard Shooting:","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"# linear solvers\nls = GMRESIterativeSolvers(reltol = 1e-8, maxiter = 100)\neig = EigKrylovKit(tol= 1e-12, x₀ = rand(2n-1), verbose = 0, dim = 50)\n# newton parameters\noptn_po = NewtonPar(verbose = true, tol = 1e-7,  maxIter = 25, linsolver = ls, eigsolver = eig)\n# continuation parameters\nopts_po_cont = ContinuationPar(dsmax = 0.03, ds= 0.005, pMax = 2.5, maxSteps = 100, newtonOptions = optn_po, nev = 10, precisionStability = 1e-5, detectBifurcation = 0, plotEveryStep = 2)\n\n# number of time slices\nMt = 1\nbr_po, = continuation(\n\tjet..., br, 1,\n\t# arguments for continuation\n\topts_po_cont, PoincareShootingProblem(Mt, par_bru, probsundials, Rodas4P(); abstol = 1e-10, retol = 1e-8, parallel = true);\n\t# the next option is not necessary\n\t# it speeds up the newton iterations\n\t# by combining the linear solves of the bordered linear system\n\tlinearAlgo = MatrixFreeBLS(@set ls.N = (2n-1)*Mt+1),\n\tampfactor = 1.0, δp = 0.005,\n\tverbosity = 3,\tplot = true,\n\tupdateSectionEveryStep = 1,\n\tplotSolution = (x, p; kwargs...) -> BK.plotPeriodicShooting!(x[1:end-1], Mt; kwargs...),\n\tnormC = norminf)","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"and you should see:","category":"page"},{"location":"tutorials3/","page":"1d Brusselator (automatic)","title":"1d Brusselator (automatic)","text":"(Image: )","category":"page"},{"location":"mittelmannAuto/#Automatic-diagram-of-2d-Bratu–Gelfand-problem-(Intermediate)","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"","category":"section"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"Pages = [\"mittelmannAuto.md\"]\nDepth = 3","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"unknown: References\nThe following example is exposed in Farrell, Patrick E., Casper H. L. Beentjes, and Ásgeir Birkisson. The Computation of Disconnected Bifurcation Diagrams. ArXiv:1603.00809 [Math], March 2, 2016. . It is also treated in Michiel Wouters. Automatic Exploration Techniques for the Numerical Continuation of Large–Scale Nonlinear Systems, 2019.","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"We consider the problem of Mittelmann:","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"Delta u +NL(lambdau) = 0","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"with Neumann boundary condition on Omega = (01)^2 and where NL(lambdau)equiv-10(u-lambda e^u). This is a good example to show how automatic bifurcation diagram computation works.","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"We start with some imports:","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"using Revise\nusing DiffEqOperators, ForwardDiff\nusing BifurcationKit, LinearAlgebra, Plots, SparseArrays, Parameters, Setfield\nconst BK = BifurcationKit\n\n# define the sup norm\nnorminf = x -> norm(x, Inf)\nnorm2 = x -> norm(x) / sqrt(length(x))\nnormbratu = x -> norm(x .* w) / sqrt(length(x)) # the weight w is defined below\n\n# some plotting functions to simplify our life\nplotsol!(x, nx = Nx, ny = Ny; kwargs...) = heatmap!(reshape(x, nx, ny); color = :viridis, kwargs...)\nplotsol(x, nx = Nx, ny = Ny; kwargs...) = (plot();plotsol!(x, nx, ny; kwargs...))","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"and with the discretization of the problem","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"function Laplacian2D(Nx, Ny, lx, ly, bc = :Neumann)\n\thx = 2lx/Nx\n\thy = 2ly/Ny\n\tD2x = CenteredDifference(2, 2, hx, Nx)\n\tD2y = CenteredDifference(2, 2, hy, Ny)\n\n\tQx = Neumann0BC(hx)\n\tQy = Neumann0BC(hy)\n\n\tD2xsp = sparse(D2x * Qx)[1]\n\tD2ysp = sparse(D2y * Qy)[1]\n\tA = kron(sparse(I, Ny, Ny), D2xsp) + kron(D2ysp, sparse(I, Nx, Nx))\n\treturn A\nend\n\nϕ(u, λ)  = -10(u-λ*exp(u))\ndϕ(u, λ) = -10(1-λ*exp(u))\n\nfunction NL!(dest, u, p)\n\t@unpack λ = p\n\tdest .= ϕ.(u, λ)\n\treturn dest\nend\n\nNL(u, p) = NL!(similar(u), u, p)\n\nfunction Fmit!(f, u, p)\n\tmul!(f, p.Δ, u)\n\tf .= f .+ NL(u, p)\n\treturn f\nend\n\nFmit(u, p) = Fmit!(similar(u), u, p)","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"It will also prove useful to have the jacobian of our functional and the other derivatives: ","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"function JFmit(x,p)\n\tJ = p.Δ\n\tdg = dϕ.(x, p.λ)\n\treturn J + spdiagm(0 => dg)\nend\n\njet = BK.getJet(Fmit, JFmit)","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"We need to pass the parameters associated to this problem:","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"Nx = 30\nNy = 30\nlx = 0.5\nly = 0.5\n\n# weight for normbratu\nconst w = (lx .+ LinRange(-lx,lx,Nx)) * (LinRange(-ly,ly,Ny))' |> vec\nw .-= minimum(w)\n\n\nΔ = Laplacian2D(Nx, Ny, lx, ly)\n\n# parameters associated with the PDE\npar_mit = (λ = .01, Δ = Δ)\n\n# initial condition\nsol0 = 0*ones(Nx, Ny) |> vec","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"To compute the eigenvalues, we opt for the solver in KrylovKit.jl","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"# eigensolver\neigls = EigKrylovKit(dim = 70)\n\n# options for Newton solver\nopt_newton = NewtonPar(tol = 1e-8, verbose = true, eigsolver = eigls, maxIter = 20)\n\n# options for continuation, we want to locate very precisely the \n# bifurcation points, so we tune the bisection accordingly\nopts_br = ContinuationPar(dsmin = 0.0001, dsmax = 0.04, ds = 0.005, pMax = 3.5, pMin = 0.01, detectBifurcation = 3, nev = 50, plotEveryStep = 10, newtonOptions = (@set opt_newton.verbose = false), maxSteps = 251, precisionStability = 1e-6, nInversion = 6, dsminBisection = 1e-7, maxBisectionSteps = 25, tolBisectionEigenvalue = 1e-19)","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"Note that we put the option detectBifurcation = 3 to detect bifurcations precisely with a bisection method. Indeed, we need to locate these branch points precisely to be able to call automatic branch switching.","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"In order to have an output like Auto07p, we provide the finaliser (see arguments of continuation)","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"function finSol(z, tau, step, br; k...)\n\tif length(br.specialpoint)>0\n\t\tif br.specialpoint[end].step == step\n\t\t\tBK._show(stdout, br.specialpoint[end], step)\n\t\tend\n\tend\n\treturn true\nend","category":"page"},{"location":"mittelmannAuto/#Automatic-bifurcation-diagram","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic bifurcation diagram","text":"","category":"section"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"In order to avoid spurious branch switching, we use a callback (see continuation) to reject specific continuation steps where the jump in parameters is too large or when the residual is too large:","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"function cb(x,f,J,res,it,itl,optN; kwargs...)\n\t_x = get(kwargs, :z0, nothing)\n\tfromNewton = get(kwargs, :fromNewton, false)\n\tif ~fromNewton\n\t\treturn (norm(_x.u - x) < 20.5 && abs(_x.p - kwargs[:p]) < 0.05)\n\tend\n\ttrue\nend","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"Finally, before calling the automatic bifurcationdiagram, we need to provide a function to adjust the continuation parameters as function of the branching level (Note that this function can be constant).","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"function optionsCont(x,p,l; opt0 = opts_br)\n\tif l == 1\n\t\treturn opt0\n\telseif l==2\n\t\treturn setproperties(opt0 ;detectBifurcation = 3,ds = 0.001, a = 0.75)\n\telse\n\t\treturn setproperties(opt0 ;detectBifurcation = 3,ds = 0.00051, dsmax = 0.01)\n\tend\nend","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"We are then ready to compute the bifurcation diagram. If we choose a level 5 of recursion like ","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"diagram = @time bifurcationdiagram(jet...,\n\tsol0, par_mit, (@lens _.λ), \n\t# important argument: this is the maximal \n\t# recursion level \n\t5, \n\toptionsCont;\n\tverbosity = 0, plot = true,\n\trecordFromSolution = (x, p) -> (n2 = norm2(x), nw = normbratu(x), n∞ = norminf(x)),\n\tcallbackN = cb,\n\tusedeflation = true,\n\tfinaliseSolution = finSol,\n\tplotSolution = (x, p; kwargs...) -> plotsol!(x ; kwargs...),\n\tnormC = norminf)","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"this gives using plot(diagram; plotfold = false, putspecialptlegend=false, markersize=2, title = \"#branches = $(size(diagram))\"):","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"(Image: )","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"We can zoom in on the left part to get ","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"(Image: )","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"Actually, this plot is misleading because of the symmetries. If we chose a weighted norm which breaks those symmetries and use it to print the solution, we get","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"plot(diagram; plotfold = false, putspecialptlegend=false, markersize=2, \n\ttitle = \"#branches = $(size(diagram))\", vars = (:param, :nw))","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"(Image: )","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"We can make more sense of these spaghetti by only plotting the first two levels of recursion","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"plot(diagram; level = (1, 2), plotfold = false, putspecialptlegend=false, markersize=2, vars = (:param, :nw))","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"(Image: )","category":"page"},{"location":"mittelmannAuto/#Interactive-exploration","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Interactive exploration","text":"","category":"section"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"We can see that the non-simple 2d branch points (magenta points) have produced non trivial branches. For example, we can look at the second bifurcation point (the first is the fold) which is composed of 8 branches","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"plot(getBranchesFromBP(diagram, 2); plotfold = false, legend = false, vars = (:param, :nw))","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"(Image: )","category":"page"},{"location":"mittelmannAuto/#Interactive-computation","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Interactive computation","text":"","category":"section"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"Let's say you have been cautious and did not launch a deep bifurcation diagram computation by using a small recursion level 2:","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"diagram = bifurcationdiagram(jet...,\n\tsol0, par_mit, (@lens _.λ), \n\t# here the recursion level is\n\t2,\n\toptionsCont;\n\tverbosity = 0, plot = true,\n\trecordFromSolution = (x, p) -> (n2 = norm2(x), nw = normbratu(x), n∞ = norminf(x)),\n\tcallbackN = cb,\n\ttangentAlgo = BorderedPred(),\n\tusedeflation = true,\n\tfinaliseSolution = finSol,\n\tplotSolution = (x, p; kwargs...) -> plotsol!(x ; kwargs...),\n\tnormC = norminf)","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"You would end up with this diagram ","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"(Image: )","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"How can we complete this diagram without recomputing it from scratch? It is easy! For example, let us complete the magenta branches as follow","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"bifurcationdiagram!(jet...,\n\t# this improves the first branch on the violet curve. Note that\n\t# for symmetry reasons, the first bifurcation point\n\t# has 8 branches\n\tgetBranch(diagram, (1,)), (current = 3, maxlevel = 6), optionsCont;\n\tverbosity = 0, plot = true,\n\trecordFromSolution = (x, p) -> (n2 = norm2(x), nw = normbratu(x), n∞ = norminf(x)),\n\tcallbackN = cb,\n\tfinaliseSolution = finSol,\n\tusedeflation = true,\n\tplotSolution = (x, p; kwargs...) -> plotsol!(x ; kwargs...),\n\tnormC = norminf)","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"This gives the following diagram. Using this call, you can pinpoint the particular location where to refine the diagram.","category":"page"},{"location":"mittelmannAuto/","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"(Image: )","category":"page"},{"location":"tutorials3b/#d-Brusselator-(advanced-user)","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"","category":"section"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"Pages = [\"tutorials3b.md\"]\nDepth = 3","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"unknown: References\nThis example is taken from Numerical Bifurcation Analysis of Periodic Solutions of Partial Differential Equations, Lust, 1997.","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"info: Goal\nThe goal of this tutorial is to show similar computations as in the previous tutorial but without using the automatic branch switching tools. This is for the experienced used who wants to dive more in the internals of the package.    ","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"We look at the Brusselator in 1d. The equations are as follows","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"beginaligned frac  partial X   partial t   = frac  D _  1    l ^  2   frac  partial ^  2  X   partial z ^  2   + X ^  2  Y - ( β + 1 ) X + α  frac  partial Y   partial t   = frac  D _  2    l ^  2   frac  partial ^  2  Y   partial z ^  2   + β X - X ^  2  Y endaligned","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"with Dirichlet boundary conditions","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"beginarray  l   X ( t  z = 0 ) = X ( t  z = 1 ) = α    Y ( t  z = 0 ) = Y ( t  z = 1 ) = β  α  endarray","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"These equations have been introduced to reproduce an oscillating chemical reaction. There is an obvious equilibrium (α β  α). Here, we consider bifurcations with respect to the parameter l.","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"We start by writing the PDE","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"using Revise\nusing BifurcationKit, LinearAlgebra, Plots, SparseArrays, Setfield, Parameters\nconst BK = BifurcationKit\n\nf1(u, v) = u * u * v\nnorminf = x -> norm(x, Inf)\n\nfunction Fbru(x, p)\n\t@unpack α, β, D1, D2, l = p\n\tf = similar(x)\n\tn = div(length(x), 2)\n\th = 1.0 / n; h2 = h*h\n\tc1 = D1 / l^2 / h2\n\tc2 = D2 / l^2 / h2\n\n\tu = @view x[1:n]\n\tv = @view x[n+1:2n]\n\n\t# Dirichlet boundary conditions\n\tf[1]   = c1 * (α      - 2u[1] + u[2] ) + α - (β + 1) * u[1] + f1(u[1], v[1])\n\tf[end] = c2 * (v[n-1] - 2v[n] + β / α)\t\t\t + β * u[n] - f1(u[n], v[n])\n\n\tf[n]   = c1 * (u[n-1] - 2u[n] +  α  )  + α - (β + 1) * u[n] + f1(u[n], v[n])\n\tf[n+1] = c2 * (β / α  - 2v[1] + v[2])\t\t\t + β * u[1] - f1(u[1], v[1])\n\n\tfor i=2:n-1\n\t\t  f[i] = c1 * (u[i-1] - 2u[i] + u[i+1]) + α - (β + 1) * u[i] + f1(u[i], v[i])\n\t\tf[n+i] = c2 * (v[i-1] - 2v[i] + v[i+1])\t\t\t  + β * u[i] - f1(u[i], v[i])\n\tend\n\treturn f\nend","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"For computing periodic orbits, we will need a Sparse representation of the Jacobian:","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"function Jbru_sp(x, p)\n\t@unpack α, β, D1, D2, l = p\n\t# compute the Jacobian using a sparse representation\n\tn = div(length(x), 2)\n\th = 1.0 / n; h2 = h*h\n\n\tc1 = D1 / p.l^2 / h2\n\tc2 = D2 / p.l^2 / h2\n\n\tu = @view x[1:n]\n\tv = @view x[n+1:2n]\n\n\tdiag   = zeros(eltype(x), 2n)\n\tdiagp1 = zeros(eltype(x), 2n-1)\n\tdiagm1 = zeros(eltype(x), 2n-1)\n\n\tdiagpn = zeros(eltype(x), n)\n\tdiagmn = zeros(eltype(x), n)\n\n\t@. diagmn = β - 2 * u * v\n\t@. diagm1[1:n-1] = c1\n\t@. diagm1[n+1:end] = c2\n\n\t@. diag[1:n]    = -2c1 - (β + 1) + 2 * u * v\n\t@. diag[n+1:2n] = -2c2 - u * u\n\n\t@. diagp1[1:n-1] = c1\n\t@. diagp1[n+1:end] = c2\n\n\t@. diagpn = u * u\n\treturn spdiagm(0 => diag, 1 => diagp1, -1 => diagm1, n => diagpn, -n => diagmn)\nend","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"tip: Tip\nWe could have used DiffEqOperators.jl like for the Swift-Hohenberg tutorial.","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"We shall now compute the equilibria and their stability.","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"n = 500\n\n# parameters of the Brusselator model and guess for the stationary solution\npar_bru = (α = 2., β = 5.45, D1 = 0.008, D2 = 0.004, l = 0.3)\nsol0 = vcat(par_bru.α * ones(n), par_bru.β/par_bru.α * ones(n))","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"For the eigensolver, we use a Shift-Invert algorithm (see Eigen solvers (Eig))","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"eigls = EigArpack(1.1, :LM)","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"We continue the trivial equilibrium to find the Hopf points","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"opt_newton = NewtonPar(eigsolver = eigls, verbose = false)\nopts_br_eq = ContinuationPar(dsmin = 0.001, dsmax = 0.01, ds = 0.001,\n\tpMax = 1.9, detectBifurcation = 3, nev = 21, plotEveryStep = 50,\n\tnewtonOptions = NewtonPar(eigsolver = eigls, tol = 1e-9), maxSteps = 1060)\n\n\tbr, = @time continuation(Fbru, Jbru_sp, sol0, par_bru, (@lens _.l),\n\t\topts_br_eq, verbosity = 0,\n\t\tplot = true,\n\t\trecordFromSolution = (x,p) -> x[div(n,2)], normC = norminf)","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"We obtain the following bifurcation diagram with 3 Hopf bifurcation points","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"(Image: )","category":"page"},{"location":"tutorials3b/#Normal-form-computation","page":"1d Brusselator (advanced user)","title":"Normal form computation","text":"","category":"section"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"We can compute the normal form of the Hopf points as follows","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"using ForwardDiff\nfunction D(f, x, p, dx)\n\treturn ForwardDiff.derivative(t->f(x .+ t .* dx, p), 0.)\nend\nd1Fbru(x,p,dx1) = D((z, p0) -> Fbru(z, p0), x, p, dx1)\nd2Fbru(x,p,dx1,dx2) = D((z, p0) -> d1Fbru(z, p0, dx1), x, p, dx2)\nd3Fbru(x,p,dx1,dx2,dx3) = D((z, p0) -> d2Fbru(z, p0, dx1, dx2), x, p, dx3)\n\n# we group the differentials together\njet  = (Fbru, Jbru_sp, d2Fbru, d3Fbru)\n\nhopfpt = computeNormalForm(jet..., br, 1)","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"and you should get","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"julia> hopfpt\nSuperCritical - Hopf bifurcation point at l ≈ 0.512353005225085.\nPeriod of the periodic orbit ≈ 2.9370202332411925\nNormal form z⋅(a⋅δp + b⋅|z|²): \n(a = 0.8770732861140638 + 0.5671547647542317im, b = -0.0009380187660555578 + 0.0009391565464102912im)","category":"page"},{"location":"tutorials3b/#Continuation-of-Hopf-points","page":"1d Brusselator (advanced user)","title":"Continuation of Hopf points","text":"","category":"section"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"We use the bifurcation points guesses located in br.specialpoint to turn them into precise bifurcation points. For the second one, we have","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"# index of the Hopf point in br.specialpoint\nind_hopf = 2\nhopfpoint, _, flag = @time newton(Fbru, Jbru_sp,\n\tbr, ind_hopf; normN = norminf)\nflag && printstyled(color=:red, \"--> We found a Hopf Point at l = \", hopfpoint.p[1], \", ω = \", hopfpoint.p[2], \", from l = \", br.specialpoint[ind_hopf].param, \"\\n\")","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"which produces","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"--> We found a Hopf Point at l = 1.0239851696548035, ω = 2.1395092895339842, from l = 1.0353910524340078","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"We now perform a Hopf continuation with respect to the parameters l, β","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"tip: Tip\nYou don't need to call newton first in order to use continuation.","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"optcdim2 = ContinuationPar(dsmin = 0.001, dsmax = 0.05, ds= 0.01, pMax = 6.5, pMin = 0.0, newtonOptions = opt_newton)\nbr_hopf, = @time continuation(Fbru, Jbru_sp,\n\tbr, ind_hopf, (@lens _.β),\n\toptcdim2, verbosity = 2, \n\tnormC = norminf)","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"which gives using plot(br_hopf)","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"(Image: )","category":"page"},{"location":"tutorials3b/#Continuation-of-periodic-orbits-(Finite-differences)","page":"1d Brusselator (advanced user)","title":"Continuation of periodic orbits (Finite differences)","text":"","category":"section"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"Here, we perform continuation of periodic orbits branching from the Hopf bifurcation points.We need an educated guess for the periodic orbit which is given by guessFromHopf:","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"# number of time slices\nM = 51\n\nl_hopf, Th, orbitguess2, hopfpt, vec_hopf = guessFromHopf(br, ind_hopf,\n\topts_br_eq.newtonOptions.eigsolver,\n\tM, 2.7; phase = 0.25)","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"We wish to make two remarks at this point. The first is that an initial guess is composed of a space time solution and of the guess for the period Th of the solution. Note that the argument 2.7 is a guess for the amplitude of the orbit.","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"# orbit initial guess from guessFromHopf, is not a vector, so we reshape it\norbitguess_f2 = reduce(vcat, orbitguess2)\norbitguess_f = vcat(vec(orbitguess_f2), Th) |> vec","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"The second remark concerns the phase 0.25 written above. To account for the additional unknown (i.e. the period), periodic orbit localisation using Finite Differences requires an additional constraint (see Periodic orbits based on trapezoidal rule for more details). In the present case, this constraint is","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":" u(0) - u_hopf phi = 0","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"where u_{hopf} is the equilibrium at the Hopf bifurcation and phi is real.(vec_hopf) where vec_hopf is the eigenvector. This is akin to a Poincaré section. We do not put any constraint on u(t) albeit this is possible (see Periodic orbits based on trapezoidal rule.","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"The phase of the periodic orbit is set so that the above constraint is satisfied. We shall now use Newton iterations to find a periodic orbit.","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"Given our initial guess, we create a (family of) problem which encodes the functional associated to finding Periodic orbits based on trapezoidal rule (see Periodic orbits based on trapezoidal rule for more information):","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"poTrap = PeriodicOrbitTrapProblem(\n\tFbru,    \t\t\t\t# pass the vector field\n\tJbru_sp, \t\t\t\t# pass the jacobian of the vector field\n\treal.(vec_hopf),\t\t# used to set ϕ, see the phase constraint\n\thopfpt.u,           # used to set uhopf, see the phase constraint\n\tM, 2n)\t\t\t          # number of time slices","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"To evaluate the functional at x, you call it like a function: poTrap(x, par) for the parameter par.","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"note: Using the functional for deflation, Fold of limit cycles...\nThe functional poTrap gives you access to the underlying methods to call a regular newton. For example the functional is x -> poTrap(x, par) at parameter par. The (sparse) Jacobian at (x,p) is computed like this poTrap(Val(:JacFullSparse), x, p) while the Matrix Free version is dx -> poTrap((x, p, dx). This also allows you to call the newton deflated method (see Deflated problems) or to locate Fold point of limit cycles see PeriodicOrbitTrapProblem. You can also use preconditioners. In the case of more computationally intense problems (like the 2d Brusselator), this might be mandatory as using LU decomposition for the linear solve will use too much memory. See also the example 2d Ginzburg-Landau equation (finite differences)","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"For convenience, we provide a simplified newton / continuation methods for periodic orbits. One has just to pass a PeriodicOrbitTrapProblem.","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"# we use the linear solver LSFromBLS to speed up the computations\nopt_po = NewtonPar(tol = 1e-10, verbose = true, maxIter = 14, linsolver = BK.LSFromBLS())\n\toutpo_f, _, flag = @time newton(poTrap, orbitguess_f, (@set par_bru.l = l_hopf + 0.01), \t\topt_po, normN = norminf,\n\t\tlinearPO = :FullSparseInplace,\n\t\tcallback = (x, f, J, res, itlin, iteration, options; kwargs...) -> (println(\"--> amplitude = \", BK.amplitude(x, n, M; ratio = 2));true))\nflag && printstyled(color=:red, \"--> T = \", outpo_f[end], \", amplitude = \", BK.amplitude(outpo_f, n, M; ratio = 2),\"\\n\")\n# plot of the periodic orbit\nBK.plotPeriodicPOTrap(outpo_f, n, M; ratio = 2)","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"and obtain","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"Newton Iterations      f(x)      Linear Iterations\n\n          0          1.5184e-03             0\n--> amplitude = 0.22182446481949203\n          1          3.2748e-03             2\n--> amplitude = 0.5042141710317618\n          2          4.4409e-04             2\n--> amplitude = 0.41320367911246847\n          3          8.5523e-05             2\n--> amplitude = 0.36741372418160223\n          4          4.9208e-06             2\n--> amplitude = 0.3560261988596807\n          5          1.6632e-08             2\n--> amplitude = 0.35535508808242433\n          6          2.4921e-13             2\n--> amplitude = 0.3553527952167588\n--> amplitude = 0.3553527952167588\n  4.384568 seconds (868.10 k allocations: 2.456 GiB, 10.67% gc time)","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"and","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"(Image: )","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"Finally, we can perform continuation of this periodic orbit using the specialized call continuationPOTrap","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"opt_po = @set opt_po.eigsolver = EigArpack(; tol = 1e-5, v0 = rand(2n))\nopts_po_cont = ContinuationPar(dsmin = 0.001, dsmax = 0.03, ds= 0.01,\n\tpMax = 3.0, maxSteps = 30,\n\tnewtonOptions = opt_po, nev = 5, precisionStability = 1e-8, detectBifurcation = 0)\nbr_po, = @time continuation(poTrap,\n\toutpo_f, (@set par_bru.l = l_hopf + 0.01), (@lens _.l),\n\topts_po_cont;\n\tlinearPO = :FullSparseInplace,\n\tverbosity = 2,\tplot = true,\n\tplotSolution = (x, p;kwargs...) -> heatmap!(reshape(x[1:end-1], 2*n, M)'; ylabel=\"time\", color=:viridis, kwargs...),\n\tnormC = norminf)","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"to obtain the period of the orbit as function of l","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"(Image: )","category":"page"},{"location":"tutorials3b/#Deflation-for-periodic-orbit-problems","page":"1d Brusselator (advanced user)","title":"Deflation for periodic orbit problems","text":"","category":"section"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"Looking for periodic orbits branching of bifurcation points, it is very useful to use newton algorithm with deflation. We thus define a deflation operator (see previous example)","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"deflationOp = DeflationOperator(2.0, (x,y) -> dot(x[1:end-1], y[1:end-1]),1.0, [zero(orbitguess_f)])","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"which allows to find periodic orbits different from orbitguess_f. Note that the dot product removes the last component, i.e. the period of the cycle is not considered during this particular deflation. We can now use","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"outpo_f, hist, flag = @time newton(poTrap,\n\torbitguess_f, (@set par_bru.l = l_hopf + 0.01), opt_po, deflationOp; linearPO = :FullSparseInplace, normN = norminf)","category":"page"},{"location":"tutorials3b/#Floquet-coefficients","page":"1d Brusselator (advanced user)","title":"Floquet coefficients","text":"","category":"section"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"A basic method for computing Floquet cofficients based on the eigenvalues of the monodromy operator is available (see FloquetQaD). It is precise enough to locate bifurcations. Their computation is triggered like in the case of a regular call to continuation:","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"opt_po = @set opt_po.eigsolver = DefaultEig()\nopts_po_cont = ContinuationPar(dsmin = 0.001, dsmax = 0.04, ds= -0.01, pMax = 3.0, maxSteps = 200, saveSolEveryStep = 1, newtonOptions = opt_po, nev = 5, precisionStability = 1e-6, detectBifurcation = 3)\nbr_po, = @time continuation(poTrap,\n\toutpo_f, (@set par_bru.l = l_hopf + 0.01), (@lens _.l),\n\topts_po_cont; verbosity = 3, plot = true,\n\tlinearPO = :FullSparseInplace,\n\tplotSolution = (x, p;kwargs...) -> heatmap!(reshape(x[1:end-1], 2*n, M)'; ylabel=\"time\", color=:viridis, kwargs...), normC = norminf)","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"A more complete diagram can be obtained combining the methods (essentially deflation and Floquet) described above. It shows the period of the periodic orbits as function of l. See example/brusselator.jl for more information.","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"(Image: )","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"danger: Floquet multipliers computation\nThe computation of Floquet multipliers is necessary for the detection of bifurcations of periodic orbits (which is done by analyzing the Floquet exponents obtained from the Floquet multipliers). Hence, the eigensolver needs to compute the eigenvalues with largest modulus (and not with largest real part which is their default behavior). This can be done by changing the option which = :LM of the eigensolver. Nevertheless, note that for most implemented eigensolvers in the current Package, the proper option is set when the computation of Floquet multipliers is requested.","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"tip: Performances\nThis example is clearly not optimized because we wanted to keep it simple. We can use a Matrix-Free version of the functional and preconditioners to speed this up. Floquet multipliers could also be computed in a Matrix-Free manner. See examples/brusselator.jl for more efficient methods. See also 2d Ginzburg-Landau equation (finite differences) for a more advanced example where we introduce those methods.","category":"page"},{"location":"tutorials3b/#Continuation-of-periodic-orbits-(Standard-Shooting)","page":"1d Brusselator (advanced user)","title":"Continuation of periodic orbits (Standard Shooting)","text":"","category":"section"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"Note that what follows is not really optimized on the DifferentialEquations.jl side. Indeed, we do not use automatic differentiation, we do not pass the sparsity pattern,...","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"We now turn to a different method based on the flow of the Brusselator. To compute this flow (time stepper), we need to be able to solve the differential equation (actually a PDE) associated to the vector field Fbru. We will show how to do this with an implicit method Rodas4P from DifferentialEquations.jl. Note that the user can pass its own time stepper but for convenience, we use the ones in DifferentialEquations.jl. More information regarding the shooting method is contained in Periodic orbits based on the shooting method. To define the flow, it is better to have an inplace version of the vector field:","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"function Fbru!(f, x, p)\n\t@unpack α, β, D1, D2, l = p\n\tn = div(length(x), 2)\n\th = 1.0 / n; h2 = h*h\n\tc1 = D1 / l^2 / h2\n\tc2 = D2 / l^2 / h2\n\n\tu = @view x[1:n]\n\tv = @view x[n+1:2n]\n\n\t# Dirichlet boundary conditions\n\tf[1]   = c1 * (α\t  - 2u[1] + u[2] ) + α - (β + 1) * u[1] + f1(u[1], v[1])\n\tf[end] = c2 * (v[n-1] - 2v[n] + β / α)\t\t\t + β * u[n] - f1(u[n], v[n])\n\n\tf[n]   = c1 * (u[n-1] - 2u[n] +  α   ) + α - (β + 1) * u[n] + f1(u[n], v[n])\n\tf[n+1] = c2 * (β / α  - 2v[1] + v[2])\t\t\t + β * u[1] - f1(u[1], v[1])\n\n\tfor i=2:n-1\n\t\t  f[i] = c1 * (u[i-1] - 2u[i] + u[i+1]) + α - (β + 1) * u[i] + f1(u[i], v[i])\n\t\tf[n+i] = c2 * (v[i-1] - 2v[i] + v[i+1])\t\t\t  + β * u[i] - f1(u[i], v[i])\n\tend\n\treturn f\nend\n\nfunction Fbru(x, p)\n\tf = similar(x)\n\tFbru!(f, x, p)\nend","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"We then recompute the locus of the Hopf bifurcation points using the same method as above.","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"n = 100\n\n# different parameters to define the Brusselator model and guess for the stationary solution\npar_bru = (α = 2., β = 5.45, D1 = 0.008, D2 = 0.004, l = 0.3)\nsol0 = vcat(par_bru.α * ones(n), par_bru.β/par_bru.α * ones(n))\n\neigls = EigArpack(1.1, :LM)\nopts_br_eq = ContinuationPar(dsmin = 0.001, dsmax = 0.00615, ds = 0.0061, pMax = 1.9,\n\tdetectBifurcation = 3, nev = 21, plotEveryStep = 50,\n\tnewtonOptions = NewtonPar(eigsolver = eigls, tol = 1e-9), maxSteps = 1060)\n\nbr, = @time continuation(Fbru, Jbru_sp,\n\tsol0, par_bru, (@lens _.l), opts_br_eq, verbosity = 0,\n\tplot = false,\n\trecordFromSolution = (x, p)->x[div(n,2)], normC = norminf)","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"We need to create a guess for the periodic orbit. We proceed as previously:","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"# number of time slices\nM = 10\n\n# index of the Hopf point in the branch br\nind_hopf = 1\n\nl_hopf, Th, orbitguess2, hopfpt, vec_hopf = BK.guessFromHopf(br, ind_hopf,\n\topts_br_eq.newtonOptions.eigsolver, M, 22*0.075)\n#\norbitguess_f2 = reduce(hcat, orbitguess2)\norbitguess_f = vcat(vec(orbitguess_f2), Th) |> vec","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"Let us now initiate the Standard Shooting method. To this aim, we need to provide a guess of the periodic orbit at times TM_sh where T is the period of the cycle and M_sh is the number of slices along the periodic orbits. If M_sh = 1, this the Standard Simple Shooting and the Standard Multiple one otherwise. See ShootingProblem for more information.","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"dM = 3\norbitsection = Array(orbitguess_f2[:, 1:dM:M])\n\n# the last component is an estimate of the period of the cycle.\ninitpo = vcat(vec(orbitsection), 3.0)","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"Finally, we need to build a problem which encodes the Shooting functional. This done as follows where we first create the time stepper. For performance reasons, we rely on SparseDiffTools","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"using DifferentialEquations, DiffEqOperators, SparseDiffTools, SparseArrays, DiffEqDiffTools\n\nFOde(f, x, p, t) = Fbru!(f, x, p)\n\nu0 = sol0 .+ 0.01 .* rand(2n)\n\n# parameter close to the Hopf bifurcation point\npar_hopf = (@set par_bru.l = l_hopf + 0.01)\n\njac_prototype = Jbru_sp(ones(2n), @set par_bru.β = 0)\njac_prototype.nzval .= ones(length(jac_prototype.nzval))\n_colors = matrix_colors(jac_prototype)\nvf = ODEFunction(FOde; jac_prototype = jac_prototype, colorvec = _colors)\nprobsundials = ODEProblem(vf,  sol0, (0.0, 520.), par_bru)","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"We create the parallel standard shooting problem:","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"# this encodes the functional for the Shooting problem\nprobSh = ShootingProblem(\n\t# pass the vector field and parameter (to be passed to the vector field)\n\tFbru, par_hopf,\n\n\t# we pass the ODEProblem encoding the flow and the time stepper\n\tprobsundials, Rodas4P(),\n\n\t# this is for the phase condition, you can pass your own section as well\n\t[orbitguess_f2[:,ii] for ii=1:dM:M];\n\n\t# enable threading\n\tparallel = true,\n\n\t# these are options passed to the ODE time stepper\n\tatol = 1e-10, rtol = 1e-8)","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"We are now ready to call newton","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"ls = GMRESIterativeSolvers(reltol = 1e-7, N = length(initpo), maxiter = 100, verbose = false)\noptn_po = NewtonPar(verbose = true, tol = 1e-9,  maxIter = 20, linsolver = ls)\noutpo, = @time newton(probSh,\n\tinitpo, par_hopf, optn_po;\n\tnormN = norminf)\nplot(initpo[1:end-1], label = \"Init guess\")\nplot!(outpo[1:end-1], label = \"sol\")","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"which gives (note that we did not have a really nice guess...)","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"  Newton Iterations      f(x)      Linear Iterations\n\n          0          1.8260e-01             0\n          1          1.1913e-01            49\n          2          7.4174e-03            43\n          3          3.0445e-04            49\n          4          1.5705e-04            47\n          5          1.0346e-06            49\n          6          2.4545e-08            50\n          7          7.2087e-11            50\n  5.336648 seconds (2.73 M allocations: 4.784 GiB, 3.55% gc time)","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"and","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"(Image: )","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"Note that using Simple Shooting, the convergence is much faster. Indeed, running the code above with dM = 10 gives:","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"\n Newton Iterations      f(x)      Linear Iterations\n\n          0          8.1464e-03             0\n          1          2.9785e-03             6\n          2          4.7400e-03             6\n          3          2.7021e-03             7\n          4          1.6648e+00             8\n          5          3.1953e-01             5\n          6          1.8953e-01             5\n          7          4.0122e-02             6\n          8          1.0293e-02             7\n          9          2.7078e-03             7\n         10          4.6741e-04             7\n         11          1.9485e-05             7\n         12          1.2012e-07             7\n         13          4.2622e-09             8\n         14          7.3854e-12             8\n  0.901249 seconds (314.81 k allocations: 796.430 MiB, 2.70% gc time)","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"info: Convergence and speedup\nThe convergence is much worse for the multiple shooting than for the simple one. This is reflected above in the number of linear iterations made during the newton solve. The reason for this is because of the cyclic structure of the jacobian which impedes GMRES from converging fast. This can only be resolved with an improved GMRES which we'll provide in the future.","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"Finally, we can perform continuation of this periodic orbit using a specialized version of continuation:","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"# note the eigensolver computes the eigenvalues of the monodromy matrix. Hence\n# the dimension of the state space for the eigensolver is 2n\nopts_po_cont = ContinuationPar(dsmin = 0.001, dsmax = 0.05, ds= 0.01, pMax = 1.5,\n\tmaxSteps = 500, newtonOptions = (@set optn_po.tol = 1e-7), nev = 25,\n\tprecisionStability = 1e-8, detectBifurcation = 0)\n\nbr_po, = @time continuation(probSh,\toutpo, par_hopf, (@lens _.l),\n\topts_po_cont; verbosity = 2,\n\t# specific bordered linear solver\n\tlinearAlgo = MatrixFreeBLS(@set ls.N = ls.N+1),\n\tplot = true,\n\tplotSolution = (x, p; kwargs...) -> BK.plotPeriodicShooting!(x[1:end-1], length(1:dM:M); kwargs...),\n\trecordFromSolution = (u, p) -> u[end], normC = norminf)","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"We can observe that simple shooting is faster but the Floquet multipliers are less accurate than for multiple shooting. Also, when the solution is very unstable, simple shooting can have spurious branch switching. Finally, note the 0=log 1 eigenvalue of the monodromy matrix in the graph below.","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"(Image: )","category":"page"},{"location":"tutorials3b/#Continuation-of-periodic-orbits-(Poincaré-Shooting)","page":"1d Brusselator (advanced user)","title":"Continuation of periodic orbits (Poincaré Shooting)","text":"","category":"section"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"We now turn to another Shooting method, namely the Poincaré one. We can provide this method thanks to the unique functionalities of DifferentialEquations.jl. More information is provided at PoincareShootingProblem and Periodic orbits based on the shooting method but basically, it is a shooting method between Poincaré sections Sigma_i (along the orbit) defined by hyperplanes. As a consequence, the dimension of the unknowns is M_shcdot(N-1) where N is the dimension of the phase space. Indeed, each time slice lives in an hyperplane Sigma_i. Additionally, the period T is not an unknown of the method but rather a by-product. However, the method requires the time stepper to find when the flow hits an hyperplane Sigma_i, something called event detection.","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"We show how to use this method, the code is very similar to the case of the Standard Shooting. We first define the functional for Poincaré Shooting Problem","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"# sub-sampling factor of a initial guess for the periodic orbit\ndM = 5\n\n# vectors to define the hyperplanes Sigma_i\nnormals = [Fbru(orbitguess_f2[:,ii], par_hopf)/(norm(Fbru(orbitguess_f2[:,ii], par_hopf))) for ii = 1:dM:M]\ncenters = [orbitguess_f2[:,ii] for ii = 1:dM:M]\n\n# functional to hold the Poincare Shooting Problem\nprobHPsh = PoincareShootingProblem(\n\t# vector field and parameter\n\tFbru, par_hopf,\n\n\t# ODEProblem, ODE solver used to compute the flow\n\tprobsundials, Rodas4P(),\n\n\t# parameters for the Poincaré sections\n\tnormals, centers;\n\n\t# enable threading\n\tparallel = true,\n\n\t# Parameters passed to the ODE solver\n\tatol = 1e-10, rtol = 1e-8)","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"Let us now compute an initial guess for the periodic orbit, it must live in the hyperplanes Sigma_i. Fortunately, we provide projections on these hyperplanes.","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"# projection of the initial guess on the hyperplanes. We assume that the centers[ii]\n# form the periodic orbit initial guess.\ninitpo_bar = reduce(vcat, BK.projection(probHPsh, centers))","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"We can now call continuation to get the first branch.","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"# eigen / linear solver\neig = EigKrylovKit(tol= 1e-12, x₀ = rand(2n-1), verbose = 0, dim = 40)\nls = GMRESIterativeSolvers(reltol = 1e-11, N = length(vec(initpo_bar)), maxiter = 500, verbose = false)\n\n# newton options\noptn = NewtonPar(verbose = true, tol = 1e-9,  maxIter = 140, linsolver = ls)\n\n# continuation options\nopts_po_cont_floquet = ContinuationPar(dsmin = 0.0001, dsmax = 0.05, ds= 0.001,\n\tpMax = 2.5, maxSteps = 500, nev = 10,\n\tprecisionStability = 1e-5, detectBifurcation = 3, plotEveryStep = 3)\nopts_po_cont_floquet = @set opts_po_cont_floquet.newtonOptions =\n\tNewtonPar(linsolver = ls, eigsolver = eig, tol = 1e-9, verbose = true)\n\n# continuation run\nbr_po, = @time BK.continuation(probHPsh,\n\tvec(initpo_bar), par_hopf, (@lens _.l),\n\topts_po_cont_floquet; verbosity = 3,\n\tlinearAlgo = MatrixFreeBLS(@set ls.N = ls.N+1),\n\tplot = true,\n\tplotSolution = (x, p; kwargs...) -> BK.plot!(x; label=\"\", kwargs...),\n\tnormC = norminf)\t\t","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"(Image: )","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"We also obtain the following information:","category":"page"},{"location":"tutorials3b/","page":"1d Brusselator (advanced user)","title":"1d Brusselator (advanced user)","text":"julia> br_po\nBranch number of points: 41\nBifurcation points:\n- #  1,    bp at p ≈ 1.20987963 ∈ (1.20128196, 1.20987963), |δp|=9e-03, [converged], δ = ( 1,  0), step =  21, eigenelements in eig[ 22], ind_ev =   1\n- #  2,    ns at p ≈ 1.78687615 ∈ (1.77831727, 1.78687615), |δp|=9e-03, [converged], δ = ( 2,  2), step =  30, eigenelements in eig[ 31], ind_ev =   3\n- #  3,    pd at p ≈ 1.85103701 ∈ (1.84676466, 1.85103701), |δp|=4e-03, [converged], δ = ( 1,  1), step =  31, eigenelements in eig[ 32], ind_ev =   4\n- #  4,    ns at p ≈ 1.87667870 ∈ (1.86813520, 1.87667870), |δp|=9e-03, [converged], δ = ( 2,  2), step =  32, eigenelements in eig[ 33], ind_ev =   6\n","category":"page"},{"location":"tutorialCO/#CO-oxydation-(codim-2)","page":"CO-oxydation (codim 2)","title":"CO-oxydation (codim 2)","text":"","category":"section"},{"location":"tutorialCO/","page":"CO-oxydation (codim 2)","title":"CO-oxydation (codim 2)","text":"Pages = [\"tutorialCO.md\"]\nDepth = 3","category":"page"},{"location":"tutorialCO/","page":"CO-oxydation (codim 2)","title":"CO-oxydation (codim 2)","text":"In this tutorial, we study the Bykov–Yablonskii–Kim model of CO-oxydation (see [Govaerts]). The goal of the tutorial is to show in a simple example how to perform codimension 2 bifurcation detection.","category":"page"},{"location":"tutorialCO/","page":"CO-oxydation (codim 2)","title":"CO-oxydation (codim 2)","text":"leftbeginarrayldotx=2 q_1 z^2-2 q_5 x^2-q_3 x y  doty=q_2 z-q_6 y-q_3 x y  dots=q_4 z-k q_4 sendarrayrighttagE","category":"page"},{"location":"tutorialCO/","page":"CO-oxydation (codim 2)","title":"CO-oxydation (codim 2)","text":"Where z=1-x-y-s.","category":"page"},{"location":"tutorialCO/","page":"CO-oxydation (codim 2)","title":"CO-oxydation (codim 2)","text":"We start with some imports that are useful in the following.","category":"page"},{"location":"tutorialCO/","page":"CO-oxydation (codim 2)","title":"CO-oxydation (codim 2)","text":"using Revise, ForwardDiff, Parameters, Setfield, Plots, LinearAlgebra\nusing BifurcationKit\nconst BK = BifurcationKit\n\n# define the sup norm\nnorminf = x -> norm(x, Inf)\nnothing # hide","category":"page"},{"location":"tutorialCO/#Problem-setting","page":"CO-oxydation (codim 2)","title":"Problem setting","text":"","category":"section"},{"location":"tutorialCO/","page":"CO-oxydation (codim 2)","title":"CO-oxydation (codim 2)","text":"We can now encode the vector field (E) in a function and use automatic differentiation to compute its various derivatives.","category":"page"},{"location":"tutorialCO/","page":"CO-oxydation (codim 2)","title":"CO-oxydation (codim 2)","text":"# vector field of the problem\nfunction COm(u, p)\n\t@unpack q1,q2,q3,q4,q5,q6,k = p\n\tx, y, s = u\n\tz = 1-x-y-s\n\tout = similar(u)\n\tout[1] = 2q1 * z^2 - 2q5 * x^2 - q3 * x * y\n\tout[2] = q2 * z - q6 * y - q3 * x * y\n\tout[3] = q4 * z - k * q4 * s\n\tout\nend\n\n# jacobian\ndCOm = (z, p) -> ForwardDiff.jacobian(x -> COm(x, p), z)\n\n# we group the differentials together\njet = BK.getJet(COm, dCOm)\n\n# parameters used in the model\npar_com = (q1 = 2.5, q2 = 0.6, q3 = 10., q4 = 0.0675, q5 = 1., q6 = 0.1, k = 0.4)\n\n# initial condition\nz0 = [0.07,0.2,05]\nnothing # hide","category":"page"},{"location":"tutorialCO/#Continuation-and-codim-1-bifurcations","page":"CO-oxydation (codim 2)","title":"Continuation and codim 1 bifurcations","text":"","category":"section"},{"location":"tutorialCO/","page":"CO-oxydation (codim 2)","title":"CO-oxydation (codim 2)","text":"Once the problem is set up, we can continue the state w.r.t. q_2 to and detect codim 1 bifurcations. This is achieved as follows:","category":"page"},{"location":"tutorialCO/","page":"CO-oxydation (codim 2)","title":"CO-oxydation (codim 2)","text":"# continuation parameters\nopts_br = ContinuationPar(pMin = 0.6, pMax = 1.9, ds = 0.002, dsmax = 0.01,\n\t# options to detect codim 1 bifurcations using bisection \n\tdetectBifurcation = 3,\n\t# Optional: bisection options for locating bifurcations\n\tnInversion = 6, maxBisectionSteps = 25, \n\t# number of eigenvalues\n\tnev = 3)\n\t\n# compute the branch of solutions\t\nbr, = continuation(jet[1], jet[2], z0, par_com, (@lens _.q2), opts_br;\n\trecordFromSolution = (x, p) -> (x = x[1], y = x[2]),\n\tplot = true, verbosity = 3, normC = norminf)\n\t\n# plot the branch\nscene = plot(br, xlims=(0.8,1.8))","category":"page"},{"location":"tutorialCO/#Continuation-of-Fold-points","page":"CO-oxydation (codim 2)","title":"Continuation of Fold points","text":"","category":"section"},{"location":"tutorialCO/","page":"CO-oxydation (codim 2)","title":"CO-oxydation (codim 2)","text":"We follow the Fold points in the parameter plane (q_2 k). We tell the solver to consider br.specialpoint[2] and continue it. ","category":"page"},{"location":"tutorialCO/","page":"CO-oxydation (codim 2)","title":"CO-oxydation (codim 2)","text":"sn_codim2, = continuation(jet[1:2]..., br, 2, (@lens _.k),\n\tContinuationPar(opts_br, pMax = 2.2, pMin = 0., ds = -0.001, dsmax = 0.05);\n\tnormC = norminf,\n\t# detection of codim 2 bifurcations with bisection\n\tdetectCodim2Bifurcation = 2,\n\t# we save the first component for plotting\n\trecordFromSolution = (u,p; kw...) -> (x = u.u[1] ),\n\t# we update the Fold problem at every continuation step\n\tupdateMinAugEveryStep = 1,\n\t# compute both sides of the initial condition\n\tbothside=true,\n\t# use this linear bordered solver, better for ODEs\n\tbdlinsolver = MatrixBLS())\n\t\nscene = plot(sn_codim2, vars=(:q2, :x), branchlabel = \"Fold\")\nplot!(scene, br, xlims=(0.8,1.8))","category":"page"},{"location":"tutorialCO/#Continuation-of-Hopf-points","page":"CO-oxydation (codim 2)","title":"Continuation of Hopf points","text":"","category":"section"},{"location":"tutorialCO/","page":"CO-oxydation (codim 2)","title":"CO-oxydation (codim 2)","text":"We tell the solver to consider br.bifpint[1] and continue it. ","category":"page"},{"location":"tutorialCO/","page":"CO-oxydation (codim 2)","title":"CO-oxydation (codim 2)","text":"hp_codim2, = continuation(jet[1:2]..., br, 1, (@lens _.k), \n\tContinuationPar(opts_br, pMin = 0., pMax = 2.8, \n\t\tds = -0.001, dsmax = 0.05) ;\n\tnormC = norminf,\n\t# detection of codim 2 bifurcations with bisection\n\tdetectCodim2Bifurcation = 2,\n\t# this is required to detect the bifurcations\n\td2F = jet[3], d3F = jet[4],\n\t# tell to start the Hopf problem using eigen elements: compute left eigenvector\n\tstartWithEigen = true,\n\t# we save the first component for plotting\n\trecordFromSolution = (u,p; kw...) -> (x = u.u[1] ),\n\t# we update the Hopf problem at every continuation step\n\tupdateMinAugEveryStep = 1,\n\t# compute both sides of the initial condition\n\tbothside = true,\n\t# use this linear bordered solver, better for ODEs\n\tbdlinsolver = MatrixBLS(),\n\t)\n\t\n# plotting\nscene = plot(sn_codim2, vars=(:q2, :x), branchlabel = \"Fold\")\nplot!(scene, hp_codim2, vars=(:q2, :x), branchlabel = \"Hopf\")\nplot!(scene, br, xlims=(0.6,1.5))","category":"page"},{"location":"tutorialCO/","page":"CO-oxydation (codim 2)","title":"CO-oxydation (codim 2)","text":"(Image: )","category":"page"},{"location":"tutorialCO/#References","page":"CO-oxydation (codim 2)","title":"References","text":"","category":"section"},{"location":"tutorialCO/","page":"CO-oxydation (codim 2)","title":"CO-oxydation (codim 2)","text":"[Govaerts]: Govaerts, Willy J. F. Numerical Methods for Bifurcations of Dynamical Equilibria. Philadelphia, Pa: Society for Industrial and Applied Mathematics, 2000.","category":"page"},{"location":"BrusselatorFF/#Brusselator-1d-with-periodic-BC-using-FourierFlows.jl-(experienced-user)","page":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","title":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","text":"","category":"section"},{"location":"BrusselatorFF/","page":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","title":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","text":"Pages = [\"BrusselatorFF.md\"]\nDepth = 3","category":"page"},{"location":"BrusselatorFF/","page":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","title":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","text":"unknown: References\nThis example is taken from [Tzou].","category":"page"},{"location":"BrusselatorFF/","page":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","title":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","text":"info: Acknowledgment\nThe example was done in collaboration with Navid C. Constantinou.    ","category":"page"},{"location":"BrusselatorFF/","page":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","title":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","text":"We look at the Brusselator in 1d. The equations are as follows","category":"page"},{"location":"BrusselatorFF/","page":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","title":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","text":"beginaligned frac  partial u   partial t   = D frac  partial ^  2  u   partial z ^  2   + u ^  2  v - ( B + 1 ) u + E  frac  partial v   partial t   = frac  partial ^  2  v  partial z ^  2   + B u - u ^  2  v endalignedtagE","category":"page"},{"location":"BrusselatorFF/","page":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","title":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","text":"with periodic boundary conditions. These equations have been introduced to reproduce an oscillating chemical reaction.","category":"page"},{"location":"BrusselatorFF/","page":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","title":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","text":"We focus on computing a snaking branch of periodic orbits using spectral methods implemented in Brusselator.jl:","category":"page"},{"location":"BrusselatorFF/","page":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","title":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","text":"using Revise, BifurcationKit\nusing Brusselator, Plots, Parameters, ForwardDiff, LinearAlgebra, Setfield, DiffEqBase\nusing FFTW: irfft\nconst BK = BifurcationKit\n\ndev = CPU()\t\t\t\t\t# Device (CPU/GPU)\n\nnx      = 512\t\t\t\t# grid resolution\nstepper = \"FilteredRK4\"\t\t# timestepper\ndt  \t= 0.01\t\t# timestep\nnsteps  = 9000\t\t# total number of time-steps\nnsubs\t= 20\t\t# number of time-steps for intermediate logging/plotting (nsteps must be multiple of nsubs)\n\n# parameters for the model used by Tzou et al. (2013)\nE = 1.4\nL = 137.37\t\t\t\t # Domain length\nε = 0.1\nμ = 25\nρ = 0.178\n\nD_c = ((sqrt(1 + E^2) - 1) / E)^2\nB_H = (1 + E * sqrt(D_c))^2\n\nB = B_H + ε^2 * μ\nD = D_c + ε^2 * ρ\n\nkc = sqrt(E / sqrt(D))\n\n# building the model\ngrid = OneDGrid(dev, nx, L)\nparams = Brusselator.Params(B, D, E)\nvars = Brusselator.Vars(dev, grid)\nequation = Brusselator.Equation(dev, params, grid)\nprob = FourierFlows.Problem(equation, stepper, dt, grid, vars, params, dev)\n\nget_u(prob) = irfft(prob.sol[:, 1], prob.grid.nx)\nget_v(prob) = irfft(prob.sol[:, 2], prob.grid.nx)\nu_solution = Diagnostic(get_u, prob; nsteps=nsteps+1)\ndiags = [u_solution]","category":"page"},{"location":"BrusselatorFF/","page":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","title":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","text":"We now integrate the model to find a periodic orbit:","category":"page"},{"location":"BrusselatorFF/","page":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","title":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","text":"l = 28\nθ = @. (grid.x > -l/2) & (grid.x < l/2)\n\nau, av = -(E^2 + kc^2) / B, -1\ncu, cv = -E * (E + im) / B, 1\n\n# initial condition\nu0 = @.\t  E + ε * real( au * exp(im * kc * grid.x) * θ + cu * (1 - θ) )\nv0 = @. B/E + ε * real( av * exp(im * kc * grid.x) * θ + cv * (1 - θ) )\nset_uv!(prob, u0, v0)\n\nplot_output(prob)\n\n# move forward in time to capture the periodic orbit\nfor j=0:Int(nsteps/nsubs)\n\tupdatevars!(prob)\n\tstepforward!(prob, diags, nsubs)\nend\n\n# estimate of the periodic orbit, will be used as initial condition for a Krylov-Newton\ninitpo = copy(vcat(vcat(prob.vars.u, prob.vars.v), 4.9))\n\nusing RecursiveArrayTools\n\nt = u_solution.t[1:10:nsteps]\nU_xt = VectorOfArray([ u_solution.data[j] for j=1:10:nsteps ])\nheatmap(grid.x, t, U_xt', c = :viridis, clims = (1, 3))","category":"page"},{"location":"BrusselatorFF/","page":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","title":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","text":"which gives","category":"page"},{"location":"BrusselatorFF/","page":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","title":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","text":"(Image: )","category":"page"},{"location":"BrusselatorFF/#Building-the-Shooting-problem","page":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","title":"Building the Shooting problem","text":"","category":"section"},{"location":"BrusselatorFF/","page":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","title":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","text":"We compute the periodic solution of (E) with a shooting algorithm. We thus define a function to compute the flow and its differential.","category":"page"},{"location":"BrusselatorFF/","page":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","title":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","text":"# update the states\nfunction _update!(out, pb::FourierFlows.Problem, N)\n\tout[1:N] .= pb.vars.u\n\tout[N+1:end] .= pb.vars.v\n\tout\nend\n\n# update the parameters in pb\nfunction _setD!(D, pb::FourierFlows.Problem)\n\tpb.eqn.L[:, 1] .*= D / prob.params.D\n\tpb.params.D = D\nend\n\n# compute the flow from x up to time t\nfunction ϕ(x, p, t)\n\t@unpack pb, D, N = p\n\t_setD!(D, pb)\n\n\t# set initial condition\n\t@views set_uv!(pb, x[1:N], x[N+1:2N])\n\tpb.clock.t=0.; pb.clock.step=0\n\t# determine number of time steps\n\tdt = pb.clock.dt\n\tnsteps = div(t, dt) |> Int\n\t# compute flow\n\tstepforward!(pb, nsteps)\n\n\trest = t - nsteps * dt\n\tdt = pb.clock.dt\n\tpb.clock.dt = rest\n\tstepforward!(pb, 1)\n\tpb.clock.dt = dt\n\tupdatevars!(pb)\n\tout = similar(x)\n\t_update!(out, pb, N)\n\treturn out\nend\n\n# differential of the flow by FD\nfunction dϕ(x, p, dx, t; δ = 1e-8)\n\t\tphi = ϕ(x, p, t)\n\t\tdphi = (ϕ(x .+ δ .* dx, p, t) .- phi) ./ δ\n\t\treturn (t=t, u=phi, du=dphi)\nend","category":"page"},{"location":"BrusselatorFF/","page":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","title":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","text":"We also need the vector field","category":"page"},{"location":"BrusselatorFF/","page":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","title":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","text":"function vf(x, p)\n\t\t@unpack pb, D, N = p\n\t\t# set parameter in prob\n\t\tpb.eqn.L[:, 1] .*= D / pb.params.D\n\t\tpb.params.D = D\n\t\tu = @view x[1:N]\n\t\tv = @view x[N+1:end]\n\t\t# set initial condition\n\t\tset_uv!(pb, u, v)\n\t\trhs = Brusselator.get_righthandside(pb)\n\t\t# rhs is in Fourier space, put back to real space\n\t\tout = similar(x)\n\t\tldiv!((@view out[1:N]), pb.grid.rfftplan, rhs[:, 1])\n\t\tldiv!((@view out[N+1:end]), pb.grid.rfftplan, rhs[:, 2])\n\t\treturn out\nend","category":"page"},{"location":"BrusselatorFF/","page":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","title":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","text":"We then specify the shooting problem","category":"page"},{"location":"BrusselatorFF/","page":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","title":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","text":"# parameters to be passed to ϕ\npar_bru = (pb = prob, N = nx, nsubs = nsubs, D = D)\n\n# example of vector passed to ϕ\nx0 = vcat(u0,v0)\n\n# here we define the problem which encodes the standard shooting\nflow = Flow(vf, ϕ, dϕ)\n\n# the first section is centered around a stationary state\n_center = vcat(E*ones(nx), B/E*ones(nx))\n\n# section for the flow\nsectionBru = BK.SectionSS(vf(initpo[1:end-1], par_bru), _center)\nprobSh = ShootingProblem(M = 1, flow = flow, ds = diff(LinRange(0, 1, 1 + 1)), section = sectionBru)","category":"page"},{"location":"BrusselatorFF/#Finding-a-periodic-orbit","page":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","title":"Finding a periodic orbit","text":"","category":"section"},{"location":"BrusselatorFF/","page":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","title":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","text":"# linear solver for the Shooting problem\nls = GMRESIterativeSolvers(N = 2nx+1)\n\n# parameters for Krylov-Newton\noptn = NewtonPar(tol = 1e-9, verbose = true,\n\t# linear solver\n\tlinsolver = ls,\n\t# eigen solver\n\teigsolver = EigKrylovKit(dim = 30, x₀ = rand(2nx), verbose = 1  )\n\t)\n\n# Newton-Krylov method to check convergence and tune parameters\nsolp, = @time newton(probSh, initpo, par_bru, optn,\n\tnormN = x->norm(x,Inf))","category":"page"},{"location":"BrusselatorFF/","page":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","title":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","text":"and you should see (the guess was not that good)","category":"page"},{"location":"BrusselatorFF/","page":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","title":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","text":"Newton Iterations      f(x)      Linear Iterations\n\n          0          1.6216e+03             0\n          1          4.4373e+01             6\n          2          9.0135e-01            15\n          3          4.9086e-02            32\n          4          4.1158e-03            27\n          5          6.0755e-03            33\n          6          2.4727e-04            33\n          7          3.7843e-05            34\n          8          1.9161e-07            31\n          9          4.3243e-09            40\n         10          2.3175e-13            27\n 83.615047 seconds (284.31 M allocations: 24.250 GiB, 6.28% gc time)","category":"page"},{"location":"BrusselatorFF/#Computation-of-the-snaking-branch","page":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","title":"Computation of the snaking branch","text":"","category":"section"},{"location":"BrusselatorFF/","page":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","title":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","text":"# you can detect bifurcations with the option detectBifurcation = 3\noptc = ContinuationPar(newtonOptions = optn, ds = -1e-3, dsmin = 1e-7, dsmax = 2e-3, pMax = 0.295, plotEveryStep = 2, maxSteps = 1000)\n\tbd, = continuation(probSh,\n\t\tsolp, par_bru, (@lens _.D), optc;\n\t\tlinearAlgo = MatrixFreeBLS(@set ls.N = 2nx+2),\n\t\tplot = true,\n\t\tverbosity = 3,\n\t\tplotSolution = (x,p ; kw...) -> plot!(x[1:nx];kw...),\n\t\tnormC = x->norm(x,Inf))","category":"page"},{"location":"BrusselatorFF/","page":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","title":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","text":"which leads to","category":"page"},{"location":"BrusselatorFF/","page":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","title":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","text":"(Image: )","category":"page"},{"location":"BrusselatorFF/#Reference(s)","page":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","title":"Reference(s)","text":"","category":"section"},{"location":"BrusselatorFF/","page":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","title":"Brusselator 1d with periodic BC using FourierFlows.jl (experienced user)","text":"[Tzou]: Tzou, J. C., Y.-P. Ma, A. Bayliss, B. J. Matkowsky, and V. A. Volpert. Homoclinic Snaking near a Codimension-Two Turing-Hopf Bifurcation Point in the Brusselator Model.” Physical Review E 87, no. 2 (February 14, 2013): 022908. https://doi.org/10.1103/PhysRevE.87.022908.","category":"page"},{"location":"ks1d/#d-Kuramoto–Sivashinsky-Equation","page":"1d Kuramoto–Sivashinsky Equation","title":"1d Kuramoto–Sivashinsky Equation","text":"","category":"section"},{"location":"ks1d/","page":"1d Kuramoto–Sivashinsky Equation","title":"1d Kuramoto–Sivashinsky Equation","text":"Pages = [\"ks1d.md\"]\nDepth = 3","category":"page"},{"location":"ks1d/","page":"1d Kuramoto–Sivashinsky Equation","title":"1d Kuramoto–Sivashinsky Equation","text":"warning: Warning\nThis is work in progress... In particular, there is a combinatorial explosion that I need to address.","category":"page"},{"location":"ks1d/","page":"1d Kuramoto–Sivashinsky Equation","title":"1d Kuramoto–Sivashinsky Equation","text":"unknown: References\nThe following example is exposed in Evstigneev, Nikolay M., and Oleg I. Ryabkov. Bifurcation Diagram of Stationary Solutions of the 2D Kuramoto-Sivashinsky Equation in Periodic Domains. Journal of Physics: Conference Series 1730, no. 1 2021","category":"page"},{"location":"ks1d/","page":"1d Kuramoto–Sivashinsky Equation","title":"1d Kuramoto–Sivashinsky Equation","text":"We study the 1d Kuramoto–Sivashinsky equation with Dirichlet boundary conditions:","category":"page"},{"location":"ks1d/","page":"1d Kuramoto–Sivashinsky Equation","title":"1d Kuramoto–Sivashinsky Equation","text":"left(2 u u+ uright)+2lambda u^(4)=0 u(0)=u(pi)=0","category":"page"},{"location":"ks1d/","page":"1d Kuramoto–Sivashinsky Equation","title":"1d Kuramoto–Sivashinsky Equation","text":"We discretize the problem by using u(x)=sum_k=1^infty u_k sin (k x) which gives","category":"page"},{"location":"ks1d/","page":"1d Kuramoto–Sivashinsky Equation","title":"1d Kuramoto–Sivashinsky Equation","text":"left(2lambda k^4-k^2right) u_k+frack2left(sum_l=1^infty u_k+l u_k-frac12 sum_l+m=k u_l u_mright)=0","category":"page"},{"location":"ks1d/","page":"1d Kuramoto–Sivashinsky Equation","title":"1d Kuramoto–Sivashinsky Equation","text":"This is a good example for the use of automatic bifurcation diagram as we shall see. Let us first encode our problem","category":"page"},{"location":"ks1d/","page":"1d Kuramoto–Sivashinsky Equation","title":"1d Kuramoto–Sivashinsky Equation","text":"using Revise, LinearAlgebra, Plots\nusing Parameters, Setfield, ForwardDiff\nusing BifurcationKit\nconst  BK = BifurcationKit\n\n# we use this library for plotting\nusing ApproxFun\n\nfunction generateLinear(n)\n\tΔ = [-k^2 for k = 1:n]\n\treturn Δ, Δ.^2\nend\n\nfunction Fks1d(a, p)\n\t@unpack Δ, Δ2, λ, N = p\n\tout = (2λ) .* (Δ2 .* a)\n\tout .+= (Δ .* a)\n\tfor l=1:N\n\t\tfor m=1:N\n\t\t\tif 0 < l+m <= N\n\t\t\t\tout[l+m] += l*a[l]*a[m]\n\t\t\tend\n\t\t\tif 0 < m-l <= N\n\t\t\t\tout[m-l] += l*a[l]*a[m]\n\t\t\tend\n\n\t\t\tif 0 < -(m-l) <= N\n\t\t\t\tout[l-m] -= l*a[l]*a[m]\n\t\t\tend\n\t\tend\n\tend\n\n\tout .*= -1\n\treturn out\nend\n\n# functional jacobian\nJks1d(u, p) = ForwardDiff.jacobian(z -> Fks1d(z,p), u)\n\n# we group the differentials together\njet = BK.getJet(Fks1d, Jks1d)","category":"page"},{"location":"ks1d/","page":"1d Kuramoto–Sivashinsky Equation","title":"1d Kuramoto–Sivashinsky Equation","text":"Having defined the model, we chose parameters:","category":"page"},{"location":"ks1d/","page":"1d Kuramoto–Sivashinsky Equation","title":"1d Kuramoto–Sivashinsky Equation","text":"N = 50\nΔ, Δ2 = generateLinear(N)\npar_ks = (Δ = Δ, Δ2 = Δ2, λ = 0.75, N = N)","category":"page"},{"location":"ks1d/","page":"1d Kuramoto–Sivashinsky Equation","title":"1d Kuramoto–Sivashinsky Equation","text":"and continuation options","category":"page"},{"location":"ks1d/","page":"1d Kuramoto–Sivashinsky Equation","title":"1d Kuramoto–Sivashinsky Equation","text":"optn = NewtonPar(verbose = false, tol = 1e-9, maxIter = 15)\n\toptc = ContinuationPar(pMin = 1/150., pMax = 1., maxSteps = 700, newtonOptions = optn,\n\tdsmax = 0.01, dsmin = 1e-4, ds = -0.001, detectBifurcation = 3, nev = N, nInversion = 8,\n\tmaxBisectionSteps = 30, dsminBisection = 1e-10, plotEveryStep = 50)\n\nkwargscont = (linearAlgo = MatrixBLS(),\n\tverbosity = 2, plot = true,\n\trecordFromSolution = (x, p) -> (s = sum(x), u2 = x[3], nrm = norm(x)),\n\tplotSolution = (x, p; kwargs...) -> plot!(Fun(SinSpace(), x) ; kwargs...),\n\tnormC = norm)","category":"page"},{"location":"ks1d/#Computation-of-the-bifurcation-diagram","page":"1d Kuramoto–Sivashinsky Equation","title":"Computation of the bifurcation diagram","text":"","category":"section"},{"location":"ks1d/","page":"1d Kuramoto–Sivashinsky Equation","title":"1d Kuramoto–Sivashinsky Equation","text":"# function to adapt continuation option to recursion level\nfunction optrec(x, p, l; opt = optc)\n\tlevel = l\n\tif level <= 2\n\t\treturn setproperties(opt;  dsmax = 0.005, maxSteps = 2000, \n\t\tdetectBifurcation = 3, detectLoop = true, nInversion = 6)\n\telse\n\t\treturn setproperties(opt;  dsmax = 0.005, maxSteps = 2000, \n\t\tdetectBifurcation = 3, detectLoop = true, nInversion = 6)\n\tend\nend\n\n# we now compute the bifurcation diagram\n# that is the connected component of (0,0)\ndiagram = @time bifurcationdiagram(jet...,\n\t\tzeros(N), par_ks, (@lens _.λ), 4, optrec;\n\t\tkwargscont..., verbosity = 0,\n\t\t)","category":"page"},{"location":"ks1d/","page":"1d Kuramoto–Sivashinsky Equation","title":"1d Kuramoto–Sivashinsky Equation","text":"Plotting the result can be done using","category":"page"},{"location":"ks1d/","page":"1d Kuramoto–Sivashinsky Equation","title":"1d Kuramoto–Sivashinsky Equation","text":"plot(diagram; code = (), plotfold = false,  markersize = 3, putspecialptlegend = false,\n\t plotcirclesbif = true, applytoX = x->2/x, vars = (:param, :nrm), \n\t xlim = (0,150), ylim=(0,8))\ntitle!(\"#branches = $(size(diagram, code))\")","category":"page"},{"location":"ks1d/","page":"1d Kuramoto–Sivashinsky Equation","title":"1d Kuramoto–Sivashinsky Equation","text":"(Image: )","category":"page"},{"location":"tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"There are three levels of tutorials:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"fully automatic bifurcation diagram (aBD) computation (only for equilibria): one uses the function bifurcationdiagram and let it compute the diagram fully automatically. Another possibility is to use deflated continuation.\nsemi-automatic bifurcation diagram computation: one uses automatic branch switching (aBS) to compute branches at specified bifurcation points\nmanual bifurcation diagram computation: one does not uses automatic branch switching. This has only educational purposes or for complex problems where aBS fails.","category":"page"},{"location":"tutorials/#ODE-examples","page":"Tutorials","title":"ODE examples","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"We present examples of the use of the package in the case of ODEs. Although BifurcationKit.jl is not geared towards them, we provide some specific methods which allow to study the bifurcations of ODE in a relatively efficient way.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Pages = [\"tutorialsODE.md\", \"tutorialCO.md\", \"tutorialPP2.md\"]\nDepth = 1","category":"page"},{"location":"tutorials/#Bifurcation-of-Equilibria","page":"Tutorials","title":"Bifurcation of Equilibria","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Pages = [\"tutorials1.md\", \"tutorials2.md\", \"mittelmann.md\", \"tutorials1b.md\", \"tutorials2b.md\", \"tutorialsSH3d.md\",\"Langmuir2d.md\"]\nDepth = 1","category":"page"},{"location":"tutorials/#Automatic-bifurcation-diagram","page":"Tutorials","title":"Automatic bifurcation diagram","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Pages = [\"Swift-Hohenberg1d.md\", \"mittelmannAuto.md\", \"tutorialCarrier.md\", \"ks1d.md\", \"ks2d.md\"]\nDepth = 1","category":"page"},{"location":"tutorials/#Solving-PDEs-using-Finite-elements-with-[Gridap.jl](https://github.com/gridap/Gridap.jl)","page":"Tutorials","title":"Solving PDEs using Finite elements with Gridap.jl","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Pages = [\"mittelmannGridap.md\"]\nDepth = 1","category":"page"},{"location":"tutorials/#Bifurcation-diagrams-with-periodic-orbits","page":"Tutorials","title":"Bifurcation diagrams with periodic orbits","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Pages = [\"tutorials3.md\",\"tutorials3b.md\", \"BrusselatorFF.md\", \"tutorialsPD.md\", \"tutorialsCGL.md\", \"tutorialsCGLShoot.md\",\"Langmuir.md\"]\nDepth = 1","category":"page"},{"location":"tutorials/#Bifurcation-diagrams-with-waves","page":"Tutorials","title":"Bifurcation diagrams with waves","text":"","category":"section"},{"location":"tutorialsPD/#Period-doubling-in-the-Barrio-Varea-Aragon-Maini-model","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"","category":"section"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"Pages = [\"tutorialsPD.md\"]\nDepth = 3","category":"page"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"The purpose of this example is to show how to handle period doubling bifurcations of periodic orbits. Note that we do not use automatic branch switching here although this is possible (but not yet for branching from period doubling points).","category":"page"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"unknown: References\nThis example is taken from Aragón, J. L., R. A. Barrio, T. E. Woolley, R. E. Baker, and P. K. Maini. “Nonlinear Effects on Turing Patterns: Time Oscillations and Chaos.” Physical Review E 86, no. 2 (2012)","category":"page"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"info: Method and performance\nWe focus on the Shooting method but we could have based the computation of periodic orbits on finite differences instead. Performances of the current tutorial are directly linked to the ones of DifferentialEquations.jl.     ","category":"page"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"We focus on the following 1D model:","category":"page"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"tagEbeginaligned\nfracpartial upartial t=D nabla^2 u+etaleft(u+a v-C u v-u v^2right)\nfracpartial vpartial t=nabla^2 v+etaleft(b v+H u+C u v+u v^2right)\nendaligned","category":"page"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"with Neumann boundary conditions. We start by encoding the model","category":"page"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"using Revise\nusing DiffEqOperators, ForwardDiff, DifferentialEquations, SparseArrays\nusing BifurcationKit, LinearAlgebra, Plots, Setfield\nconst BK = BifurcationKit\n\nnorminf = x -> norm(x, Inf)\nf(u, v, p) = p.η * (      u + p.a * v - p.C * u * v - u * v^2)\ng(u, v, p) = p.η * (p.H * u + p.b * v + p.C * u * v + u * v^2)\n\nfunction Laplacian(N, lx, bc = :Dirichlet)\n\thx = 2lx/N\n\tD2x = CenteredDifference(2, 2, hx, N)\n\tif bc == :Neumann\n\t\tQx = Neumann0BC(hx)\n\telseif bc == :Dirichlet\n\t\tQx = Dirichlet0BC(typeof(hx))\n\tend\n\tD2xsp = sparse(D2x * Qx)[1]\nend\n\nfunction NL!(dest, u, p, t = 0.)\n\tN = div(length(u), 2)\n\tu1 =  @view (u[1:N])\n\tu2 =  @view (u[N+1:end])\n\tdest[1:N]     .= f.(u1, u2, Ref(p))\n\tdest[N+1:end] .= g.(u1, u2, Ref(p))\n\treturn dest\nend\n\nfunction Fbr!(f, u, p)\n\tmul!(f, p.Δ, u)\n\tf .= f .+ NL(u, p)\nend\n\nfunction NL(u, p)\n\tout = similar(u)\n\tNL!(out, u, p)\n\tout\nend\n\nfunction Fbr(x, p, t = 0.)\n\tf = similar(x)\n\tFbr!(f, x, p)\nend\n\n# this is not very efficient but simple enough ;)\nJbr(x,p) = sparse(ForwardDiff.jacobian(x -> Fbr(x, p), x))","category":"page"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"We can now perform bifurcation of the following Turing solution:","category":"page"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"N = 100\nn = 2N\nlx = 3pi /2\nX = LinRange(-lx,lx, N)\n\nΔ = Laplacian(N, lx, :Neumann)\nD = 0.08\npar_br = (η = 1.0, a = -1., b = -3/2., H = 3.0, D = D, C = -0.6, Δ = blockdiag(D*Δ, Δ))\n\nu0 = 1.0 * cos.(2X)\nsolc0 = vcat(u0, u0)\n\n# parameters for continuation\neigls = EigArpack(0.5, :LM)\nopt_newton = NewtonPar(eigsolver = eigls, verbose=true, maxIter = 3200, tol=1e-9)\nopts_br = ContinuationPar(dsmax = 0.04, ds = -0.01, pMin = -1.8,\n\tdetectBifurcation = 3, nev = 21, plotEveryStep = 50, newtonOptions = opt_newton, maxSteps = 400)\n\nbr, = @time continuation(Fbr, Jbr, solc0, (@set par_br.C = -0.2), (@lens _.C), opts_br;\n\tplot = true, verbosity = 3,\n\trecordFromSolution = (x, p) -> norm(x, Inf),\n\tplotSolution = (x, p; kwargs...) -> plot!(x[1:end÷2];label=\"\",ylabel =\"u\", kwargs...))","category":"page"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"which yields","category":"page"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"(Image: )","category":"page"},{"location":"tutorialsPD/#Periodic-orbits-from-the-Hopf-point-(Shooting)","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Periodic orbits from the Hopf point (Shooting)","text":"","category":"section"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"We continue the periodic orbit form the first Hopf point around Capprox -08598 using a Standard Simple Shooting method (see Periodic orbits based on the shooting method). To this end, we define a SplitODEProblem from DifferentialEquations.jl which is convenient for solving semilinear problems of the form","category":"page"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"dot x = Ax+g(x)","category":"page"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"where A is the infinitesimal generator of a C_0-semigroup. We use the exponential-RK scheme ETDRK2 ODE solver to compute the solution of (E) just after the Hopf point.","category":"page"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"# parameters close to the Hopf bifurcation\npar_br_hopf = @set par_br.C = -0.86\n# parameters for the ODEProblem\nf1 = DiffEqArrayOperator(par_br.Δ)\nf2 = NL!\nprob_sp = SplitODEProblem(f1, f2, solc0, (0.0, 280.0), @set par_br.C = -0.86)\n\nsol = @time solve(prob_sp, ETDRK2(krylov=true); abstol=1e-14, reltol=1e-14, dt = 0.1)","category":"page"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"We estimate the period of the limit cycle to be around Tapprox 3. We then use this as a guess for the shooting method:","category":"page"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"# compute the guess for the shooting method\norbitsection = Array(sol[:, end])\ninitpo = vcat(vec(orbitsection), 3.)\n\n# define the functional for the standard simple shooting based on the\n# ODE solver ETDRK2. SectionShooting implements an appropriate phase condition\nprobSh = ShootingProblem(Fbr, par_br_hopf, prob_sp, ETDRK2(krylov=true),\n\t[sol(280.0)]; abstol=1e-14, reltol=1e-14, dt = 0.1)\n\n# parameters for the Newton-Krylov solver\nls = GMRESIterativeSolvers(reltol = 1e-7, N = length(initpo), maxiter = 50, verbose = false)\noptn = NewtonPar(verbose = true, tol = 1e-9,  maxIter = 120, linsolver = ls)\n# Newton-Krylov solver\nout_po_sh, _, flag = @time newton(probSh , initpo, par_br_hopf, optn; normN = norminf)\nflag && printstyled(color=:red, \"--> T = \", out_po_sh[end], \", amplitude = \", BK.getAmplitude(probSh, out_po_sh, par_br_hopf; ratio = 2),\"\\n\")","category":"page"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"which gives","category":"page"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"--> T = 2.94557883943451, amplitude = 0.05791350025709674","category":"page"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"We can now continue this periodic orbit:","category":"page"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"eig = DefaultEig()\nopts_po_cont = ContinuationPar(dsmin = 0.0001, dsmax = 0.01, ds= 0.005, pMin = -1.8, maxSteps = 170, newtonOptions = (@set optn.eigsolver = eig),\n\tnev = 10, precisionStability = 1e-2, detectBifurcation = 3)\nbr_po_sh, = @time continuation(probSh, out_po_sh, par_br_hopf, (@lens _.C), opts_po_cont; verbosity = 3,\n\tplot = true,\n\tlinearAlgo = MatrixFreeBLS(@set ls.N = probSh.M*n+2),\n\tplotSolution = (x, p; kwargs...) -> BK.plotPeriodicShooting!(x[1:end-1], 1; kwargs...),\n\trecordFromSolution = (u, p) -> BK.getMaximum(probSh, u, (@set par_br_hopf.C = p); ratio = 2), normC = norminf)","category":"page"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"We plot the result using plot(br_po_sh, br, label = \"\"):","category":"page"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"(Image: )","category":"page"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"tip: Numerical precision for stability\nThe Floquet multipliers are not very precisely computed here using the Shooting method. We know that 1=exp(0) should be a Floquet multiplier but this is only true here at precision ~1e-3. In order to prevent spurious bifurcation detection, there is a threshold precisionStability in ContinuationPar for declaring an unstable eigenvalue. Another way would be to use Poincaré Shooting so that this issue does not show up.","category":"page"},{"location":"tutorialsPD/#Periodic-orbits-from-the-PD-point-(Shooting)","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Periodic orbits from the PD point (Shooting)","text":"","category":"section"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"We now compute the periodic orbits branching of the first Period-Doubling bifurcation point. It is straightforward to obtain an initial guess using the flow around the bifurcation point:","category":"page"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"par_br_pd = @set par_br.C = -1.32\nprob_sp = SplitODEProblem(f1, f2, solc0, (0.0, 300.0), par_br_pd)\n# solution close to the PD point.\nsolpd = @time solve(prob_sp, ETDRK2(krylov=true); abstol=1e-14, reltol=1e-14, dt = 0.1)","category":"page"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"The estimated period is T_pd=62:","category":"page"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"orbitsectionpd = Array(solpd[:,end-100])\ninitpo_pd = vcat(vec(orbitsectionpd), 6.2)","category":"page"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"For educational purposes, we show the newton outputs:","category":"page"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"out_po_sh_pd, _, flag = @time newton(probSh, initpo_pd, par_br_pd , optn; normN = norminf)\nflag && printstyled(color=:red, \"--> T = \", out_po_sh_pd[end], \", amplitude = \", BK.getAmplitude(probSh, out_po_sh_pd, par_br_pd; ratio = 2),\"\\n\")","category":"page"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"which gives","category":"page"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":" Newton Iterations\n   Iterations      Func-count      f(x)      Linear-Iterations\n\n        0                1     5.2811e-01         0\n        1                2     3.0518e-02        13\n        2                3     6.4500e-03        14\n        3                4     1.8029e-03        13\n        4                5     6.9716e-05        11\n        5                6     6.6815e-07        12\n        6                7     2.6769e-08        14\n        7                8     1.0727e-09        13\n        8                9     4.3002e-11        13\n  6.941868 seconds (3.59 M allocations: 2.286 GiB, 8.26% gc time)\n--> T = 6.126399996979465, amplitude = 1.410164896740365","category":"page"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"We also compute the branch of periodic orbits using the following command:","category":"page"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"opts_po_cont = ContinuationPar(dsmin = 0.0001, dsmax = 0.005, ds= 0.001, pMin = -1.8, maxSteps = 100, newtonOptions = (@set optn.eigsolver = eig), nev = 5, precisionStability = 1e-3, detectBifurcation = 2)\nbr_po_sh_pd, = @time continuation(probSh, out_po_sh_pd, par_br_pd, (@lens _.C),\n\topts_po_cont; verbosity = 2, plot = true,\n\tplotSolution = (x, p; kwargs...) -> BK.plotPeriodicShooting!(x[1:end-1], 1; kwargs...),\n\trecordFromSolution = (u, p) -> BK.getMaximum(probSh, u, (@set par_br_pd.C = p); ratio = 2), normC = norminf)","category":"page"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"and plot it using plot(br_po_sh, br, br_po_sh_pd, label = \"\"):","category":"page"},{"location":"tutorialsPD/","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"(Image: )","category":"page"},{"location":"guidelines/#Guidelines","page":"Overview","title":"Guidelines","text":"","category":"section"},{"location":"guidelines/","page":"Overview","title":"Overview","text":"The goal of this package is to find solutions x to nonlinear equations ","category":"page"},{"location":"guidelines/","page":"Overview","title":"Overview","text":"F(xp) = 0 quadtagE","category":"page"},{"location":"guidelines/","page":"Overview","title":"Overview","text":"in large dimensions as function of a real parameter p. We want to be able to do so on GPU, distributed systems...","category":"page"},{"location":"guidelines/","page":"Overview","title":"Overview","text":"The core of the package is built around a Newton-Krylov solver (see newton) which allows to solve equations of the form F(x)=0, or find a solution x_0 to (E) for a particular p_0.","category":"page"},{"location":"guidelines/","page":"Overview","title":"Overview","text":"Once such a solution (or several) (x_0p_0) is known, we can continue it by computing a 1d curve of solutions gamma = (x(s)p(s))_sin I passing through (x_0p_0) (see continuation and Deflated Continuation).","category":"page"},{"location":"guidelines/","page":"Overview","title":"Overview","text":"In practice, you don't need to know exactly (x_0p_0) to compute gamma. Indeed, continuation will call newton to refine any initial guess that you pass.","category":"page"},{"location":"guidelines/#Bifurcation-analysis-of-Equilibria","page":"Overview","title":"Bifurcation analysis of Equilibria","text":"","category":"section"},{"location":"guidelines/","page":"Overview","title":"Overview","text":"We can detect if the curve of solutions gamma crosses another curve of solutions gamma^bif without knowing gamma^bif! The intersection point (x^bp^b)ingamma is called a bifurcation point and is such that partial_xF(x^bp^b) is non invertible. When calling γ, = continuation(...) with the option detectBifurcation > 1 inside ContinuationPar, the bifurcation points are automatically detected and stored in γ.specialpoints.","category":"page"},{"location":"guidelines/","page":"Overview","title":"Overview","text":"warning: Eigenvalues\nThe rightmost eigenvalues are computed by default to detect bifurcations. Hence, the number of eigenvalues with positive real parts must be finite (e.g. small). This might require to consider -F(xp)=0 instead of (E).","category":"page"},{"location":"guidelines/#Branch-switching","page":"Overview","title":"Branch switching","text":"","category":"section"},{"location":"guidelines/","page":"Overview","title":"Overview","text":"In the simple case where dimker partial_xF(x^bp^b) = 1, we can compute automatically the bifurcated branch gamma^bif by calling continuation and passing gamma. This is explained in Branch switching from simple branch point to equilibria. Recursively, we can compute the curves of solutions which are connected to (x_0p_0), this is called a bifurcation diagram. This bifurcation diagram can be automatically computed using the function bifurcationdiagram with minimum input from the user. More information is provided in Automatic Bifurcation diagram computation and examples of use are 1d Swift-Hohenberg equation (Automatic) and Automatic diagram of 2d Bratu–Gelfand problem (Intermediate).","category":"page"},{"location":"guidelines/","page":"Overview","title":"Overview","text":"When dequiv dimker partial_xF(x^bp^b)  1, you can still compute automatically the bifurcated branches gamma^bifs by calling continuation. It is based on a reduction of (E) to a small system of d dimensional multivariate polynomial equations in d unknowns whose solutions give the local topology of branches in the neighborhood of the bifurcation point (x^b p^b). The solutions of this reduced equation are then used as initial guesses for the call to Krylov-Newton. This is explained in Branch switching from non simple branch point to equilibria and examples of use are shown in 2d generalized Bratu–Gelfand problem and Automatic diagram of 2d Bratu–Gelfand problem (Intermediate).\t","category":"page"},{"location":"guidelines/","page":"Overview","title":"Overview","text":"In the case d=1, the reduced equation can be further simplified into a normal form. This is also automatically computed by the package.","category":"page"},{"location":"guidelines/#Bifurcation-analysis-of-Cauchy-problems","page":"Overview","title":"Bifurcation analysis of Cauchy problems","text":"","category":"section"},{"location":"guidelines/","page":"Overview","title":"Overview","text":"The goal of this section is to study the dynamics of the Cauchy problem","category":"page"},{"location":"guidelines/","page":"Overview","title":"Overview","text":"fracddtx - F(xp) = 0 quadtagC","category":"page"},{"location":"guidelines/","page":"Overview","title":"Overview","text":"The equilibria are time independent solutions of (C) hence satisfying (E). The previous section can be applied to compute curves of equilibria. However, we can do more. By discretizing time, we can recast (C) in the general form (E) and look for time dependent solutions as well. ","category":"page"},{"location":"guidelines/","page":"Overview","title":"Overview","text":"We can detect the existence of periodic solutions close to gamma. This is done automatically and those bifurcation points are stored in γ.specialpoint as well with the name of Hopf bifurcation points.  ","category":"page"},{"location":"guidelines/#Branch-switching-at-Hopf-points","page":"Overview","title":"Branch switching at Hopf points","text":"","category":"section"},{"location":"guidelines/","page":"Overview","title":"Overview","text":"We focus on computing the branch of periodic solutions branching from a Hopf point. This is done automatically by calling continuation, passing gamma and choosing a time discretization algorithm (see Periodic orbits computation). Some details about this branch switching are given in Branch switching from Hopf point to periodic orbits.","category":"page"},{"location":"guidelines/#Branch-switching-at-bifurcation-points-of-periodic-orbits","page":"Overview","title":"Branch switching at bifurcation points of periodic orbits","text":"","category":"section"},{"location":"guidelines/","page":"Overview","title":"Overview","text":"Let us consider the case where a branch of periodic orbits gamma^po have been computed (see for example previous section) and several bifurcation points have been detected (branch point, period doubling and Neimark Sacker). Can we compute bifurcated branches from gamma^po? Automatically?","category":"page"},{"location":"guidelines/","page":"Overview","title":"Overview","text":"We do not provide an automatic branch switching for those points and for all methods (Shooting, Finite differences). However, for branch points of periodic orbits, you can call continuation by passing gamma^po and some simple arguments (amplitude of the periodic orbits) to perform branch switching in a semi-automatic way. For the case of Periodic orbits based on trapezoidal rule, see Branch switching from Branch point of curve of periodic orbits.","category":"page"},{"location":"guidelines/","page":"Overview","title":"Overview","text":"tip: Manual Branch switching\nYou can perform manual branch switching by computing the nearby solutions close to a bifurcation point using a deflated newton (see Deflated problems), which provides a way to compute solutions other than a set of already known solutions.  You can then use these solutions to compute branches by calling continuation. Many, if not all tutorials give example of doing so like 2d generalized Bratu–Gelfand problem or 1d Brusselator (automatic).","category":"page"},{"location":"mittelmannGridap/#d-Bratu–Gelfand-problem-with-[Gridap.jl](https://github.com/gridap/Gridap.jl)-(Intermediate)","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"","category":"section"},{"location":"mittelmannGridap/","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"Pages = [\"mittelmannGridap.md\"]\nDepth = 3","category":"page"},{"location":"mittelmannGridap/","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"We re-consider the problem of Mittelmann treated in the previous tutorial but using a finite elements method (FEM) implemented in the package Gridap.jl. ","category":"page"},{"location":"mittelmannGridap/","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"Recall that the problem is defined by solving","category":"page"},{"location":"mittelmannGridap/","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"Delta u +NL(lambdau) = 0","category":"page"},{"location":"mittelmannGridap/","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"with Neumann boundary condition on Omega = (01)^2 and where NL(lambdau)equiv-10(u-lambda e^u).","category":"page"},{"location":"mittelmannGridap/","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"We start by installing the package GridapBifurcationKit.jl. Then, we can import the different packages:","category":"page"},{"location":"mittelmannGridap/","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"using Revise\nusing Plots, Gridap,Setfield\nusing Gridap.FESpaces\nusing GridapBifurcationKit, BifurcationKit\n\n# custom plot function to deal with Gridap\nplotgridap!(x; k...) = (n=Int(sqrt(length(x)));heatmap!(reshape(x,n,n); color=:viridis, k...))\nplotgridap(x; k...) =( plot();plotgridap!(x; k...))","category":"page"},{"location":"mittelmannGridap/","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"We are now ready to specify the problem using the setting of Gridap.jl: it allows to write the equations very closely to the mathematical formulation:","category":"page"},{"location":"mittelmannGridap/","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"# discretisation\nn = 40\ndomain = (0,1,0,1)\ncells = (n,n)\nmodel = CartesianDiscreteModel(domain,cells)\n\n# function spaces\norder = 1\nreffe = ReferenceFE(lagrangian,Float64,order)\nV = TestFESpace(model,reffe,conformity=:H1,)#dirichlet_tags=\"boundary\")\nU = TrialFESpace(V)\n\nΩ = Triangulation(model)\ndegree = 2*order\ndΩ = Measure(Ω,degree)\n\n# nonlinearity\nNL(u) = exp(u)\n\n# residual\nres(u,p,v) = ∫( -∇(v)⋅∇(u) -  v ⋅ (u - p.λ ⋅ (NL ∘ u)) * 10 )*dΩ\n\n# jacobian of the residual\njac(u,p,du,v) = ∫( -∇(v)⋅∇(du) - v ⋅ du ⋅ (1 - p.λ * ( NL ∘ u)) * 10 )*dΩ\n\n# 3rd and 4th derivatives, used for aBS\nd2res(u,p,du1,du2,v) = ∫( v ⋅ du1 ⋅ du2 ⋅ (NL ∘ u) * 10 * p.λ )*dΩ\nd3res(u,p,du1,du2,du3,v) = ∫( v ⋅ du1 ⋅ du2 ⋅ du3 ⋅ (NL ∘ u) * 10 * p.λ )*dΩ\n\n# example of initial guess\nuh = zero(U)\n\n# model parameter\npar_bratu = (λ = 0.01,)\n\n# problem definition\nprob = GridapProblem(res, jac, d2res, d3res, V, U)","category":"page"},{"location":"mittelmannGridap/","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"We can call then the newton solver:","category":"page"},{"location":"mittelmannGridap/","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"optn = NewtonPar(eigsolver = EigArpack())\nsol, = newton(prob, uh, par_bratu, NewtonPar(optn; verbose = true))","category":"page"},{"location":"mittelmannGridap/","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"which gives","category":"page"},{"location":"mittelmannGridap/","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":" Newton Iterations\n   Iterations      Func-count      f(x)      Linear-Iterations\n\n        0                1     2.4687e-03         0\n        1                2     1.2637e-07         1\n        2                3     3.3579e-16         1","category":"page"},{"location":"mittelmannGridap/","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"In the same vein, we can continue this solution as function of lambda:","category":"page"},{"location":"mittelmannGridap/","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"opts = ContinuationPar(pMax = 40., pMin = 0.01, ds = 0.01,\n\tmaxSteps = 1000, detectBifurcation = 3, newtonOptions = optn, nev = 20)\nbr, = continuation(prob, uh, par_bratu, (@lens _.λ), opts;\n\tplot = true, verbosity = 2,\n\tplotSolution = (x, p; k...) -> plotgridap!(x;  k...))","category":"page"},{"location":"mittelmannGridap/","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"We obtain:","category":"page"},{"location":"mittelmannGridap/","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"julia> br\n Branch number of points: 53\nBranch of Equilibrium\nBifurcation points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1,    bp at p ≈ +0.36782970 ∈ (+0.36782970, +0.36787920), |δp|=5e-05, [converged], δ = ( 1,  0), step =  12, eigenelements in eig[ 13], ind_ev =   1\n- #  2,    nd at p ≈ +0.27168226 ∈ (+0.27168226, +0.27286757), |δp|=1e-03, [converged], δ = ( 2,  0), step =  19, eigenelements in eig[ 20], ind_ev =   3\n- #  3,    bp at p ≈ +0.15186464 ∈ (+0.15186464, +0.15187849), |δp|=1e-05, [converged], δ = ( 1,  0), step =  26, eigenelements in eig[ 27], ind_ev =   4\n- #  4,    nd at p ≈ +0.03484879 ∈ (+0.03484879, +0.03491029), |δp|=6e-05, [converged], δ = ( 2,  0), step =  41, eigenelements in eig[ 42], ind_ev =   6\n- #  5,    nd at p ≈ +0.01556655 ∈ (+0.01556655, +0.01559518), |δp|=3e-05, [converged], δ = ( 2,  0), step =  48, eigenelements in eig[ 49], ind_ev =   8\nFold points:\n- #  1, fold at p ≈ 0.36782970 ∈ (0.36782970, 0.36782970), |δp|=-1e+00, [    guess], δ = ( 0,  0), step =  13, eigenelements in eig[ 13], ind_ev =   0\n\n","category":"page"},{"location":"mittelmannGridap/","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"(Image: )","category":"page"},{"location":"mittelmannGridap/#Computation-of-the-first-branches","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"Computation of the first branches","text":"","category":"section"},{"location":"mittelmannGridap/","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"Let us now compute the first branches from the bifurcation points. We start with the one with 1d kernel:","category":"page"},{"location":"mittelmannGridap/","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"br1, = continuation(prob, br, 3,\n\tsetproperties(opts;ds = 0.001, dsmax = 0.05, maxSteps = 140, detectBifurcation = 3);\n\tverbosity = 0, plot = true, nev = 10,\n\ttangentAlgo = BorderedPred(),\n\tusedeflation = true,\n\tplotSolution = (x, p; k...) -> plotgridap!(x;  k...))","category":"page"},{"location":"mittelmannGridap/","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"We also compute the branch from the first bifurcation point on this branch br1:","category":"page"},{"location":"mittelmannGridap/","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"br2, = continuation(prob, br1, 1,\n\tsetproperties(opts;ds = 0.005, dsmax = 0.05, maxSteps = 140, detectBifurcation = 0);\n\tverbosity = 0, plot = true, nev = 10,\n\ttangentAlgo = BorderedPred(),\n\tusedeflation = true,\n\tplotSolution = (x, p; k...) -> plotgridap!(x;  k...))\n\nplot(br, br1, br2)","category":"page"},{"location":"mittelmannGridap/","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"We get:","category":"page"},{"location":"mittelmannGridap/","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"(Image: )","category":"page"},{"location":"mittelmannGridap/","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"Finally, we compute the branches from the 2d bifurcation point:","category":"page"},{"location":"mittelmannGridap/","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"br3, = continuation(prob, br, 2,\n\tsetproperties(opts;ds = 0.005, dsmax = 0.05, maxSteps = 140, detectBifurcation = 3);\n\tverbosity = 0, plot = true, nev = 10,\n\tusedeflation = true,\n\tplotSolution = (x, p; k...) -> plotgridap!(x;  k...))\n\nplot(br, br1, br2, br3...)","category":"page"},{"location":"mittelmannGridap/","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"(Image: )","category":"page"},{"location":"mittelmann/#d-generalized-Bratu–Gelfand-problem","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"","category":"section"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"Pages = [\"mittelmann.md\"]\nDepth = 3","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"unknown: References\nThe following example is exposed in Farrell, Patrick E., Casper H. L. Beentjes, and Ásgeir Birkisson. The Computation of Disconnected Bifurcation Diagrams. ArXiv:1603.00809 [Math], March 2, 2016. It is also treated in Michiel Wouters. Automatic Exploration Techniques for the Numerical Continuation of Large–Scale Nonlinear Systems, 2019.","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"We consider the problem of Mittelmann:","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"Delta u + NL(lambdau) = 0","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"with Neumann boundary condition on Omega = (01)^2 and where NL(lambdau)equiv-10(u-lambda e^u). This is a good example to show how automatic branch switching works and also nonlinear deflation.","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"We start with some imports:","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"using Revise\nusing DiffEqOperators, ForwardDiff\nusing BifurcationKit, LinearAlgebra, Plots, SparseArrays, Parameters, Setfield\nconst BK = BifurcationKit\n\n# define the sup norm and a L2 norm\nnorminf = x -> norm(x, Inf)\nnormbratu = x -> norm(x .* w) / sqrt(length(x)) # the weight w is defined below\n\n# some plotting functions to simplify our life\nplotsol!(x, nx = Nx, ny = Ny; kwargs...) = heatmap!(reshape(x, nx, ny); color = :viridis, kwargs...)\nplotsol(x, nx = Nx, ny = Ny; kwargs...) = (plot();plotsol!(x, nx, ny; kwargs...))","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"and with the discretization of the problem","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"function Laplacian2D(Nx, Ny, lx, ly, bc = :Neumann)\n\thx = 2lx/Nx\n\thy = 2ly/Ny\n\tD2x = CenteredDifference(2, 2, hx, Nx)\n\tD2y = CenteredDifference(2, 2, hy, Ny)\n\n\tQx = Neumann0BC(hx)\n\tQy = Neumann0BC(hy)\n\n\tD2xsp = sparse(D2x * Qx)[1]\n\tD2ysp = sparse(D2y * Qy)[1]\n\tA = kron(sparse(I, Ny, Ny), D2xsp) + kron(D2ysp, sparse(I, Nx, Nx))\n\treturn A\nend\n\nϕ(u, λ)  = -10(u-λ*exp(u))\ndϕ(u, λ) = -10(1-λ*exp(u))\n\nfunction NL!(dest, u, p)\n\t@unpack λ = p\n\tdest .= ϕ.(u, λ)\n\treturn dest\nend\n\nNL(u, p) = NL!(similar(u), u, p)\n\nfunction Fmit!(f, u, p)\n\tmul!(f, p.Δ, u)\n\tf .= f .+ NL(u, p)\n\treturn f\nend\n\nFmit(u, p) = Fmit!(similar(u), u, p)","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"It will also prove useful to have the derivatives of our functional: ","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"function JFmit(x,p)\n\tJ = p.Δ\n\tdg = dϕ.(x, p.λ)\n\treturn J + spdiagm(0 => dg)\nend\n\n# compute 3-Jet\njet = BK.getJet(Fmit, JFmit)","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"We need to define the parameters associated to this problem:","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"Nx = 30; Ny = 30\nlx = 0.5; ly = 0.5\n# weight for the weighted norm\nconst w = (lx .+ LinRange(-lx,lx,Nx)) * (LinRange(-ly,ly,Ny))' |> vec\n\nΔ = Laplacian2D(Nx, Ny, lx, ly)\npar_mit = (λ = .05, Δ = Δ)\n\n# initial guess f for newton\nsol0 = zeros(Nx, Ny) |> vec","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"To compute the eigenvalues, we opt for the shift-invert strategy with shift =0.5","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"# eigensolver\neigls = EigKrylovKit(dim = 70)\n\n# options for Newton solver, we pass the eigensolverr\nopt_newton = BK.NewtonPar(tol = 1e-8, verbose = true, eigsolver = eigls, maxIter = 20)\n\n# options for continuation\nopts_br = ContinuationPar(pMax = 3.5, pMin = 0.025,\n\t# for a good looking curve\n\tdsmin = 0.001, dsmax = 0.05, ds = 0.01, \n\t# number of eigenvalues to compute\n\tnev = 30, \n\tplotEveryStep = 10, newtonOptions = (@set opt_newton.verbose = true), \n\tmaxSteps = 100, precisionStability = 1e-6, \n\t# detect codim 1 bifurcations\n\tdetectBifurcation = 3,\n\t# Optional: bisection options for locating bifurcations\n\tnInversion = 4, dsminBisection = 1e-7, maxBisectionSteps = 25)","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"Note that we put the option detectBifurcation = 3 to detect bifurcations precisely with a bisection method. Indeed, we need to locate these branch points precisely to be able to call automatic branch switching.","category":"page"},{"location":"mittelmann/#Branch-of-homogenous-solutions","page":"2d generalized Bratu–Gelfand problem","title":"Branch of homogenous solutions","text":"","category":"section"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"At this stage, we note that the problem has a curve of homogenous (constant in space) solutions u_h solving N(lambda u_h)=0. We shall compute this branch now.","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"Given that we will use these arguments for continuation many times, it is wise to collect them:","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"# optional arguments for continuation\nkwargsC = (verbosity = 3, plot = true,\n\trecordFromSolution = (x, p) -> (x = normbratu(x), n2 = norm(x), n∞ = norminf(x)),\n\tplotSolution = (x, p; k...) -> plotsol!(x ; k...),\n\tnormC = norminf\n\t)","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"We call continuation with the initial guess sol0 which is homogenous, thereby generating homogenous solutions:","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"br, = BK.continuation(Fmit, JFmit, sol0, par_mit, (@lens _.λ), opts_br; kwargsC...)","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"You should see the following result:","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"(Image: )","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"Several branch point were detected as can be seen using the command","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"julia> br\nBranch number of points: 84\nBranch of Equilibrium\nParameters λ from 0.05 to 0.025\nBifurcation points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1,    bp at λ ≈ +0.36787944 ∈ (+0.36787944, +0.36787944), |δp|=2e-10, [converged], δ = ( 1,  0), step =  18, eigenelements in eig[ 19], ind_ev =   1\n- #  2,    nd at λ ≈ +0.27255474 ∈ (+0.27255474, +0.27255937), |δp|=5e-06, [converged], δ = ( 2,  0), step =  33, eigenelements in eig[ 34], ind_ev =   3\n- #  3,    bp at λ ≈ +0.15215124 ∈ (+0.15215124, +0.15215818), |δp|=7e-06, [converged], δ = ( 1,  0), step =  48, eigenelements in eig[ 49], ind_ev =   4\n- #  4,    nd at λ ≈ +0.03551852 ∈ (+0.03551852, +0.03554981), |δp|=3e-05, [converged], δ = ( 2,  0), step =  76, eigenelements in eig[ 77], ind_ev =   6","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"We notice several simple bifurcation points for which the dimension of the kernel of the jacobian is one dimensional. In the above box, δ = ( 1,  0) gives the change in the stability. In this case, there is one vector in the kernel which is real. The bifurcation point 2 has a 2d kernel and is thus not amenable to automatic branch switching.","category":"page"},{"location":"mittelmann/#Automatic-branch-switching-at-simple-branch-points","page":"2d generalized Bratu–Gelfand problem","title":"Automatic branch switching at simple branch points","text":"","category":"section"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"We can compute the branch off the third bifurcation point:","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"br1, = continuation(jet..., br, 3, \n\tsetproperties(opts_br;ds = 0.001, maxSteps = 40); kwargsC...)","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"and you should see:","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"(Image: )","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"You can also plot the two branches together plot(br,br1,plotfold=false) and get","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"(Image: )","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"We continue our journey and compute the branch bifurcating of the first bifurcation point from the last branch we computed:","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"br2, = continuation(jet..., br1, 1, \n\tsetproperties(opts_br;ds = 0.001, maxSteps = 40); kwargsC...)","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"(Image: )","category":"page"},{"location":"mittelmann/#Analysis-at-the-2d-branch-points-(manual)","page":"2d generalized Bratu–Gelfand problem","title":"Analysis at the 2d-branch points (manual)","text":"","category":"section"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"The second bifurcation point on the branch br of homogenous solutions has a 2d kernel. we provide two methods to deal with such case","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"automatic local bifurcation diagram (see below)\nbranch switching with deflation (see next section)","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"We provide a generic way to study branch points of arbitrary dimensions by computing a reduced equation. The general method is based on a Lyapunov-Schmidt reduction. We can compute the information about the branch point using the generic function (valid for simple branch points, Hopf bifurcation points,...)","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"bp2d = computeNormalForm(jet..., br, 2;  verbose=true, nev = 50)","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"You can print the 2d reduced equation as follows. Note that this is a multivariate polynomials. For more information, see Non-simple branch point.","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"julia> bp2d\nNon simple bifurcation point at p ≈ 0.27255473583423123. \nKernel dimension = 2\nNormal form :\n + -73.8978 * x1 ⋅ p + 0.0071 ⋅ x1³ + 0.0231 ⋅ x1² ⋅ x2 + -0.0273 ⋅ x1 ⋅ x2² + -0.0076 ⋅ x2³\n + -73.8978 * x2 ⋅ p + 0.0079 ⋅ x1³ + -0.027 ⋅ x1² ⋅ x2 + -0.0231 ⋅ x1 ⋅ x2² + 0.0072 ⋅ x2³","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"You can evaluate this polynomial as follows bp2d(Val(:reducedForm),[0.1,0.2], 0.01) which returns a 2d vector or bp2d([0.1,0.2], 0.01). This last expression actually returns a vector corresponding to the PDE problem.","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"You need to solve these equations to compute the bifurcation diagram in the neighborhood of the bifurcation point. In the present case, we do it using brute force. We suggest to use IntervalConstraintProgramming.jl for a more precise way.","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"using ProgressMeter\nNd = 200; L = 0.9\n# sampling grid\nX = LinRange(-L,L, Nd); Y = LinRange(-L,L, Nd); P = LinRange(-0.0001,0.0001, Nd+1)\n\n# sample reduced equation on the grid for the first component\nV1a = @showprogress [bp2d(Val(:reducedForm),[x1,y1], p1)[1] for p1 in P, x1 in X, y1 in Y]\nInd1 = findall( abs.(V1a) .<= 9e-4 * maximum(abs.(V1a)))\n# intersect with second component\nV2a = @showprogress [bp2d(Val(:reducedForm),[X[ii[2]],Y[ii[3]]], P[ii[1]])[2] for ii in Ind1]\nInd2 = findall( abs.(V2a) .<= 3e-3 * maximum(abs.(V2a)))\n\n# get solutions\nresp = Float64[]; resx = Vector{Float64}[]; resnrm = Float64[]\n\t@showprogress for k in Ind2\n\t\tii = Ind1[k]\n\t\tpush!(resp, P[ii[1]])\n\t\tpush!(resnrm, sqrt(X[ii[2]]^2+Y[ii[3]]^2))\n\t\tpush!(resx, [X[ii[2]], Y[ii[3]]])\n\tend","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"We can now plot the local bifurcation diagram as follows","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"using LaTeXStrings\nplot(\n\tscatter(1e4resp, map(x->x[1], resx), map(x->x[2], resx); label = \"\", markerstrokewidth=0, xlabel = L\"10^4 \\cdot \\lambda\", ylabel = L\"x_1\", zlabel = L\"x_2\", zcolor = resnrm, color = :viridis,colorbar=false),\n\tscatter(1e4resp, resnrm; label = \"\", markersize =2, markerstrokewidth=0, xlabel = L\"10^4 \\cdot \\lambda\", ylabel = L\"\\|x\\|\"))","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"(Image: )","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"This looks like a Pitchfork bifurcation with D4 symmetry","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"We can see that there are two types of solutions. After the bifurcation point, the solutions are of the form (x_1x_2) = (pm xpm x) for some real x. Before the bifurcation point, the solutions are of the form (x_1x_2) = (pm x0) (0 pm x) for some real x. Here is an example plotsol(bp2d(resx[10], resp[10]))","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"(Image: )","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"We could use the solutions saved in resp, resx as initial guesses for a call to continuation but we turn to a different method.","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"tip: Solutions\nThe brute force method provided all solutions in a neighborhood of the bifurcation point.","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"info: Advanced computation\nInstead of using brute force and computing the vector field on a grid. One can rely on IntervalConstraintProgramming.jl to do better using bisection. See also this discourse post where the same example is treated by D. P. Sanders.    ","category":"page"},{"location":"mittelmann/#Branch-switching-with-deflated-newton-(manual)","page":"2d generalized Bratu–Gelfand problem","title":"Branch switching with deflated newton (manual)","text":"","category":"section"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"At this stage, we know what happens at the 2d bifurcation point of the curve of homogenous solutions. We chose another method based on Deflated problems. We want to find all nearby solutions of the problem close to this bifurcation point. This is readily done by trying several initial guesses in a brute force manner:","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"out = zeros(Nx*Ny)\n# deflation operator to \ndeflationOp = DeflationOperator(2, 1.0, [zeros(Nx*Ny)])\n\n# options for the newton solver\noptdef = setproperties(opt_newton; tol = 1e-8, maxIter = 100)\n\n# eigen-elements close to the second bifurcation point on the branch\n# of homogenous solutions\nvp, ve, _, _= eigls(JFmit(out, @set par_mit.λ = br.specialpoint[2].param), 5)\n\nfor ii=1:length(ve)\n\toutdef1, _, flag, _ = @time newton(\n\t\tFmit, JFmit,\n\t\t# initial guess for newton\n\t\tbr.specialpoint[2].x .+ 0.01 .*  real.(ve[ii]) .* (1 .+ 0.01 .* rand(Nx*Ny)),\n\t\t(@set par_mit.λ = br.specialpoint[2].param + 0.005),\n\t\toptdef, deflationOp)\n\t\tflag && push!(deflationOp, outdef1)\nend","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"This provides length(deflationOp) = 5 solutions as there are some symmetries in the problem. For example plotsol(deflationOp[5]) gives","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"(Image: )","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"We can continue this solution as follows in one direction","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"brdef1, = continuation(\n\tFmit, JFmit,\n\tdeflationOp[3], (@set par_mit.λ = br.specialpoint[2].param + 0.005), (@lens _.λ),\n\tsetproperties(opts_br;ds = -0.001, detectBifurcation = 3, dsmax = 0.01, maxSteps = 500);\n\tkwargsC...)","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"If we repeat the above loop but before the branch point by using @set par_mit.λ = br.specialpoint[2].param + 0.005, we get 3 new solutions that we can continue","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"brdef2, = continuation(\n\tFmit, JFmit,\n\tdeflationOp[5], (@set par_mit.λ = br.specialpoint[2].param + 0.005), (@lens _.λ),\n\tsetproperties(opts_br;ds = 0.001, detectBifurcation = 3, dsmax = 0.01);\n\tkwargsC...)","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"thereby providing the following bifurcation diagram with plot(br,br1,br2,brdef1, brdef2,plotfold=false, putbifptlegend = false)","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"(Image: )","category":"page"},{"location":"mittelmann/#Automatic-branch-switching-at-the-2d-branch-points","page":"2d generalized Bratu–Gelfand problem","title":"Automatic branch switching at the 2d-branch points","text":"","category":"section"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"We now show how to perform automatic branch switching at the nonsimple branch points. However, we think it is important that the user is able to use the previous tools in case automatic branch switching fails.","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"The call for automatic branch switching is the same as in the case of simple branch points (see above) except that many branches are returned.","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"branches, = continuation(jet..., br, 2,\n\tsetproperties(opts_br; detectBifurcation = 3, ds = 0.001, pMin = 0.01, maxSteps = 32 ) ;\n\tkwargsC...,\n\tnev = 30, tangentAlgo = BorderedPred()\n\t)","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"You can plot the branches using plot(branches...). The branches are as follows","category":"page"},{"location":"mittelmann/","page":"2d generalized Bratu–Gelfand problem","title":"2d generalized Bratu–Gelfand problem","text":"julia> branches\n8-element Vector{Branch}:\n Branch number of points: 33\nBranch of Equilibrium from NonSimpleBranchPoint bifurcation point.\nParameters λ from 0.27255473583423384 to 0.0656104381834156\nBifurcation points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1,    bp at λ ≈ +0.27255723 ∈ (+0.27255723, +0.27255723), |δp|=7e-10, [converged], δ = (-1,  0), step =   1, eigenelements in eig[  2], ind_ev =   3\n- #  2,    bp at λ ≈ +0.14414814 ∈ (+0.14414814, +0.14424073), |δp|=9e-05, [converged], δ = ( 1,  0), step =  24, eigenelements in eig[ 25], ind_ev =   3\n\n Branch number of points: 33\nBranch of Equilibrium from NonSimpleBranchPoint bifurcation point.\nParameters λ from 0.27255473583423384 to 0.06561043854512201\nBifurcation points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1,    bp at λ ≈ +0.27255723 ∈ (+0.27255723, +0.27255723), |δp|=7e-10, [converged], δ = (-1,  0), step =   1, eigenelements in eig[  2], ind_ev =   3\n- #  2,    bp at λ ≈ +0.14414814 ∈ (+0.14414814, +0.14424073), |δp|=9e-05, [converged], δ = ( 1,  0), step =  24, eigenelements in eig[ 25], ind_ev =   3\n\n Branch number of points: 33\nBranch of Equilibrium from NonSimpleBranchPoint bifurcation point.\nParameters λ from 0.27255473583423384 to 0.06561044134787948\nBifurcation points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1,    bp at λ ≈ +0.27255723 ∈ (+0.27255723, +0.27255723), |δp|=7e-10, [converged], δ = (-1,  0), step =   1, eigenelements in eig[  2], ind_ev =   3\n- #  2,    bp at λ ≈ +0.14414815 ∈ (+0.14414815, +0.14424074), |δp|=9e-05, [converged], δ = ( 1,  0), step =  24, eigenelements in eig[ 25], ind_ev =   3\n\n Branch number of points: 33\nBranch of Equilibrium from NonSimpleBranchPoint bifurcation point.\nParameters λ from 0.27255473583423384 to 0.06561043798345574\nBifurcation points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1,    bp at λ ≈ +0.27255723 ∈ (+0.27255723, +0.27255723), |δp|=7e-10, [converged], δ = (-1,  0), step =   1, eigenelements in eig[  2], ind_ev =   3\n- #  2,    bp at λ ≈ +0.14414814 ∈ (+0.14414814, +0.14424073), |δp|=9e-05, [converged], δ = ( 1,  0), step =  24, eigenelements in eig[ 25], ind_ev =   3\n\n Branch number of points: 33\nBranch of Equilibrium from NonSimpleBranchPoint bifurcation point.\nParameters λ from 0.27255473583423384 to 0.09945404995078021\nBifurcation points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1,    bp at λ ≈ +0.27255724 ∈ (+0.27255724, +0.27255724), |δp|=9e-10, [converged], δ = (-1,  0), step =   1, eigenelements in eig[  2], ind_ev =   3\n- #  2,    bp at λ ≈ +0.27868730 ∈ (+0.27868728, +0.27868730), |δp|=3e-08, [converged], δ = (-1,  0), step =  15, eigenelements in eig[ 16], ind_ev =   2\n\n Branch number of points: 33\nBranch of Equilibrium from NonSimpleBranchPoint bifurcation point.\nParameters λ from 0.27255473583423384 to 0.09945405127587528\nBifurcation points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1,    bp at λ ≈ +0.27255724 ∈ (+0.27255724, +0.27255724), |δp|=9e-10, [converged], δ = (-1,  0), step =   1, eigenelements in eig[  2], ind_ev =   3\n- #  2,    bp at λ ≈ +0.27868730 ∈ (+0.27868728, +0.27868730), |δp|=3e-08, [converged], δ = (-1,  0), step =  15, eigenelements in eig[ 16], ind_ev =   2\n\n Branch number of points: 33\nBranch of Equilibrium from NonSimpleBranchPoint bifurcation point.\nParameters λ from 0.27255473583423384 to 0.09945404945914721\nBifurcation points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1,    bp at λ ≈ +0.27255724 ∈ (+0.27255724, +0.27255724), |δp|=9e-10, [converged], δ = (-1,  0), step =   1, eigenelements in eig[  2], ind_ev =   3\n- #  2,    bp at λ ≈ +0.27868730 ∈ (+0.27868728, +0.27868730), |δp|=3e-08, [converged], δ = (-1,  0), step =  15, eigenelements in eig[ 16], ind_ev =   2\n\n Branch number of points: 33\nBranch of Equilibrium from NonSimpleBranchPoint bifurcation point.\nParameters λ from 0.27255473583423384 to 0.09945404935297063\nBifurcation points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1,    bp at λ ≈ +0.27255724 ∈ (+0.27255724, +0.27255724), |δp|=9e-10, [converged], δ = (-1,  0), step =   1, eigenelements in eig[  2], ind_ev =   3\n- #  2,    bp at λ ≈ +0.27868730 ∈ (+0.27868728, +0.27868730), |δp|=3e-08, [converged], δ = (-1,  0), step =  15, eigenelements in eig[ 16], ind_ev =   2","category":"page"},{"location":"periodicOrbit/#Periodic-orbits-computation","page":"Introduction","title":"Periodic orbits computation","text":"","category":"section"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"We provide two methods for computing periodic orbits (PO):","category":"page"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"one based on finite differences to discretize a Cauchy problem\none based on the flow associated to a Cauchy problem","category":"page"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"It is important to understand the pro and cons of each method to compute PO in large dimensions.","category":"page"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"The methods based on finite differences are usually faster than the ones based on Shooting but they require more memory as they save the whole orbit. However the main drawback of this method is that the associated linear solver is not \"nice\", being composed of a cyclic matrix for which no generic Matrix-free preconditioner is known. Hence, this method is often used with an ILU preconditioner which is severely constrained by memory. Also, when the period of the cycle is large, finer time discretization (or mesh adaptation which is not yet implemented) must be employed which is also a limiting factor both in term of memory and preconditioning.","category":"page"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"The methods based on Shooting do not share the same drawbacks because the associated linear system is usually well conditioned, at least in the simple shooting case. There are thus often used without preconditioner at all. Even in the case of multiple shooting, this can be alleviated by a simple generic preconditioner based on deflation of eigenvalues (see Linear solvers (LS)). Also, the time stepper will automatically adapt to the stiffness of the problem, putting more time points where needed unlike the method based on finite differences which requires an adaptive (time) meshing to provide a similar property. The main drawback of the method is to find a fast time stepper, at least to compete with the method based on finite differences.","category":"page"},{"location":"nonsimplebp/#Non-simple-branch-point","page":"Non-simple branch point","title":"Non-simple branch point","text":"","category":"section"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"unknown: References\nThe general method is exposed in Golubitsky, Martin, David G Schaeffer, and Ian Stewart. Singularities and Groups in Bifurcation Theory. New York: Springer-Verlag, 1985, VI.1.d page 295","category":"page"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"tip: Example\nAn example of use of the methods presented here is provided in 2d generalized Bratu–Gelfand problem.    ","category":"page"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"We expose our method to study non-simple branch points. Such branch point (x_0p_0) for the problem F(xp)=0 satisfies d=dim ker dF(x_0p_0)  1 and the eigenvalues have zero imaginary part. At such point, we can apply Lyapunov-Schmidt reduction to transform the initial problem in large dimensions to a d-dimensional polynomial equation, called the reduced equation.","category":"page"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"More precisely, it is possible to write x = u + v where uin ker dF(x_0p_0) and vapprox 0 belongs to a vector space complement of ker dF(x_0p_0). It can be shown that u solves Phi(udelta p)=0 with Phi(udelta p) = (I-Pi)F(u+psi(udelta p)p_0+delta p) where psi is known implicitly and Pi is the spectral projector on ker dF(x_0p_0). Fortunately, one can compute the Taylor expansion of Phi up to order 3. Computing the bifurcation diagram of this d-dimensional multivariate polynomials can be done using brute force methods.","category":"page"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"Once the zeros of Phi have been located, we can use them as initial guess for continuation but for the original F !!","category":"page"},{"location":"nonsimplebp/#Reduced-equation-computation","page":"Non-simple branch point","title":"Reduced equation computation","text":"","category":"section"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"The reduced equation (E) can be automatically computed as follows","category":"page"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"computeNormalForm(F, dF, d2F, d3F, br::ContResult, ind_bif::Int ; δ = 1e-8,\n\tnev = 5, Jᵗ = nothing, verbose = false, ζs = nothing, lens = br.param_lens)","category":"page"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"where dF, d2F,d3F are the differentials of F. br is a branch computed after a call to continuation with detection of bifurcation points enabled and ind_bif is the index of the bifurcation point on the branch br. The above call returns a point with information needed to compute the bifurcated branch. For more information about the optional parameters, we refer to computeNormalForm. It returns a point with all requested information:","category":"page"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"mutable struct NdBranchPoint{Tv, T, Tevl, Tevr, Tnf} <: BranchPoint\n\t\"bifurcation point\"\n\tx0::Tv\n\n\t\"Parameter value at the bifurcation point\"\n\tp::T\n\n\t\"Right eigenvectors\"\n\tζ::Tevr\n\n\t\"Left eigenvectors\"\n\tζstar::Tevl\n\n\t\"Normal form coefficients\"\n\tnf::Tnf\n\n\t\"Type of bifurcation point\"\n\ttype::Symbol\nend","category":"page"},{"location":"nonsimplebp/#Using-the-Reduced-equation","page":"Non-simple branch point","title":"Using the Reduced equation","text":"","category":"section"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"Once a branch point has been computed bp = computeNormalForm(...), you can do all sort of things. ","category":"page"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"For example, quoted from the file test/testNF.jl, you can print the 2d reduced equation as follows:","category":"page"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"julia> BifurcationKit.nf(bp2d)\n2-element Array{String,1}:\n \" + (3.23 + 0.0im) * x1 * p + (-0.123 + 0.0im) * x1^3 + (-0.234 + 0.0im) * x1 * x2^2\"\n \" + (-0.456 + 0.0im) * x1^2 * x2 + (3.23 + 0.0im) * x2 * p + (-0.123 + 0.0im) * x2^3\"","category":"page"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"You can evaluate the reduced equation as bp2d(Val(:reducedForm), rand(2), 0.2). This can be used to find all the zeros of the reduced equation by sampling on a grid. \nFinally, given a d-dimensional vector x and a parameter delta p, you can can have access to an initial guess u (see above) by calling bp2d(rand(2), 0.1)","category":"page"},{"location":"Swift-Hohenberg1d/#d-Swift-Hohenberg-equation-(Automatic)","page":"1d Swift-Hohenberg equation (Automatic)","title":"1d Swift-Hohenberg equation (Automatic)","text":"","category":"section"},{"location":"Swift-Hohenberg1d/","page":"1d Swift-Hohenberg equation (Automatic)","title":"1d Swift-Hohenberg equation (Automatic)","text":"Pages = [\"Swift-Hohenberg1d.md\"]\nDepth = 3","category":"page"},{"location":"Swift-Hohenberg1d/","page":"1d Swift-Hohenberg equation (Automatic)","title":"1d Swift-Hohenberg equation (Automatic)","text":"In this tutorial, we will see how to compute automatically the bifurcation diagram of the 1d Swift-Hohenberg equation","category":"page"},{"location":"Swift-Hohenberg1d/","page":"1d Swift-Hohenberg equation (Automatic)","title":"1d Swift-Hohenberg equation (Automatic)","text":"-(I+Delta)^2 u+lcdot u +nu u^3-u^5 = 0tagE","category":"page"},{"location":"Swift-Hohenberg1d/","page":"1d Swift-Hohenberg equation (Automatic)","title":"1d Swift-Hohenberg equation (Automatic)","text":"with Dirichlet boundary conditions. We use a Sparse Matrix to express the operator L_1=(I+Delta)^2. We start by loading the packages:","category":"page"},{"location":"Swift-Hohenberg1d/","page":"1d Swift-Hohenberg equation (Automatic)","title":"1d Swift-Hohenberg equation (Automatic)","text":"using Revise\nusing SparseArrays, LinearAlgebra, DiffEqOperators, Setfield, Parameters\nusing BifurcationKit\nusing Plots\nconst BK = BifurcationKit","category":"page"},{"location":"Swift-Hohenberg1d/","page":"1d Swift-Hohenberg equation (Automatic)","title":"1d Swift-Hohenberg equation (Automatic)","text":"We then define a discretization of the problem","category":"page"},{"location":"Swift-Hohenberg1d/","page":"1d Swift-Hohenberg equation (Automatic)","title":"1d Swift-Hohenberg equation (Automatic)","text":"# define a norm\nnorminf(x) = norm(x, Inf64)\n\n# discretisation\nNx = 200; Lx = 6.;\nX = -Lx .+ 2Lx/Nx*(0:Nx-1) |> collect\nhx = X[2]-X[1]\n\n# boundary condition\nQ = Dirichlet0BC(hx |> typeof)\nDxx = sparse(CenteredDifference(2, 2, hx, Nx) * Q)[1]\nLsh = -(I + Dxx)^2\n\n# functional of the problem\nfunction R_SH(u, par)\n\t@unpack l, ν, L1 = par\n\tout = similar(u)\n\tout .= L1 * u .+ l .* u .+ ν .* u.^3 - u.^5\nend\n\n# Jacobian of the function\nJac_sp(u, par) = par.L1 + spdiagm(0 => par.l .+ 3 .* par.ν .* u.^2 .- 5 .* u.^4)\n\n# second derivative\nd2R(u,p,dx1,dx2) = @. p.ν * 6u*dx1*dx2 - 5*4u^3*dx1*dx2\n\n# third derivative\nd3R(u,p,dx1,dx2,dx3) = @. p.ν * 6dx3*dx1*dx2 - 5*4*3u^2*dx1*dx2*dx3\n\n# jet associated with the functional\njet = (R_SH, Jac_sp, d2R, d3R)\n\n# parameters associated with the equation\nparSH = (l = -0.7, ν = 2., L1 = Lsh)","category":"page"},{"location":"Swift-Hohenberg1d/","page":"1d Swift-Hohenberg equation (Automatic)","title":"1d Swift-Hohenberg equation (Automatic)","text":"We then choose the parameters for continuation with precise detection of bifurcation points by bisection:","category":"page"},{"location":"Swift-Hohenberg1d/","page":"1d Swift-Hohenberg equation (Automatic)","title":"1d Swift-Hohenberg equation (Automatic)","text":"optnew = NewtonPar(verbose = true, tol = 1e-12)\nopts = ContinuationPar(dsmin = 0.0001, dsmax = 0.01, ds = 0.01, pMax = 1.,\n\tnewtonOptions = setproperties(optnew; maxIter = 30, tol = 1e-8), \n\tmaxSteps = 300, plotEveryStep = 40, \n\tdetectBifurcation = 3, nInversion = 4, tolBisectionEigenvalue = 1e-17, dsminBisection = 1e-7)","category":"page"},{"location":"Swift-Hohenberg1d/","page":"1d Swift-Hohenberg equation (Automatic)","title":"1d Swift-Hohenberg equation (Automatic)","text":"Before we continue, it is useful to define a callback (see continuation) for newton to avoid spurious branch switching. It is not strictly necessary for what follows. ","category":"page"},{"location":"Swift-Hohenberg1d/","page":"1d Swift-Hohenberg equation (Automatic)","title":"1d Swift-Hohenberg equation (Automatic)","text":"function cb(x,f,J,res,it,itl,optN; kwargs...)\n\t_x = get(kwargs, :z0, nothing)\n\tfromNewton = get(kwargs, :fromNewton, false)\n\tif ~fromNewton\n\t\t# if the residual is too large or if the parameter jump\n\t\t# is too big, abord continuation step\n\t\treturn norm(_x.u - x) < 20.5 && abs(_x.p - kwargs[:p]) < 0.05\n\tend\n\ttrue\nend","category":"page"},{"location":"Swift-Hohenberg1d/","page":"1d Swift-Hohenberg equation (Automatic)","title":"1d Swift-Hohenberg equation (Automatic)","text":"Next, we specify the arguments to be used during continuation, such as plotting function, tangent predictors, callbacks...","category":"page"},{"location":"Swift-Hohenberg1d/","page":"1d Swift-Hohenberg equation (Automatic)","title":"1d Swift-Hohenberg equation (Automatic)","text":"args = (verbosity = 3,\n\tplot = true,\n\tlinearAlgo  = MatrixBLS(),\n\tplotSolution = (x, p;kwargs...)->(plot!(X, x; ylabel=\"solution\", label=\"\", kwargs...)),\n\tcallbackN = cb, halfbranch = true,\n\t)","category":"page"},{"location":"Swift-Hohenberg1d/","page":"1d Swift-Hohenberg equation (Automatic)","title":"1d Swift-Hohenberg equation (Automatic)","text":"Depending on the level of recursion in the bifurcation diagram, we change a bit the options as follows","category":"page"},{"location":"Swift-Hohenberg1d/","page":"1d Swift-Hohenberg equation (Automatic)","title":"1d Swift-Hohenberg equation (Automatic)","text":"function optrec(x, p, l; opt = opts)\n\tlevel =  l\n\tif level <= 2\n\t\treturn setproperties(opt; maxSteps = 300, detectBifurcation = 3, \n\t\t\tnev = Nx, detectLoop = false)\n\telse\n\t\treturn setproperties(opt; maxSteps = 250, detectBifurcation = 3, \n\t\t\tnev = Nx, detectLoop = true)\n\tend\nend","category":"page"},{"location":"Swift-Hohenberg1d/","page":"1d Swift-Hohenberg equation (Automatic)","title":"1d Swift-Hohenberg equation (Automatic)","text":"tip: Tuning\nThe function optrec modifies the continuation options opts as function of the branching level. It can be used to alter the continuation parameters inside the bifurcation diagram.","category":"page"},{"location":"Swift-Hohenberg1d/","page":"1d Swift-Hohenberg equation (Automatic)","title":"1d Swift-Hohenberg equation (Automatic)","text":"We are now in position to compute the bifurcation diagram","category":"page"},{"location":"Swift-Hohenberg1d/","page":"1d Swift-Hohenberg equation (Automatic)","title":"1d Swift-Hohenberg equation (Automatic)","text":"# initial condition\nsol0 = zeros(Nx)\n\ndiagram = @time bifurcationdiagram(jet..., \n\tsol0, (@set parSH.l = -1.), (@lens _.l), \n\t# here we specify a maximum branching level of 4\n\t4, optrec; args...)","category":"page"},{"location":"Swift-Hohenberg1d/","page":"1d Swift-Hohenberg equation (Automatic)","title":"1d Swift-Hohenberg equation (Automatic)","text":"After ~700s, you can plot the result  ","category":"page"},{"location":"Swift-Hohenberg1d/","page":"1d Swift-Hohenberg equation (Automatic)","title":"1d Swift-Hohenberg equation (Automatic)","text":"plot(diagram;  plotfold = false,  \n\tmarkersize = 2, putspecialptlegend = false, xlims=(-1,1))\ntitle!(\"#branches = $(size(diagram))\")","category":"page"},{"location":"Swift-Hohenberg1d/","page":"1d Swift-Hohenberg equation (Automatic)","title":"1d Swift-Hohenberg equation (Automatic)","text":"(Image: )","category":"page"},{"location":"Swift-Hohenberg1d/","page":"1d Swift-Hohenberg equation (Automatic)","title":"1d Swift-Hohenberg equation (Automatic)","text":"Et voilà!","category":"page"},{"location":"Swift-Hohenberg1d/#Exploration-of-the-diagram","page":"1d Swift-Hohenberg equation (Automatic)","title":"Exploration of the diagram","text":"","category":"section"},{"location":"Swift-Hohenberg1d/","page":"1d Swift-Hohenberg equation (Automatic)","title":"1d Swift-Hohenberg equation (Automatic)","text":"The bifurcation diagram diagram is stored as tree:","category":"page"},{"location":"Swift-Hohenberg1d/","page":"1d Swift-Hohenberg equation (Automatic)","title":"1d Swift-Hohenberg equation (Automatic)","text":"julia> diagram\nBifurcation diagram. Root branch (level 1) has 5 children and is such that:\nBranch number of points: 146\nBranch of Equilibrium\nParameters l from -1.0 to 1.0\nSpecial points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1,    bp at l ≈ +0.00729225 ∈ (+0.00728880, +0.00729225), |δp|=3e-06, [converged], δ = ( 1,  0), step =  72, eigenelements in eig[ 73], ind_ev =   1\n- #  2,    bp at l ≈ +0.15169672 ∈ (+0.15158623, +0.15169672), |δp|=1e-04, [converged], δ = ( 1,  0), step =  83, eigenelements in eig[ 84], ind_ev =   2\n- #  3,    bp at l ≈ +0.48386427 ∈ (+0.48385737, +0.48386427), |δp|=7e-06, [converged], δ = ( 1,  0), step = 107, eigenelements in eig[108], ind_ev =   3\n- #  4,    bp at l ≈ +0.53115204 ∈ (+0.53071010, +0.53115204), |δp|=4e-04, [converged], δ = ( 1,  0), step = 111, eigenelements in eig[112], ind_ev =   4\n- #  5,    bp at l ≈ +0.86889220 ∈ (+0.86887839, +0.86889220), |δp|=1e-05, [converged], δ = ( 1,  0), step = 135, eigenelements in eig[136], ind_ev =   5","category":"page"},{"location":"Swift-Hohenberg1d/","page":"1d Swift-Hohenberg equation (Automatic)","title":"1d Swift-Hohenberg equation (Automatic)","text":"We can access the different branches with BK.getBranch(diagram, (1,)). Alternatively, you can plot a specific branch:","category":"page"},{"location":"Swift-Hohenberg1d/","page":"1d Swift-Hohenberg equation (Automatic)","title":"1d Swift-Hohenberg equation (Automatic)","text":"\tplot(diagram; code = (1,), plotfold = false,  markersize = 2, putspecialptlegend = false, xlims=(-1,1))","category":"page"},{"location":"Swift-Hohenberg1d/","page":"1d Swift-Hohenberg equation (Automatic)","title":"1d Swift-Hohenberg equation (Automatic)","text":"(Image: )","category":"page"},{"location":"tutorials2b/#d-Swift-Hohenberg-equation-(non-local)-on-the-GPU,-periodic-BC-(Advanced)","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"","category":"section"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"Pages = [\"tutorials2b.md\"]\nDepth = 3","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"Here we give an example where the continuation can be done entirely on the GPU, e.g. on a single V100 NIVDIA.","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"We choose the 2d Swift-Hohenberg as an example and consider a larger grid. See 2d Swift-Hohenberg equation: snaking, Finite Differences for more details. Solving the sparse linear problem in v","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"-(I+Delta)^2 v+(l +2nu u-3u^2)v = rhs","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"with a direct solver becomes prohibitive. Looking for an iterative method, the conditioning of the jacobian is not good enough to have fast convergence, mainly because of the Laplacian operator. However, the above problem is equivalent to:","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"-v + L cdot (d cdot v) = Lcdot rhs","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"where","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"L = ((I+Delta)^2 + I)^-1","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"is very well conditioned and","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"d = l+1+2nu v-3v^2","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"Hence, to solve the previous equation, only a few GMRES iterations are required.","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"In effect, the preconditioned PDE is an example of nonlocal problem.","category":"page"},{"location":"tutorials2b/#Linear-Algebra-on-the-GPU","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"Linear Algebra on the GPU","text":"","category":"section"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"We plan to use KrylovKit on the GPU. We define the following types so it is easier to switch to Float32 for example:","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"using Revise, CUDA\n\n# this disable slow operations but errors if you use one of them\nCUDA.allowscalar(false)\n\n# type used for the arrays, can be Float32 is GPU requires it\nTY = Float64\n\n# put the AF = Array{TY} instead to make the code on the CPU\nAF = CuArray{TY}","category":"page"},{"location":"tutorials2b/#Computing-the-inverse-of-the-differential-operator","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"Computing the inverse of the differential operator","text":"","category":"section"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"The issue now is to compute L but this is easy using Fourier transforms.","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"Hence, that's why we slightly modify the previous Example by considering periodic boundary conditions. Let us now show how to compute L. Although the code looks quite technical, it is based on two facts. First, the Fourier transform symbol associated to L is","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"l_1 = 1+(1-k_x^2-k_y^2)^2","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"which is pre-computed in the composite type SHLinearOp. Then, the effect of L on u is as simple as real.(ifft( l1 .* fft(u) )) and the inverse L\\u is real.(ifft( fft(u) ./ l1 )). However, in order to save memory on the GPU, we use inplace FFTs to reduce temporaries which explains the following code.","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"using AbstractFFTs, FFTW, KrylovKit, Setfield, Parameters\nusing BifurcationKit, LinearAlgebra, Plots\nconst BK = BifurcationKit\n\n# the following struct encodes the operator L1\n# Making the linear operator a subtype of BK.AbstractLinearSolver is handy as it will be used\n# in the Newton iterations.\nstruct SHLinearOp{Treal, Tcomp, Tl1, Tplan, Tiplan} <: BK.AbstractLinearSolver\n\ttmp_real::Treal         # temporary\n\ttmp_complex::Tcomp      # temporary\n\tl1::Tl1\n\tfftplan::Tplan\n\tifftplan::Tiplan\nend\n\n# this is a constructor for the above struct\nfunction SHLinearOp(Nx, lx, Ny, ly; AF = Array{TY})\n\t# AF is a type, it could be CuArray{TY} to run the following on GPU\n\tk1 = vcat(collect(0:Nx/2), collect(Nx/2+1:Nx-1) .- Nx)\n\tk2 = vcat(collect(0:Ny/2), collect(Ny/2+1:Ny-1) .- Ny)\n\td2 = [(1-(pi/lx * kx)^2 - (pi/ly * ky)^2)^2 + 1. for kx in k1, ky in k2]\n\ttmpc = Complex.(AF(zeros(Nx, Ny)))\n\treturn SHLinearOp(AF(zeros(Nx, Ny)), tmpc, AF(d2), plan_fft!(tmpc), plan_ifft!(tmpc))\nend\n\nimport Base: *, \\\n\n# generic function to apply operator op to u\nfunction apply(c::SHLinearOp, u, multiplier, op = *)\n\tc.tmp_complex .= Complex.(u)\n\tc.fftplan * c.tmp_complex\n\tc.tmp_complex .= op.(c.tmp_complex, multiplier)\n\tc.ifftplan * c.tmp_complex\n\tc.tmp_real .= real.(c.tmp_complex)\n\treturn copy(c.tmp_real)\nend\n\n# action of L\n*(c::SHLinearOp, u) = apply(c, u, c.l1)\n\n# inverse of L\n\\(c::SHLinearOp, u) = apply(c, u, c.l1, /)","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"Before applying a Newton solver, we need to tell how to solve the linear equation arising in the Newton Algorithm.","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"# inverse of the jacobian of the PDE\nfunction (sh::SHLinearOp)(J, rhs; shift = 0., tol =  1e-9)\n\tu, l, ν = J\n\tudiag = l .+ 1 .+ 2ν .* u .- 3 .* u.^2 .- shift\n\tres, info = KrylovKit.linsolve( du -> -du .+ sh \\ (udiag .* du), sh \\ rhs, \n\ttol = tol, maxiter = 6)\n\treturn res, true, info.numops\nend","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"Now that we have our operator L, we can encode our functional:","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"function F_shfft(u, p)\n\t@unpack l, ν, L = p\n\treturn -(L * u) .+ ((l+1) .* u .+ ν .* u.^2 .- u.^3)\nend","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"Let us now show how to build our operator L and an initial guess sol0 using the above defined structures.","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"using LinearAlgebra, Plots\n\n# to simplify plotting of the solution\nplotsol(x; k...) = heatmap(reshape(Array(x), Nx, Ny)'; color=:viridis, k...)\nplotsol!(x; k...) = heatmap!(reshape(Array(x), Nx, Ny)'; color=:viridis, k...)\nnorminf(x) = maximum(abs.(x))\n\n# norm compatible with CUDA\nnorminf(x) = maximum(abs.(x))\n\nNx = 2^10\nNy = 2^10\nlx = 8pi * 2\nly = 2*2pi/sqrt(3) * 2\n\nX = -lx .+ 2lx/(Nx) * collect(0:Nx-1)\nY = -ly .+ 2ly/(Ny) * collect(0:Ny-1)\n\nsol0 = [(cos(x) .+ cos(x/2) * cos(sqrt(3) * y/2) ) for x in X, y in Y]\n\t\tsol0 .= sol0 .- minimum(vec(sol0))\n\t\tsol0 ./= maximum(vec(sol0))\n\t\tsol0 = sol0 .- 0.25\n\t\tsol0 .*= 1.7\n\nL = SHLinearOp(Nx, lx, Ny, ly, AF = AF)\nJ_shfft(u, p) = (u, p.l, p.ν)\n# parameters of the PDE\npar = (l = -0.15, ν = 1.3, L = L)","category":"page"},{"location":"tutorials2b/#Newton-iterations-and-deflation","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"Newton iterations and deflation","text":"","category":"section"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"We are now ready to perform Newton iterations:","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"opt_new = NewtonPar(verbose = true, tol = 1e-6, maxIter = 100, linsolver = L)\n\tsol_hexa, hist, flag = @time newton(\n\t\tF_shfft, J_shfft,\n\t\tAF(sol0), par,\n\t\topt_new, normN = norminf)\n\t\t\t\t\n\tprintln(\"--> norm(sol) = \", maximum(abs.(sol_hexa)))\n\tplotsol(sol_hexa)","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"You should see this:","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"Newton Iterations      f(x)      Linear Iterations\n\n          0          3.3758e-01             0\n          1          8.0152e+01            12\n          2          2.3716e+01            27\n          3          6.7353e+00            22\n          4          1.9498e+00            17\n          5          5.5893e-01            14\n          6          1.0998e-01            12\n          7          1.1381e-02            11\n          8          1.6393e-04            11\n          9          6.7459e-08            10\n  0.317790 seconds (42.67 k allocations: 1.256 MiB)\n--> norm(sol) = 1.26017611779702","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"Note that this is about the 10x faster than Example 2 but for a problem almost 100x larger! (On a V100 GPU)","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"The solution is:","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"(Image: )","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"We can also use the deflation technique (see DeflationOperator and DeflatedProblem for more information) on the GPU as follows","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"deflationOp = DeflationOperator(2.0, dot, 1.0, [sol_hexa])\n\nopt_new = @set opt_new.maxIter = 250\noutdef, _, flag, _ = @time newton(\n\t\tF_shfft, J_shfft,\n\t\t0.4 .* sol_hexa .* AF([exp(-1(x+0lx)^2/25) for x in X, y in Y]),\n\t\tpar, opt_new, deflationOp, normN = x-> maximum(abs.(x)))\n\tprintln(\"--> norm(sol) = \", norm(outdef))\n\tplotsol(outdef) |> display\n\tflag && push!(deflationOp, outdef)","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"and get:","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"(Image: )","category":"page"},{"location":"tutorials2b/#Computation-of-the-branches","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"Computation of the branches","text":"","category":"section"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"Finally, we can perform continuation of the branches on the GPU:","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"opts_cont = ContinuationPar(dsmin = 0.001, dsmax = 0.007, ds= -0.005, \n\tpMax = 0., pMin = -1.0, theta = 0.5, plotEveryStep = 5, \n\tnewtonOptions = setproperties(opt_new; tol = 1e-6, maxIter = 15), maxSteps = 100)\n\n\tbr, = @time continuation(F_shfft, J_shfft,\n\t\tdeflationOp[1], par, (@lens _.l), opts_cont;\n\t\tplot = true, verbosity = 3,\n\t\tplotSolution = (x, p; kwargs...)->plotsol!(x; color=:viridis, kwargs...), \n\t\tnormC = x -> maximum(abs.(x))\n\t\t)","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"We did not detail how to compute the eigenvalues on the GPU and detect the bifurcations. It is based on a simple Shift-Invert strategy, please look at examples/SH2d-fronts-cuda.jl.","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"(Image: )","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"We have the following information about the branch of hexagons","category":"page"},{"location":"tutorials2b/","page":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","title":"2d Swift-Hohenberg equation (non-local) on the GPU, periodic BC (Advanced)","text":"julia> br\nBranch number of points: 67\nBranch of Equilibrium\nBifurcation points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1,    nd at p ≈ -0.21522461 ∈ (-0.21528614, -0.21522461), |δp|=6e-05, [converged], δ = ( 3,  0), step =  24, eigenelements in eig[ 25], ind_ev =   3\n- #  2,    nd at p ≈ -0.21469007 ∈ (-0.21479652, -0.21469007), |δp|=1e-04, [converged], δ = ( 2,  0), step =  25, eigenelements in eig[ 26], ind_ev =   5\n- #  3,    nd at p ≈ -0.21216919 ∈ (-0.21264341, -0.21216919), |δp|=5e-04, [converged], δ = ( 2,  0), step =  27, eigenelements in eig[ 28], ind_ev =   7\n- #  4,    nd at p ≈ -0.21052576 ∈ (-0.21110899, -0.21052576), |δp|=6e-04, [converged], δ = ( 2,  0), step =  28, eigenelements in eig[ 29], ind_ev =   9\n- #  5,    nd at p ≈ -0.20630678 ∈ (-0.21052576, -0.20630678), |δp|=4e-03, [converged], δ = ( 8,  0), step =  29, eigenelements in eig[ 30], ind_ev =  17\n- #  6,    nd at p ≈ -0.19896508 ∈ (-0.19897308, -0.19896508), |δp|=8e-06, [converged], δ = ( 6,  0), step =  30, eigenelements in eig[ 31], ind_ev =  23\n- #  7,    nd at p ≈ -0.18621673 ∈ (-0.18748234, -0.18621673), |δp|=1e-03, [converged], δ = ( 2,  0), step =  33, eigenelements in eig[ 34], ind_ev =  25\n- #  8,    nd at p ≈ -0.17258147 ∈ (-0.18096574, -0.17258147), |δp|=8e-03, [converged], δ = ( 4,  0), step =  35, eigenelements in eig[ 36], ind_ev =  29\n- #  9,    nd at p ≈ -0.14951737 ∈ (-0.15113148, -0.14951737), |δp|=2e-03, [converged], δ = (-4,  0), step =  39, eigenelements in eig[ 40], ind_ev =  29\n- # 10,    nd at p ≈ -0.14047758 ∈ (-0.14130979, -0.14047758), |δp|=8e-04, [converged], δ = (-2,  0), step =  41, eigenelements in eig[ 42], ind_ev =  25\n- # 11,    nd at p ≈ -0.11304882 ∈ (-0.11315916, -0.11304882), |δp|=1e-04, [converged], δ = (-4,  0), step =  45, eigenelements in eig[ 46], ind_ev =  23\n- # 12,    nd at p ≈ -0.09074623 ∈ (-0.09085968, -0.09074623), |δp|=1e-04, [converged], δ = (-6,  0), step =  49, eigenelements in eig[ 50], ind_ev =  19\n- # 13,    nd at p ≈ -0.07062574 ∈ (-0.07246519, -0.07062574), |δp|=2e-03, [converged], δ = (-4,  0), step =  52, eigenelements in eig[ 53], ind_ev =  13\n- # 14,    nd at p ≈ -0.06235903 ∈ (-0.06238787, -0.06235903), |δp|=3e-05, [converged], δ = (-2,  0), step =  54, eigenelements in eig[ 55], ind_ev =   9\n- # 15,    nd at p ≈ -0.05358077 ∈ (-0.05404312, -0.05358077), |δp|=5e-04, [converged], δ = (-2,  0), step =  56, eigenelements in eig[ 57], ind_ev =   7\n- # 16,    nd at p ≈ -0.02494422 ∈ (-0.02586444, -0.02494422), |δp|=9e-04, [converged], δ = (-2,  0), step =  60, eigenelements in eig[ 61], ind_ev =   5\n- # 17,    nd at p ≈ -0.00484022 ∈ (-0.00665356, -0.00484022), |δp|=2e-03, [converged], δ = (-2,  0), step =  63, eigenelements in eig[ 64], ind_ev =   3\n- # 18,    nd at p ≈ +0.00057801 ∈ (-0.00122418, +0.00057801), |δp|=2e-03, [converged], δ = ( 5,  0), step =  64, eigenelements in eig[ 65], ind_ev =   6\n- # 19,    nd at p ≈ +0.00320921 ∈ (+0.00141327, +0.00320921), |δp|=2e-03, [converged], δ = (10,  0), step =  65, eigenelements in eig[ 66], ind_ev =  16\nFold points:\n- #  1, fold at p ≈ -0.21528694 ∈ (-0.21528694, -0.21528694), |δp|=-1e+00, [    guess], δ = ( 0,  0), step =  24, eigenelements in eig[ 24], ind_ev =   0","category":"page"},{"location":"DeflatedContinuation/#Deflated-Continuation","page":"Deflated Continuation","title":"Deflated Continuation","text":"","category":"section"},{"location":"DeflatedContinuation/","page":"Deflated Continuation","title":"Deflated Continuation","text":"unknown: References\nFarrell, Patrick E., Casper H. L. Beentjes, and Ásgeir Birkisson. The Computation of Disconnected Bifurcation Diagrams. ArXiv:1603.00809 [Math], March 2, 2016. http://arxiv.org/abs/1603.00809.","category":"page"},{"location":"DeflatedContinuation/","page":"Deflated Continuation","title":"Deflated Continuation","text":"Deflated continuation allows to compute branches of solutions to the equation F(xp)=0. It is based on the Deflated Newton (see Deflated problems).","category":"page"},{"location":"DeflatedContinuation/","page":"Deflated Continuation","title":"Deflated Continuation","text":"However, unlike the regular continuation method, deflated continuation allows to compute disconnected bifurcation diagrams, something that is impossible to our Automatic Bifurcation diagram computation method.","category":"page"},{"location":"DeflatedContinuation/","page":"Deflated Continuation","title":"Deflated Continuation","text":"You can find an example of use in the Deflated Continuation in the Carrier Problem. We reproduce below the result of the computation:","category":"page"},{"location":"DeflatedContinuation/","page":"Deflated Continuation","title":"Deflated Continuation","text":"(Image: )","category":"page"},{"location":"DeflatedContinuation/#Algorithm","page":"Deflated Continuation","title":"Algorithm","text":"","category":"section"},{"location":"DeflatedContinuation/","page":"Deflated Continuation","title":"Deflated Continuation","text":"Input: Initial parameter value λmin.\nInput: Final parameter value λmax > λmin. Input: Step size ∆λ > 0.\nInput: Nonlinear residual f(u,λ).\nInput: Deflation operator M(u; u∗).\nInput: Initial solutions S(λmin) to f(·,λmin).\nλ ← λmin\nwhile λ < λmax do\n\tF(·) ← f(·,λ+∆λ) \t\t\t\t\t\t# Fix the value of λ to solve for.\n\tS(λ+∆λ) ← ∅\n\tfor u0 ∈ S(λ) do \t\t\t\t\t\t# Continue known branches.\n\t\tapply Newton’s method to F from initial guess u0.\n\t\tif solution u∗ found then\n\t\t\tS(λ + ∆λ) ← S(λ + ∆λ) ∪ {u∗}  # Record success\n\t\t\tF(·) ← M(·;u∗)F(·)\t\t\t  # Deflate solution\n\t\t\t\n\tfor u0 ∈ S(λ) do \t\t\t\t\t  # Seek new branches.\n\t\tsuccess ← true \n\t\twhile success do\n\t\t\tapply Newton’s method to F from initial guess u0.\n\t\t\tif solution u∗ found then\t\t # New branch found\n\t\t\t\tS(λ + ∆λ) ← S(λ + ∆λ) ∪ {u∗} # Record success\n\t\t\t\tF(·) ← M(·;u∗)F(·)\t\t     # Deflate solution\n\t\telse\n\t\t\tsuccess ← false \n\tλ←λ+∆λ\nreturn S","category":"page"},{"location":"DeflatedContinuation/#Tips","page":"Deflated Continuation","title":"Tips","text":"","category":"section"},{"location":"DeflatedContinuation/","page":"Deflated Continuation","title":"Deflated Continuation","text":"The following piece of information is valuable in order to get the algorithm working in various conditions (see also here) especially for small systems (e.g. dim<20):","category":"page"},{"location":"DeflatedContinuation/","page":"Deflated Continuation","title":"Deflated Continuation","text":"newton is quite good and it is convenient to limit it otherwise it will be able to bypass the deflation. For example, you can use maxIter = 10 in NewtonPar \ntry to limit the newton residual by using the argument callbackN = (x, f, J, res, iteration, itlinear, options; kwargs...) -> res < 1e7. This will likely remove the occurence of ┌ Error: Same solution found for identical parameter value!!\nfinally, you can try some agressive shift (here 0.01 in the deflation operator, like DeflationOperator(2.0, dot, 0.01, [sol]) but use it wisely.","category":"page"},{"location":"DeflatedContinuation/#Basic-example","page":"Deflated Continuation","title":"Basic example","text":"","category":"section"},{"location":"DeflatedContinuation/","page":"Deflated Continuation","title":"Deflated Continuation","text":"We show a quick and simple example of use. Note in particular that the algoritm is able to find the disconnected branch. The starting points are marked with crosses","category":"page"},{"location":"DeflatedContinuation/","page":"Deflated Continuation","title":"Deflated Continuation","text":"using BifurcationKit, LinearAlgebra, Setfield, SparseArrays, Plots\nconst BK = BifurcationKit\n\nk = 2\nN = 1\nF = (x, p) -> p .* x .+ x.^(k+1)/(k+1) .+ 0.01\nJac_m = (x, p) -> diagm(0 => p .+ x.^k)\n\nopts = BK.ContinuationPar(dsmax = 0.051, dsmin = 1e-3, ds=0.001, maxSteps = 140, pMin = -3., saveSolEveryStep = 0, newtonOptions = NewtonPar(tol = 1e-8, verbose = false), saveEigenvectors = false)\n\nbrdc, = continuation(F,Jac_m, 0.5, (@lens _),\n\tContinuationPar(opts, ds = -0.001, maxSteps = 800, newtonOptions = NewtonPar(verbose = false, maxIter = 6), plotEveryStep = 40),\n\tDeflationOperator(2.0, dot, .001, [[0.]]); plot=true, verbosity = 0,\n\tperturbSolution = (x,p,id) -> (x  .+ 0.1 .* rand(length(x))),\n\tcallbackN = (x, f, J, res, iteration, itlinear, options; kwargs...) -> res <1e3)\nplot(brdc...)","category":"page"},{"location":"Predictors/#Predictors-Correctors","page":"Predictors / correctors","title":"Predictors - Correctors","text":"","category":"section"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"As explained in the docs of continuation, the continuation method works with the following pattern (see [Allgower1990]):","category":"page"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"compute tangent\ncall predictor (based on tangent, mostly)\ncall corrector","category":"page"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"[Allgower1990]: Allgower and Georg, Numerical Continuation Methods, 1990","category":"page"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"There are several couples predictor-tangent/corrector which can be used in BifurcationKit.jl as we now explain. The tangent computation is formally included in the predictor whereas it is a distinct function in the code.","category":"page"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"info: Corrector\nNote that setting the tangent predictor (for example) tangentAlgo = SecantPred() also sets the corresponding corrector: it selects the couple predictor-corrector. You don't have (in fact cannot) set them independently.","category":"page"},{"location":"Predictors/#.-Natural,-zeroth-order-predictor","page":"Predictors / correctors","title":"1. Natural, zeroth order predictor","text":"","category":"section"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"This is the dumbest predictor based on the formula (x_1p_1) = (x_0 p_0 + ds) with Newton corrector ; it fails at Turning points. This is set by the option tangentAlgo = NaturalPred() in continuation. For matrix based jacobian, it is not faster than the pseudo-arclength predictor because the factorisation of the jacobian is catched. For Matrix-free methods, this predictor can be faster than the following ones until it hits a Turning point.","category":"page"},{"location":"Predictors/#.-First-order-predictor","page":"Predictors / correctors","title":"2. First order predictor","text":"","category":"section"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"This predictor is based on a computation of the tangent tau = (dxdp) to the curve of solutions, it is given by (x_1p_1) = (x_0p_0) + dscdot tau. This predictor passes Turning points when used with PALC Newton corrector. BifurcationKit.jl provides two ways to compute the tangent (dx dp). ","category":"page"},{"location":"Predictors/#a.-Secant-predictor","page":"Predictors / correctors","title":"2a. Secant predictor","text":"","category":"section"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"This predictor is called secant and is parametrized by the option tangentAlgo = SecantPred().  It is computed by (dx dp) = (z_1 p_1) - (z_0 p_0) and normalized by the norm (x p)^2_theta = fracthetalength(x) langle xxrangle + (1 - theta)cdot p^2. ","category":"page"},{"location":"Predictors/#b.-Bordered-predictor","page":"Predictors / correctors","title":"2b. Bordered predictor","text":"","category":"section"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"This predictor departs from the previous one in the way the tangent is estimated. It computes (dx dp) by solving solving the bordered linear system beginbmatrix F_x  F_p\t fracthetalength(x)dx_0  (1-theta)dp_0endbmatrixbeginbmatrixdx   dpendbmatrix =beginbmatrix0  1endbmatrix.","category":"page"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"it is set by the option tangentAlgo = BorderedPred().","category":"page"},{"location":"Predictors/#.-Polynomial-predictor","page":"Predictors / correctors","title":"3. Polynomial predictor","text":"","category":"section"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"The polynomial predictor is based on a fit (least square regression) of an nth-order polynomial P on the last k solution vectors, where n  k. The arclength s is used for the polynomial which then fits the solution (x_ip_is_i) as P(s_i)approx (x_ip_i). To keep s in suitable range (see [Waugh]), we rescale it as sto fracs-bar ssigma where sigma is the standard deviation of the s_i.","category":"page"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"This predictor is parametrized by tangentAlgo = PolynomialPred(n, k, v0, algo = SecantPred() ) where algo is the tangent predictor used only for the first k solutions before the polynomial predictor is operational and v0 is an example of guess.","category":"page"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"[Waugh]: Waugh, Illingworth, and Juniper, “Matrix-Free Continuation of Limit Cycles for Bifurcation Analysis of Large Thermoacoustic Systems.”","category":"page"},{"location":"Predictors/#.-Multiple-predictor-(aka-pmcont-in-pde2path)","page":"Predictors / correctors","title":"4. Multiple predictor (aka pmcont in pde2path)","text":"","category":"section"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"The predictor is designed [Uecker2014] to avoid spurious branch switching and pass singular points especially in PDE where branch point density can be quite high. It is based on the use of many predictors with increasing \"jumps\" (x_ip_i) = (x_0p_0) + icdot dscdot tau ileq nb and use a corrector (PALC Newton) with the following twist. The criterion is that in each Newton step, the residual has to decrease by a factor 0alpha1:","category":"page"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":" F(u_np_n)leq alpha  F(u_n-1p_n-1) ","category":"page"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"otherwise the corrector fails. The solution that is returned is the one for the highest i. We refer to [Uecker2014] for an exposition of the step size adaption strategy.","category":"page"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"This predictor is parametrized by tangentAlgo = MultiplePred(α, nb, τ, algo = SecantPred() ) where τ is an initial tangent vector (used to set the types) and algo is a predictor.","category":"page"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"[Uecker2014]: 1.Uecker, H. pde2path - A Matlab Package for Continuation and Bifurcation in 2D Elliptic Systems. NMTMA 7, 58–106 (2014).","category":"page"},{"location":"iterator/#Iterator-Interface","page":"Iterator Interface","title":"Iterator Interface","text":"","category":"section"},{"location":"iterator/","page":"Iterator Interface","title":"Iterator Interface","text":"The iterator interface gives the possibility of stepping through the numerical steps of the continuation procedure. It thus allows to inject custom monitoring function (saving, plotting, bifurcation detection, ...) at will and during the continuation run. In short, it allows to completely re-write the continuation algorithm as one sees fit and this, in a straightforward manner.","category":"page"},{"location":"iterator/","page":"Iterator Interface","title":"Iterator Interface","text":"The general method continuation is built upon this iterator interface and we refer to the source code for a complete example of use.","category":"page"},{"location":"iterator/","page":"Iterator Interface","title":"Iterator Interface","text":"The iterator provided below does not compute eigenvalues nor perform bifurcations detection. ","category":"page"},{"location":"iterator/#Initialization","page":"Iterator Interface","title":"Initialization","text":"","category":"section"},{"location":"iterator/","page":"Iterator Interface","title":"Iterator Interface","text":"More information about iterators can be found on the page of julialang.","category":"page"},{"location":"iterator/","page":"Iterator Interface","title":"Iterator Interface","text":"The interface is set by defining an iterator, pretty much in the same way one calls continuation:","category":"page"},{"location":"iterator/","page":"Iterator Interface","title":"Iterator Interface","text":"iter = ContIterable(F, J, x0, p0, lens::Lens, opts; kwargs...)","category":"page"},{"location":"iterator/#Stepping","page":"Iterator Interface","title":"Stepping","text":"","category":"section"},{"location":"iterator/","page":"Iterator Interface","title":"Iterator Interface","text":"Once an iterator iter has been defined, one can step through the numerical continuation using a for loop:","category":"page"},{"location":"iterator/","page":"Iterator Interface","title":"Iterator Interface","text":"for state in iter\n\tprintln(\"Continuation step = \", state.step)\nend","category":"page"},{"location":"iterator/","page":"Iterator Interface","title":"Iterator Interface","text":"The state::ContState has the following description. It is a mutable object which holds the current state of the continuation procedure from which one can step to the next state.","category":"page"},{"location":"iterator/","page":"Iterator Interface","title":"Iterator Interface","text":"The for loop stops when done(iter, state) returns false. The condition which is implemented is basically that the number of iterations should be smaller than maxIter, that the parameters should be in (pMin, pMax)...","category":"page"},{"location":"iterator/","page":"Iterator Interface","title":"Iterator Interface","text":"ContState","category":"page"},{"location":"iterator/#BifurcationKit.ContState","page":"Iterator Interface","title":"BifurcationKit.ContState","text":"state = ContState(ds = 1e-4,...)\n\nReturns a variable containing the state of the continuation procedure. The fields are meant to change during the continuation procedure.\n\nArguments\n\nz_pred current solution on the branch\ntau tangent predictor\nz_old previous solution\nisconverged Boolean for newton correction\nitnewton Number of newton iteration (in corrector)\nstep current continuation step\nds step size\ntheta theta parameter for constraint equation in PALC\nstopcontinuation Boolean to stop continuation\n\nUseful functions\n\ncopy(state) returns a copy of state\ngetSolution(state) returns the current solution (x, p)\ngetx(state) returns the x component of the current solution\ngetp(state) returns the p component of the current solution\ngetpreviousp(state) returns the p component of the previous solution\nisStable(state) whether the current state is stable\n\n\n\n\n\n","category":"type"},{"location":"iterator/","page":"Iterator Interface","title":"Iterator Interface","text":"tip: continuation\nYou can also call continuation(iter) to have access to the regular continuation method used throughout the tutorials.","category":"page"},{"location":"iterator/#Basic-example","page":"Iterator Interface","title":"Basic example","text":"","category":"section"},{"location":"iterator/","page":"Iterator Interface","title":"Iterator Interface","text":"We show a quick and simple example of use. Note that it is not very optimized because of the use of global variables.","category":"page"},{"location":"iterator/","page":"Iterator Interface","title":"Iterator Interface","text":"using BifurcationKit, SparseArrays, LinearAlgebra, Plots, Setfield\nconst BK = BifurcationKit\n\nk = 2\n\n# functional we want to study\nF = (x, p) -> (@. p + x - x^(k+1)/(k+1))\n\n# Jacobian for the fonctional\nJac_m = (x, p) -> diagm(0 => 1  .- x.^k)\n\n\n# parameters for the continuation\nopts = ContinuationPar(dsmax = 0.1, dsmin = 1e-3, ds = -0.001, maxSteps = 130, pMin = -3., pMax = 3., saveSolEveryStep = 0, newtonOptions = NewtonPar(tol = 1e-8, verbose = true))\n\n# we define an iterator to hold the continuation routine\niter = BK.ContIterable(F, Jac_m, [0.8], 1., (@lens _), opts; verbosity = 2)\n\nresp = Float64[]\nresx = Float64[]\n\n# this is the PALC algorithm\nfor state in iter\n\t# we save the current solution on the branch\n\tpush!(resx, getx(state)[1])\n\tpush!(resp, getp(state))\nend\n\n# plot the result\nplot(resp, resx; label = \"\", xlabel = \"p\")","category":"page"},{"location":"iterator/#Additional-information","page":"Iterator Interface","title":"Additional information","text":"","category":"section"},{"location":"iterator/","page":"Iterator Interface","title":"Iterator Interface","text":"If you want to customize the iterator to your needs, perhaps the best source of inspiration is the code of the function continuation!(it::ContIterable, state::ContState, contRes::ContResult) where the iterator is used at its fullest. You will see how the eigen-elements and the stability are computed, how bifurcations are detected and how results are saved.","category":"page"},{"location":"#BifurcationKit.jl","page":"Home","title":"BifurcationKit.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This Julia package aims at performing automatic bifurcation analysis of large dimensional equations F(u,λ)=0 where λ∈ℝ.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"It incorporates continuation algorithms (PALC, deflated continuation, ...) which provide a predictor (u_1p_1) from a known solution (u_0p_0). A Newton-Krylov method is then used to correct this predictor and a Matrix-Free eigensolver is used to compute stability and bifurcation points.","category":"page"},{"location":"","page":"Home","title":"Home","text":"By leveraging on the above method, the package can also seek for periodic orbits of Cauchy problems by casting them into an equation F(up)=0 of high dimension. It is by now, one of the only softwares which provides shooting methods AND methods based on finite differences to compute periodic orbits.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The current package focuses on large scale nonlinear problems and multiple hardwares. Hence, the goal is to use Matrix Free methods on GPU (see PDE example and Periodic orbit example) or on a cluster to solve non linear PDE, nonlocal problems, compute sub-manifolds...","category":"page"},{"location":"","page":"Home","title":"Home","text":"One design choice is that we try not to require u to be a subtype of an AbstractArray as this would forbid the use of spectral methods like the one from ApproxFun.jl. For now, our implementation does not allow this for Hopf continuation and computation of periodic orbits. ","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package requires Julia >= v1.3.0 because of the use of methods added to abstract types (see #31916).","category":"page"},{"location":"","page":"Home","title":"Home","text":"To install it, please run","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add BifurcationKit","category":"page"},{"location":"","page":"Home","title":"Home","text":"To install the bleeding edge version, please run","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add BifurcationKit#master","category":"page"},{"location":"#Citing-this-work","page":"Home","title":"Citing this work","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use this package for your work, we ask that you cite the following paper!! Open source development strongly depends on this. It is referenced on HAL-Inria as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{veltz:hal-02902346,\n  TITLE = {{BifurcationKit.jl}},\n  AUTHOR = {Veltz, Romain},\n  URL = {https://hal.archives-ouvertes.fr/hal-02902346},\n  INSTITUTION = {{Inria Sophia-Antipolis}},\n  YEAR = {2020},\n  MONTH = Jul,\n  KEYWORDS = {pseudo-arclength-continuation ; periodic-orbits ; floquet ; gpu ; bifurcation-diagram ; deflation ; newton-krylov},\n  PDF = {https://hal.archives-ouvertes.fr/hal-02902346/file/354c9fb0d148262405609eed2cb7927818706f1f.tar.gz},\n  HAL_ID = {hal-02902346},\n  HAL_VERSION = {v1},\n}","category":"page"},{"location":"#Other-softwares","page":"Home","title":"Other softwares","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are many good softwares already available.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For regular continuation (e.g. in small dimension), most of them are listed on DSWeb. One can mention the venerable AUTO, or also, XPPAUT, MATCONT, PyDSTool and COCO. \nFor large scale problems, there is the versatile and feature full pde2path but also Trilinos, CL_MATCONTL and the python libraries pyNCT and pacopy.\nFor deflated continuation, there is defcont (by the inventor of the algo. P. E. Farrell) and this code by N. M. Evstigneev.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In Julia, we have for now a wrapper to PyDSTools, and also Bifurcations.jl.","category":"page"},{"location":"#A-word-on-performance","page":"Home","title":"A word on performance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The examples which follow have not all been written with the goal of performance but rather simplicity (except maybe 2d Ginzburg-Landau equation (finite differences)). One could surely turn them into more efficient codes. The intricacies of PDEs make the writing of efficient code highly problem dependent and one should take advantage of every particularity of the problem under study.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For example, in the first tutorial on Temperature model (Simplest example), one could use BandedMatrices.jl for the jacobian and an inplace modification when the jacobian is called ; using a composite type would be favored. Porting them to GPU would be another option.","category":"page"},{"location":"#Main-features","page":"Home","title":"Main features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Newton-Krylov solver with generic linear / eigen preconditioned solver. Idem for the arc-length continuation.\nContinuation written as an iterator\nMonitoring user functions along curves computed by continuation, see events\nNewton-Krylov solver with nonlinear deflation and preconditioner. It can be used for branch switching for example.\nDeflated continuation\nBifurcation points are located using a bisection algorithm\nBranch, Fold, Hopf bifurcation point detection of stationary solutions.\nAutomatic branch switching at branch points (whatever the dimension of the kernel)\nAutomatic branch switching at simple Hopf points to periodic orbits\nAutomatic bifurcation diagram computation\nFold / Hopf continuation based on Minimally Augmented formulation, with Matrix Free / Sparse Jacobian.\ndetection of Bogdanov-Takens, Bautin and Cusp bifurcations\nPeriodic orbit computation and continuation using Shooting or Finite Differences.\nBranch, Fold, Neimark-Sacker, Period Doubling bifurcation point detection of periodic orbits.\nComputation and Continuation of Fold of periodic orbits","category":"page"},{"location":"","page":"Home","title":"Home","text":"Custom state means, we can use something else than AbstractArray, for example your own struct.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that you can combine most of the solvers, like use Deflation for Periodic orbit computation or Fold of periodic orbits family.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Features Matrix Free Custom state Tutorial GPU\n(Deflated) Krylov-Newton Yes Yes All Y\nContinuation (Natural, Secant, Tangent, Polynomial) Yes Yes All Y\nDeflated Continuation Yes Yes Link Y\nBranching / Fold / Hopf point detection Yes Yes All / All / Link Y\nFold Point continuation Yes Yes Link, Link Y\nHopf continuation Yes AbstractArray Link \nBranch switching at Branch / Hopf points Yes AbstractArray Link Y\nAutomatic bifurcation diagram computation Yes AbstractArray Link \nPeriodic Orbit (FD) Newton / continuation Yes AbstractVector Link, Link Y\nPeriodic Orbit with Parallel Poincaré / Standard Shooting Newton / continuation Yes AbstractArray Link \nFold, Neimark-Sacker, Period doubling detection Yes AbstractVector Link \nContinuation of Fold of periodic orbits Yes AbstractVector Link Y","category":"page"},{"location":"#Requested-methods-for-Custom-State","page":"Home","title":"Requested methods for Custom State","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Needless to say, if you use regular arrays, you don't need to worry about what follows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We make the same requirements than KrylovKit.jl. Hence, we refer to its docs for more information. We additionally require the following methods to be available:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Base.length(x): it is used in the constraint equation of the pseudo arclength continuation method (see continuation for more details). If length is not available for your \"vector\", define it length(x) = 1 and adjust tuning the parameter theta in ContinuationPar.\nBase.copyto!(dest, in) this is required to reduce the allocations by avoiding too many copies","category":"page"},{"location":"#Citations","page":"Home","title":"Citations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See here","category":"page"},{"location":"tutorialCarrier/#Deflated-Continuation-in-the-Carrier-Problem","page":"Deflated Continuation in the Carrier Problem","title":"Deflated Continuation in the Carrier Problem","text":"","category":"section"},{"location":"tutorialCarrier/","page":"Deflated Continuation in the Carrier Problem","title":"Deflated Continuation in the Carrier Problem","text":"unknown: References\nChapman, S. J., and P. E. Farrell. Analysis of Carrier’s Problem. ArXiv:1609.08842 [Math], September 28, 2016. http://arxiv.org/abs/1609.08842.","category":"page"},{"location":"tutorialCarrier/","page":"Deflated Continuation in the Carrier Problem","title":"Deflated Continuation in the Carrier Problem","text":"In this example, we study the following singular perturbation problem:","category":"page"},{"location":"tutorialCarrier/","page":"Deflated Continuation in the Carrier Problem","title":"Deflated Continuation in the Carrier Problem","text":"epsilon^2 y^prime prime+2left(1-x^2right) y+y^2=1 quad y(-1)=y(1)=0tagE","category":"page"},{"location":"tutorialCarrier/","page":"Deflated Continuation in the Carrier Problem","title":"Deflated Continuation in the Carrier Problem","text":"It is a remarkably difficult problem which present many disconnected branches which are not amenable to the continuation method. We thus use the recently developed deflated continuation method which builds upon the Deflated Newton (see Deflated problems) technics to find solutions which are different from a set of already known solutions.","category":"page"},{"location":"tutorialCarrier/","page":"Deflated Continuation in the Carrier Problem","title":"Deflated Continuation in the Carrier Problem","text":"We start with some import","category":"page"},{"location":"tutorialCarrier/","page":"Deflated Continuation in the Carrier Problem","title":"Deflated Continuation in the Carrier Problem","text":"using Revise\nusing LinearAlgebra, Parameters, Setfield, SparseArrays, BandedMatrices\n\nusing BifurcationKit, Plots\nconst BK = BifurcationKit","category":"page"},{"location":"tutorialCarrier/","page":"Deflated Continuation in the Carrier Problem","title":"Deflated Continuation in the Carrier Problem","text":"and a discretization of the problem","category":"page"},{"location":"tutorialCarrier/","page":"Deflated Continuation in the Carrier Problem","title":"Deflated Continuation in the Carrier Problem","text":"function F_carr(x, p)\n\t@unpack ϵ, X, dx = p\n\tf = similar(x)\n\tn = length(x)\n\tf[1] = x[1]\n\tf[n] = x[n]\n\tfor i=2:n-1\n\t\tf[i] = ϵ^2 * (x[i-1] - 2 * x[i] + x[i+1]) / dx^2 +\n\t\t\t2 * (1 - X[i]^2) * x[i] + x[i]^2-1\n\tend\n\treturn f\nend\n\nfunction Jac_carr(x, p)\n\t@unpack ϵ, X, dx = p\n\tn = length(x)\n\tJ = BandedMatrix{Float64}(undef, (n,n), (1,1))\n\tJ[band(-1)] .= ϵ^2/dx^2    \t\t\t\t\t\t\t\t\t# set the diagonal band\n\tJ[band(1)]  .= ϵ^2/dx^2\t\t\t\t\t\t\t\t\t\t# set the super-diagonal band\n\tJ[band(0)]  .= (-2ϵ^2 /dx^2) .+ 2 * (1 .- X.^2) .+ 2 .* x   # set the second super-diagonal band\n\tJ[1, 1] = 1.0\n\tJ[n, n] = 1.0\n\tJ[1, 2] = 0.0\n\tJ[n, n-1] = 0.0\n\tJ\nend","category":"page"},{"location":"tutorialCarrier/","page":"Deflated Continuation in the Carrier Problem","title":"Deflated Continuation in the Carrier Problem","text":"We can now use Newton to find solutions:","category":"page"},{"location":"tutorialCarrier/","page":"Deflated Continuation in the Carrier Problem","title":"Deflated Continuation in the Carrier Problem","text":"N = 200\nX = LinRange(-1,1,N)\ndx = X[2] - X[1]\npar_car = (ϵ = 0.7, X = X, dx = dx)\nsol = -(1 .- par_car.X.^2)\n\n\noptnew = NewtonPar(tol = 1e-8, verbose = true)\n\tout, = @time newton(F_carr, Jac_carr, sol,\n\t\t(@set par_car.ϵ = 0.6), optnew, normN = x -> norm(x, Inf64))\n\tplot(out, label=\"Solution\")","category":"page"},{"location":"tutorialCarrier/#First-try-with-automatic-bifurcation-diagram","page":"Deflated Continuation in the Carrier Problem","title":"First try with automatic bifurcation diagram","text":"","category":"section"},{"location":"tutorialCarrier/","page":"Deflated Continuation in the Carrier Problem","title":"Deflated Continuation in the Carrier Problem","text":"We can start by using our Automatic bifurcation method.","category":"page"},{"location":"tutorialCarrier/","page":"Deflated Continuation in the Carrier Problem","title":"Deflated Continuation in the Carrier Problem","text":"using ForwardDiff\nD(f, x, p, dx) = ForwardDiff.derivative(t -> f(x .+ t .* dx, p), 0.)\ndF_carr(x,p)         \t   =  ForwardDiff.jacobian( z-> F_carr(z,p), x)\nd1F_carr(x,p,dx1)         = D((z, p0) -> F_carr(z, p0), x, p, dx1)\nd2F_carr(x,p,dx1,dx2)     = D((z, p0) -> d1F_carr(z, p0, dx1), x, p, dx2)\nd3F_carr(x,p,dx1,dx2,dx3) = D((z, p0) -> d2F_carr(z, p0, dx1, dx2), x, p, dx3)\njet = (F_carr, Jac_carr, d2F_carr, d3F_carr)\n\noptcont = ContinuationPar(dsmin = 0.001, dsmax = 0.05, ds= -0.01, pMin = 0.05, plotEveryStep = 10, newtonOptions = NewtonPar(tol = 1e-8, maxIter = 20, verbose = true), maxSteps = 300, detectBifurcation = 3, nev = 40)\n\ndiagram = bifurcationdiagram(jet..., 0*out, par_car,\n\t(@lens _.ϵ), 2,\n\t(arg...) -> @set optcont.newtonOptions.verbose = false;\n\trecordFromSolution = (x, p) -> (x[2] - x[1]) * sum(x.^2),\n\tplot = true)","category":"page"},{"location":"tutorialCarrier/","page":"Deflated Continuation in the Carrier Problem","title":"Deflated Continuation in the Carrier Problem","text":"However, this is a bit disappointing as we only find two branches. (Image: )","category":"page"},{"location":"tutorialCarrier/#Second-try-with-deflated-continuation","page":"Deflated Continuation in the Carrier Problem","title":"Second try with deflated continuation","text":"","category":"section"},{"location":"tutorialCarrier/","page":"Deflated Continuation in the Carrier Problem","title":"Deflated Continuation in the Carrier Problem","text":"# deflation operator to hold solutions\ndeflationOp = DeflationOperator(2, dot, 1.0, [out])\n\n# parameter values for the problem\npar_def = @set par_car.ϵ = 0.6\n\n# newton options\noptdef = setproperties(optnew; tol = 1e-7, maxIter = 200)\n\n# function to encode a perturbation of the old solutions\nfunction perturbsol(sol, p, id)\n\t# we use this sol0 for the boundary conditions\n\tsol0 = @. exp(-.01/(1-par_car.X^2)^2)\n\tsolp = 0.02*rand(length(sol))\n\treturn sol .+ solp .* sol0\nend\n\n# call the deflated continuation method\nbr, = @time continuation(\n\tF_carr, Jac_carr,\n\tpar_def, (@lens _.ϵ),\n\tsetproperties(optcont; ds = -0.00021, dsmin=1e-5, maxSteps = 20000,\n\t\tpMax = 0.7, pMin = 0.05, detectBifurcation = 0, plotEveryStep = 40,\n\t\tnewtonOptions = setproperties(optnew; tol = 1e-9, maxIter = 100, verbose = false)),\n\tdeflationOp;\n\tperturbSolution = perturbsol,\n\trecordFromSolution = (x, p) -> (x[2]-x[1]) * sum(x.^2),\n\tnormN = x -> norm(x, Inf64),\n\t)\n\nplot(br...)","category":"page"},{"location":"tutorialCarrier/","page":"Deflated Continuation in the Carrier Problem","title":"Deflated Continuation in the Carrier Problem","text":"We obtain the following result which is remarkable because it contains many more disconnected branches which we did not find in the first try.","category":"page"},{"location":"tutorialCarrier/","page":"Deflated Continuation in the Carrier Problem","title":"Deflated Continuation in the Carrier Problem","text":"(Image: )","category":"page"},{"location":"diffeq/#Wrapper-to-the-package-DifferentialEquations.jl","page":"DiffEq wrapper","title":"Wrapper to the package DifferentialEquations.jl","text":"","category":"section"},{"location":"diffeq/","page":"DiffEq wrapper","title":"DiffEq wrapper","text":"Note that this is still work in progress.","category":"page"},{"location":"diffeq/","page":"DiffEq wrapper","title":"DiffEq wrapper","text":"The current package provides basic methods to wrap some of the functionality of DifferentialEquations.jl. ","category":"page"},{"location":"diffeq/","page":"DiffEq wrapper","title":"DiffEq wrapper","text":"Basically, the ultimate idea is that you provide a prob::ODEProblem to our newton, continuation... and they will use the expression of the jacobians, the linear solvers... that you already provided for the construction of prob.","category":"page"},{"location":"eigensolver/#Eigen-solvers-(Eig)","page":"Eigen Solvers","title":"Eigen solvers (Eig)","text":"","category":"section"},{"location":"eigensolver/","page":"Eigen Solvers","title":"Eigen Solvers","text":"The eigen solvers must be subtypes of AbstractEigenSolver. ","category":"page"},{"location":"eigensolver/","page":"Eigen Solvers","title":"Eigen Solvers","text":"They provide a way of computing the eigen elements of the Jacobian J. Such eigen solver eigsolve will be called like ev, evecs, itnumber = eigsolve(J, nev; kwargs...) throughout the package, nev being the number of requested eigen elements of largest real part and kwargs being used to send information about the algorithm (perform bisection,...).","category":"page"},{"location":"eigensolver/","page":"Eigen Solvers","title":"Eigen Solvers","text":"Here is an example of the simplest of them (see src/EigSolver.jl for the true implementation) to give you an idea:","category":"page"},{"location":"eigensolver/","page":"Eigen Solvers","title":"Eigen Solvers","text":"struct DefaultEig <: AbstractEigenSolver end\n\nfunction (l::DefaultEig)(J, nev; kwargs...)\n\t# I put Array so we can call it on small sparse matrices\n\tF = eigen(Array(J))\n\tI = sortperm(F.values, by = x-> real(x), rev = true)\n\tnev2 = min(nev, length(I))\n\treturn F.values[I[1:nev2]], F.vectors[:, I[1:nev2]], true, 1\nend","category":"page"},{"location":"eigensolver/","page":"Eigen Solvers","title":"Eigen Solvers","text":"warning: Eigenvalues\nThe eigenvalues must be ordered by increasing real part for the detection of bifurcations to work properly.","category":"page"},{"location":"eigensolver/","page":"Eigen Solvers","title":"Eigen Solvers","text":"warning: Eigenvectors\nYou have to implement the method geteigenvector(eigsolver, eigenvectors, i::Int) for newtonHopf to work properly.","category":"page"},{"location":"eigensolver/#Methods-for-computing-eigenvalues","page":"Eigen Solvers","title":"Methods for computing eigenvalues","text":"","category":"section"},{"location":"eigensolver/","page":"Eigen Solvers","title":"Eigen Solvers","text":"Like for the linear solvers, computing the spectrum of operators A associated to PDE is a highly non trivial task because of the clustering of eigenvalues. Most methods are based on the so-called power method but this only yields the eigenvalues with largest modulus. In case of the Laplacian operator, this can be disastrous and it is better to apply the power method to (sigma I-A)^-1 instead. ","category":"page"},{"location":"eigensolver/","page":"Eigen Solvers","title":"Eigen Solvers","text":"This method, called Shift-invert, is readily available for the solver EigArpack, see below. It is mostly used to compute interior eigenvalues. For the solver EigKrylovKit, one must implement its own shift invert operator, using for example GMRESKrylovKit.","category":"page"},{"location":"eigensolver/","page":"Eigen Solvers","title":"Eigen Solvers","text":"In some cases, it may be advantageous to consider the Cayley transform (sigma I-A)^-1(tau I+A) to focus on a specific part of the spectrum. As it is mathematically equivalent to the Shift-invert method, we did not implement it.","category":"page"},{"location":"eigensolver/#List-of-implemented-eigen-solvers","page":"Eigen Solvers","title":"List of implemented eigen solvers","text":"","category":"section"},{"location":"eigensolver/","page":"Eigen Solvers","title":"Eigen Solvers","text":"Default eigen Julia eigensolver for matrices. You can create it via eig = DefaultEig(). Note that you can also specify how the eigenvalues are ordered (by decreasing real part by default). You can then compute 3 eigenelements of J like eig(J, 3).\nEigensolver from Arpack.jl. You can create one via eigsolver = EigArpack() and pass appropriate options (see Arpack.jl). For example, you can compute eigenvalues using Shift-Invert method with shift σ by using EigArpack(σ, :LR). Note that you can specify how the eigenvalues are ordered (by decreasing real part by default). Finally, this method can be used for (sparse) matrix or Matrix-Free formulation. For a matrix J, you can compute 3 eigen-elements using eig(J, 3). In the case of a Matrix-Free jacobian dx -> J(dx), you need to tell the eigensolver the dimension of the state space by giving an example of vector: eig = EigArpack(v0 = zeros(10)). You can then compute 3 eigen-elements using eig(dx -> J(dx), 3). \nEigensolver from KrylovKit.jl. You create one via eigsolver = EigKrylovKit() and pass appropriate options (see KrylovKit.jl). This method can be used for (sparse) matrix or Matrix-Free formulation. In the case of a matrix J, you can create a solver like this eig = EigKrylovKit(). Then, you compute 3 eigen-elements using eig(J, 3). In the case of a Matrix-Free jacobian dx -> J(dx), you need to tell the eigensolver the dimension of the state space by giving an example of vector: eig = EigKrylovKit(x₀ = zeros(10)). You can then compute 3 eigen-elements using eig(dx -> J(dx), 3).\nEigensolver from ArnoldiMethod.jl. You can create one via eigsolver = EigArnoldiMethod() and pass appropriate options (see ArnoldiMethod.jl). For example, you can compute eigenvalues using the Shift-Invert method with shift σ by using EigArpack(σ, LR()). Note that you can also specify how the eigenvalues are ordered (by decreasing real part by default). In the case of a matrix J, you can create a solver like eig = EigArpack(). Then, you compute 3 eigen-elements using eig(J, 3). In the case of a Matrix-Free jacobian dx -> J(dx), you need to tell the eigensolver the dimension of the state space by giving an example of vector: eig = EigArpack(x₀ = zeros(10)). You can then compute 3 eigen-elements using eig(dx -> J(dx), 3). ","category":"page"},{"location":"tutorialsCGL/#d-Ginzburg-Landau-equation-(finite-differences)","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"","category":"section"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"Pages = [\"tutorialsCGL.md\"]\nDepth = 3","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"This example is also treated in the MATLAB library pde2path.","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"We look at the Ginzburg-Landau equations in 2d. The code is very similar to the Brusselator example except that some special care has to be taken in order to cope with the \"high\" dimensionality of the problem.","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"Note that we try to be pedagogical here. Hence, we may write \"bad\" code that we improve later. Finally, we could use all sort of tricks to take advantage of the specificity of the problem. Rather, we stay quite close to the example in the MATLAB library pde2path (and discussed in Hopf Bifurcation and Time Periodic Orbits with Pde2path – Algorithms and Applications., Uecker, Hannes, Communications in Computational Physics 25, no. 3 (2019)) for fair comparison.","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"info: Goal\nWe do not use automatic branch switching here. The goal is to show our to use the internals of the package to squeeze most of the performances, use tailored options...","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"The equations are as follows","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"partial_t u=Delta u+(r+mathrmi v) u-left(c_3+mathrmi muright)u^2 u-c_5u^4 u+gamma quad u=u(t x) in mathbbCquad gammainmathbb R","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"with Dirichlet boundary conditions. We discretize the square Omega = (0L_x)times(0L_y) with 2N_xN_y points. We start by writing the Laplacian:","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"using Revise\nusing DiffEqOperators, ForwardDiff\nusing BifurcationKit, LinearAlgebra, Plots, SparseArrays, Parameters, Setfield\nconst BK = BifurcationKit\n\nnorminf = x -> norm(x, Inf)\n\nfunction Laplacian2D(Nx, Ny, lx, ly)\n\thx = 2lx/Nx; hy = 2ly/Ny\n\tD2x = CenteredDifference(2, 2, hx, Nx)\n\tD2y = CenteredDifference(2, 2, hy, Ny)\n\n\tQx = Dirichlet0BC(typeof(hx))\n\tQy = Dirichlet0BC(typeof(hy))\n\t\n\tD2xsp = sparse(D2x * Qx)[1]\n\tD2ysp = sparse(D2y * Qy)[1]\n\t\n\tA = kron(sparse(I, Ny, Ny), D2xsp) + kron(D2ysp, sparse(I, Nx, Nx))\n\treturn A\nend","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"It is then straightforward to write the vector field","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"# this encodes the nonlinearity\nfunction NL(u, p)\n\t@unpack r, μ, ν, c3, c5, γ = p\n\tn = div(length(u), 2)\n\tu1 = @view u[1:n]\n\tu2 = @view u[n+1:2n]\n\n\tua = u1.^2 .+ u2.^2\n\n\tf = similar(u)\n\tf1 = @view f[1:n]\n\tf2 = @view f[n+1:2n]\n\n\t@. f1 .= r * u1 - ν * u2 - ua * (c3 * u1 - μ * u2) - c5 * ua^2 * u1 + γ\n\t@. f2 .= r * u2 + ν * u1 - ua * (c3 * u2 + μ * u1) - c5 * ua^2 * u2\n\n\treturn f\nend\n\nfunction Fcgl(u, p)\n\tf = similar(u)\n\tmul!(f, p.Δ, u)\n\tf .= f .+ NL(u, p)\nend","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"and its jacobian:","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"function Jcgl(u, p)\n\t@unpack r, μ, ν, c3, c5, Δ = p\n\n\tn = div(length(u), 2)\n\tu1 = @view u[1:n]\n\tu2 = @view u[n+1:2n]\n\n\tua = u1.^2 .+ u2.^2\n\n\tf1u = zero(u1)\n\tf2u = zero(u1)\n\tf1v = zero(u1)\n\tf2v = zero(u1)\n\n\t@. f1u =  r - 2 * u1 * (c3 * u1 - μ * u2) - c3 * ua - 4 * c5 * ua * u1^2 - c5 * ua^2\n\t@. f1v = -ν - 2 * u2 * (c3 * u1 - μ * u2)  + μ * ua - 4 * c5 * ua * u1 * u2\n\t@. f2u =  ν - 2 * u1 * (c3 * u2 + μ * u1)  - μ * ua - 4 * c5 * ua * u1 * u2\n\t@. f2v =  r - 2 * u2 * (c3 * u2 + μ * u1) - c3 * ua - 4 * c5 * ua * u2 ^2 - c5 * ua^2\n\n\tjacdiag = vcat(f1u, f2v)\n\n\tΔ + spdiagm(0 => jacdiag, n => f1v, -n => f2u)\nend","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"We now define the parameters and the stationary solution:","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"Nx = 41\nNy = 21\nn = Nx * Ny\nlx = pi\nly = pi/2\n\nΔ = Laplacian2D(Nx, Ny, lx, ly)\npar_cgl = (r = 0.5, μ = 0.1, ν = 1.0, c3 = -1.0, c5 = 1.0, Δ = blockdiag(Δ, Δ), γ = 0.)\nsol0 = zeros(2Nx, Ny)","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"and we continue it to find the Hopf bifurcation points. We use a Shift-Invert eigensolver.","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"# Shift-Invert eigensolver\neigls = EigArpack(1.0, :LM) # shift = 1.0\nopt_newton = NewtonPar(tol = 1e-10, verbose = true, eigsolver = eigls)\nopts_br = ContinuationPar(dsmin = 0.001, dsmax = 0.005, ds = 0.001, pMax = 2., detectBifurcation = 3, nev = 5, plotEveryStep = 50, newtonOptions = opt_newton, maxSteps = 1060)\n\nbr, = continuation(Fcgl, Jcgl, vec(sol0), par_cgl, (@lens _.r), opts_br, verbosity = 0)","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"which gives","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"Branch number of points: 216\nBranch of Equilibrium\nBifurcation points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1,  hopf at p ≈ +1.14777610 ∈ (+1.14766562, +1.14777610), |δp|=1e-04, [converged], δ = ( 2,  2), step =  94, eigenelements in eig[ 95], ind_ev =   2\n- #  2,  hopf at p ≈ +1.86107007 ∈ (+1.86018618, +1.86107007), |δp|=9e-04, [converged], δ = ( 2,  2), step = 195, eigenelements in eig[196], ind_ev =   4","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"and (with plot(br, ylims=(-0.1,0.1))) ","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"(Image: )","category":"page"},{"location":"tutorialsCGL/#Normal-form-computation","page":"2d Ginzburg-Landau equation (finite differences)","title":"Normal form computation","text":"","category":"section"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"We compute the Hopf normal form of the first bifurcation point.","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"# we group the differentials together\njet  = BK.getJet(Fcgl, Jcgl)\n\nhopfpt = computeNormalForm(jet..., br, 1)","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"We can look at the coefficients of the normal form","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"julia> hopfpt\nSubCritical - Hopf bifurcation point at r ≈ 1.1477761028276166.\nPeriod of the periodic orbit ≈ 6.283185307179592\nNormal form z⋅(a⋅δp + b⋅|z|²): \n(a = 0.9999993808297818 - 6.092862765364455e-9im, b = 0.004870129870129872 + 0.0004870129870129874im)","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"So the Hopf branch is subcritical.","category":"page"},{"location":"tutorialsCGL/#Codim-2-Hopf-continuation","page":"2d Ginzburg-Landau equation (finite differences)","title":"Codim 2 Hopf continuation","text":"","category":"section"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"Having detected 2 hopf bifurcation points, we now continue them in the plane (gamma r). To speed things up, we need an analytical version of the second derivative.","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"Before we start the codim 2 continuation, we tell BifurcationKit.jl to use the spectral information startWithEigen = true because the left eigenvector of the Jacobian is simply not the conjugate of the right one.","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"# we perform Hopf continuation of the first Hopf point in br\nind_hopf = 1\nbr_hopf, u1_hopf = @time continuation(\n\tFcgl, Jcgl,\n\tbr, ind_hopf, (@lens _.γ),\n\tContinuationPar(dsmin = 0.001, dsmax = 0.05, ds= -0.01, pMax = 0.6, pMin = -0.6, newtonOptions = opts_br.newtonOptions, plotEveryStep = 5); plot = true,\n\tupdateMinAugEveryStep = 1, verbosity = 3, normC = norminf,\n\tstartWithEigen = true, bothside = true,\n\td2F = jet[3],)\n\nplot(br_hopf, title = \"Hopf continuation\")","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"(Image: )","category":"page"},{"location":"tutorialsCGL/#Periodic-orbits-continuation-with-stability","page":"2d Ginzburg-Landau equation (finite differences)","title":"Periodic orbits continuation with stability","text":"","category":"section"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"Having found two Hopf bifurcation points, we aim at computing the periodic orbits branching from them. Like for the Brusselator example, we need to find some educated guess for the periodic orbits in order to have a successful Newton call.","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"The following code is very close to the one explained in the tutorial 1d Brusselator (advanced user) so we won't give too much details here.","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"We focus on the first Hopf bifurcation point. Note that, we do not improve the guess for the Hopf bifurcation point, e.g. by calling newtonHopf, as this is not really needed.","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"# index of the Hopf point we want to branch from\nind_hopf = 1\n\n# number of time slices in the periodic orbit\nM = 30\n\n# periodic orbit initial guess from Hopf point\nr_hopf, Th, orbitguess2, hopfpt, eigvec = guessFromHopf(br, ind_hopf, opt_newton.eigsolver,\n\t# we pass the number of time slices M, the amplitude 22*sqrt(0.1) and phase\n\tM, 22*sqrt(0.1); phase = 0.25)\n\n# flatten the initial guess\norbitguess_f2 = reduce(hcat, orbitguess2)\norbitguess_f = vcat(vec(orbitguess_f2), Th) |> vec","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"We create a problem to hold the functional and compute Periodic orbits based on trapezoidal rule","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"poTrap = PeriodicOrbitTrapProblem(\n# vector field and sparse Jacobian\t\n\tFcgl, Jcgl,\n# parameters for the phase condition\n\treal.(eigvec),\n\thopfpt.u,\n# number of time slices\t\n\tM,\n# space dimension\t\n\t2n)","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"We can use this (family) problem poTrap with newton on our periodic orbit guess to find a periodic orbit. Hence, one can be tempted to use","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"danger: Don't run this!!\nIt uses too much memory opts_po_cont = ContinuationPar(dsmin = 0.0001, dsmax = 0.03, ds= 0.001, pMax = 2.5, \t maxSteps = 250, plotEveryStep = 3, newtonOptions = (@set opt_po.linsolver = DefaultLS()))\nbr_po, upo, = @time continuation(Fcgl, Jcgl, vec(sol0), par_cgl, (@lens _.r), opts_po_cont)","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"However, the linear system associated to the newton iterations will be solved by forming the sparse jacobian of size (2N_xN_yM+1)^2 and the use of \\ (based on LU decomposition). It takes way too much time and memory.","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"Instead, we use a preconditioner. We build the jacobian once, compute its incomplete LU decomposition (ILU) and use it as a preconditioner.","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"using IncompleteLU\n\n# Sparse matrix representation of the jacobian of the periodic orbit functional\nJpo = poTrap(Val(:JacFullSparse), orbitguess_f, @set par_cgl.r = r_hopf - 0.01)\n\n# incomplete LU factorization with threshold\nPrecilu = @time ilu(Jpo, τ = 0.005)\n\n# we define the linear solver with left preconditioner Precilu\nls = GMRESIterativeSolvers(verbose = false, reltol = 1e-3, N = size(Jpo,1), restart = 40, maxiter = 50, Pl = Precilu, log=true)\n\n# we try the linear solver\nls(Jpo, rand(ls.N))","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"This converges in 7 iterations whereas, without the preconditioner, it does not converge after 100 iterations. ","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"We set the parameters for the newton solve.","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"opt_po = @set opt_newton.verbose = true\noutpo_f, _, flag = @time newton(poTrap,\n   orbitguess_f, (@set par_cgl.r = r_hopf - 0.01),\n   (@set opt_po.linsolver = ls); \n   linearPO = :FullMatrixFree, normN = norminf)\nflag && printstyled(color=:red, \"--> T = \", outpo_f[end], \", amplitude = \", BK.getAmplitude(poTrap, outpo_f, par_cgl; ratio = 2),\"\\n\")\nBK.plotPeriodicPOTrap(outpo_f, M, Nx, Ny; ratio = 2);","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"which gives ","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"┌─────────────────────────────────────────────────────┐\n│ Newton Iterations      f(x)      Linear Iterations  │\n├─────────────┬──────────────────────┬────────────────┤\n│       0     │       6.5432e-03     │        0       │\n│       1     │       1.4372e-03     │        8       │\n│       2     │       3.6731e-04     │        8       │\n│       3     │       6.5658e-05     │        9       │\n│       4     │       4.3028e-06     │       10       │\n│       5     │       6.4509e-08     │       11       │\n│       6     │       2.9713e-10     │       12       │\n│       7     │       2.2181e-13     │       14       │\n└─────────────┴──────────────────────┴────────────────┘\n  1.780986 seconds (132.31 k allocations: 1.237 GiB, 12.13% gc time)\n--> T = 6.532023020978835, amplitude = 0.2684635643839235","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"and","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"(Image: )","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"At this point, we are still wasting a lot of resources, because the matrix-free version of the jacobian of the functional uses the jacobian of the vector field x ->  Jcgl(x, p). Hence, it builds M sparse matrices for each evaluation!! Let us create a problem which is fully Matrix Free:","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"# computation of the first derivative using automatic differentiation\nd1Fcgl(x, p, dx) = ForwardDiff.derivative(t -> Fcgl(x .+ t .* dx, p), 0.)\n\n# linear solver for solving Jcgl*x = rhs. Needed for Floquet multipliers computation\nls0 = GMRESIterativeSolvers(N = 2Nx*Ny, reltol = 1e-9, Pl = lu(I + par_cgl.Δ))\n\n# matrix-free problem\npoTrapMF = PeriodicOrbitTrapProblem(\n\tFcgl,\t(x, p) ->  (dx -> d1Fcgl(x, p, dx)),\n\treal.(eigvec),\n\thopfpt.u,\n\tM, 2n, ls0)","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"We can now use newton","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"outpo_f, _, flag = @time newton(poTrapMF,\n\torbitguess_f, (@set par_cgl.r = r_hopf - 0.01),\n\t(@set opt_po.linsolver = ls); \n\tlinearPO = :FullMatrixFree, normN = norminf)\nflag && printstyled(color=:red, \"--> T = \", outpo_f[end], \", amplitude = \", BK.getAmplitude(poTrapMF, outpo_f, par_cgl; ratio = 2),\"\\n\")","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"which gives ","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"┌─────────────────────────────────────────────────────┐\n│ Newton Iterations      f(x)      Linear Iterations  │\n├─────────────┬──────────────────────┬────────────────┤\n│       0     │       6.5432e-03     │        0       │\n│       1     │       1.4372e-03     │        8       │\n│       2     │       3.6731e-04     │        8       │\n│       3     │       6.5658e-05     │        9       │\n│       4     │       4.3028e-06     │       10       │\n│       5     │       6.4509e-08     │       11       │\n│       6     │       2.9713e-10     │       12       │\n│       7     │       2.2188e-13     │       14       │\n└─────────────┴──────────────────────┴────────────────┘\n  1.322440 seconds (35.03 k allocations: 459.996 MiB, 7.63% gc time)","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"The speedup will increase a lot for larger N_x N_y. Also, for Floquet multipliers computation, the speedup will be substantial.","category":"page"},{"location":"tutorialsCGL/#Removing-most-allocations-(Advanced-and-Experimental)","page":"2d Ginzburg-Landau equation (finite differences)","title":"Removing most allocations (Advanced and Experimental)","text":"","category":"section"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"We show here how to remove most allocations and speed up the computations. This is an experimental feature as the Floquet multipliers computation is not yet readily available in this case. To this end, we rewrite the functional using inplace formulation and trying to avoid allocations. This can be done as follows:","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"# compute just the nonlinearity\nfunction NL!(f, u, p, t = 0.)\n\t@unpack r, μ, ν, c3, c5 = p\n\tn = div(length(u), 2)\n\tu1v = @view u[1:n]\n\tu2v = @view u[n+1:2n]\n\n\tf1 = @view f[1:n]\n\tf2 = @view f[n+1:2n]\n\n\t@inbounds for ii = 1:n\n\t\tu1 = u1v[ii]\n\t\tu2 = u2v[ii]\n\t\tua = u1^2+u2^2\n\t\tf1[ii] = r * u1 - ν * u2 - ua * (c3 * u1 - μ * u2) - c5 * ua^2 * u1\n\t\tf2[ii] = r * u2 + ν * u1 - ua * (c3 * u2 + μ * u1) - c5 * ua^2 * u2\n\tend\n\treturn f\nend\n\n# derivative of the nonlinearity\nfunction dNL!(f, u, p, du)\n\t@unpack r, μ, ν, c3, c5 = p\n\tn = div(length(u), 2)\n\tu1v = @view u[1:n]\n\tu2v = @view u[n+1:2n]\n\n\tdu1v = @view du[1:n]\n\tdu2v = @view du[n+1:2n]\n\n\tf1 = @view f[1:n]\n\tf2 = @view f[n+1:2n]\n\n\t@inbounds for ii = 1:n\n\t\tu1 = u1v[ii]\n\t\tu2 = u2v[ii]\n\t\tdu1 = du1v[ii]\n\t\tdu2 = du2v[ii]\n\t\tua = u1^2+u2^2\n\t\tf1[ii] = (-5*c5*u1^4 + (-6*c5*u2^2 - 3*c3)*u1^2 + 2*μ*u1*u2 - c5*u2^4 - c3*u2^2 + r) * du1 +\n\t\t(-4*c5*u2*u1^3 + μ*u1^2 + (-4*c5*u2^3 - 2*c3*u2)*u1 + 3*u2^2*μ - ν) * du2\n\n\t\tf2[ii] = (-4*c5*u2*u1^3 - 3*μ*u1^2 + (-4*c5*u2^3 - 2*c3*u2)*u1 - u2^2*μ + ν) * du1 + (-c5*u1^4 + (-6*c5*u2^2 - c3)*u1^2 - 2*μ*u1*u2 - 5*c5*u2^4 - 3*c3*u2^2 + r) * du2\n\tend\n\n\treturn f\nend\n\n# inplace vector field\nfunction Fcgl!(f, u, p, t = 0.)\n\tNL!(f, u, p)\n\tmul!(f, p.Δ, u, 1., 1.)\nend\n\n# inplace derivative of the vector field\nfunction dFcgl!(f, x, p, dx)\n\tdNL!(f, x, p, dx)\n\tmul!(f, p.Δ, dx, 1., 1.)\nend","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"We can now define an inplace functional","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"ls0 = GMRESIterativeSolvers(N = 2Nx*Ny, reltol = 1e-9)#, Pl = lu(I + par_cgl.Δ))\npoTrapMFi = PeriodicOrbitTrapProblem(\n\tFcgl!, dFcgl!,\n\treal.(eigvec),\n\thopfpt.u,\n\tM, 2n, ls0; isinplace = true)","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"and run the newton method:","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"outpo_f, _, flag = @time newton(poTrapMFi,\n\torbitguess_f, (@set par_cgl.r = r_hopf - 0.01),\t(@set opt_po.linsolver = ls);\n\tlinearPO = :FullMatrixFree, normN = norminf)","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"It gives\t","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"┌─────────────────────────────────────────────────────┐\n│ Newton Iterations      f(x)      Linear Iterations  │\n├─────────────┬──────────────────────┬────────────────┤\n│       0     │       6.5432e-03     │        0       │\n│       1     │       1.4372e-03     │        8       │\n│       2     │       3.6731e-04     │        8       │\n│       3     │       6.5658e-05     │        9       │\n│       4     │       4.3028e-06     │       10       │\n│       5     │       6.4509e-08     │       11       │\n│       6     │       2.9713e-10     │       12       │\n│       7     │       2.2143e-13     │       14       │\n└─────────────┴──────────────────────┴────────────────┘\n  1.179854 seconds (902 allocations: 151.500 MiB)","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"Notice the small speed boost but the reduced allocations. At this stage, further improvements could target the use of BlockBandedMatrices.jl for the Laplacian operator, etc.","category":"page"},{"location":"tutorialsCGL/#Other-linear-formulation","page":"2d Ginzburg-Landau equation (finite differences)","title":"Other linear formulation","text":"","category":"section"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"We could use another way to \"invert\" jacobian of the functional based on bordered technics. We try to use an ILU preconditioner on the cyclic matrix J_c (see Periodic orbits based on trapezoidal rule) which has a smaller memory footprint:","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"Jpo2 = poTrap(Val(:JacCyclicSparse), orbitguess_f, @set par_cgl.r = r_hopf - 0.1)\nPrecilu = @time ilu(Jpo2, τ = 0.005)\nls2 = GMRESIterativeSolvers(verbose = false, reltol = 1e-3, N = size(Jpo2,1), restart = 30, maxiter = 50, Pl = Precilu, log=true)\n\nopt_po = @set opt_newton.verbose = true\noutpo_f, hist, flag = @time newton(\n\tpoTrapMF,\torbitguess_f, (@set par_cgl.r = r_hopf - 0.1),\n\t(@set opt_po.linsolver = ls2), linearPO = :BorderedMatrixFree,\n\tnormN = norminf)","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"but it gives:","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"┌─────────────────────────────────────────────────────┐\n│ Newton Iterations      f(x)      Linear Iterations  │\n├─────────────┬──────────────────────┬────────────────┤\n│       0     │       3.3298e-03     │        0       │\n│       1     │       9.5088e-03     │       34       │\n│       2     │       1.2807e-03     │       26       │\n│       3     │       7.1393e-05     │       29       │\n│       4     │       4.1625e-07     │       36       │\n│       5     │       1.7924e-09     │       44       │\n│       6     │       6.2725e-13     │       60       │\n└─────────────┴──────────────────────┴────────────────┘\n  3.479920 seconds (62.64 k allocations: 1009.778 MiB, 5.19% gc time)","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"Hence, it seems better to use the previous preconditioner.","category":"page"},{"location":"tutorialsCGL/#Continuation-of-periodic-solutions","page":"2d Ginzburg-Landau equation (finite differences)","title":"Continuation of periodic solutions","text":"","category":"section"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"We can now perform continuation of the newly found periodic orbit and compute the Floquet multipliers using Matrix-Free methods.","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"# set the eigensolver for the computation of the Floquet multipliers\nopt_po = @set opt_po.eigsolver = EigKrylovKit(tol = 1e-3, x₀ = rand(2n), verbose = 2, dim = 25)\n\n# parameters for the continuation\nopts_po_cont = ContinuationPar(dsmin = 0.0001, dsmax = 0.02, ds = 0.001, pMax = 2.2, maxSteps = 250, plotEveryStep = 3, newtonOptions = (@set opt_po.linsolver = ls), \n\tnev = 5, precisionStability = 1e-7, detectBifurcation = 0)\n\nbr_po, = @time continuation(poTrapMF, outpo_f, \n\t(@set par_cgl.r = r_hopf - 0.01), (@lens _.r),\topts_po_cont, linearPO = :FullMatrixFree;\n\tverbosity = 2,\tplot = true,\n\tplotSolution = (x, p; kwargs...) -> BK.plotPeriodicPOTrap(x, M, Nx, Ny; ratio = 2, kwargs...),\n\trecordFromSolution = (u, p) -> BK.getAmplitude(poTrapMF, u, par_cgl; ratio = 2), normC = norminf)","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"This gives the following bifurcation diagram:","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"(Image: )","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"tip: Improved performances\nAlthough it would be \"cheating\" for fair comparisons with existing packages, there is a trick to compute the bifurcation diagram without using preconditionners. We will not detail it here but it allows to handle the case Nx = 200; Ny = 110; M = 30 and above.","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"We did not change the preconditioner in the previous example as it does not seem needed. Let us show how to do this nevertheless:","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"# callback which will be sent to newton. \n# `iteration` in the arguments refers to newton iterations\nfunction callbackPO(x, f, J, res, iteration, itlinear, linsolver = ls, prob = poTrap, p = par_cgl; kwargs...)\n\t# we update the preconditioner every 10 continuation steps\n\tif mod(kwargs[:iterationC], 10) == 9 && iteration == 1\n\t\t@info \"update Preconditioner\"\n\t\tJpo = poTrap(Val(:JacCyclicSparse), x, @set p.r = kwargs[:p])\n\t\tPrecilu = @time ilu(Jpo, τ = 0.003)\n\t\tls.Pl = Precilu\n\tend\n\ttrue\nend\n\nbr_po, = @time continuation(poTrapMF, outpo_f, \n\t(@set par_cgl.r = r_hopf - 0.01), (@lens _.r),\topts_po_cont, linearPO = :FullMatrixFree;\n\tverbosity = 2,\tplot = true,\n\tcallbackN = callbackPO,\n\tplotSolution = (x, p; kwargs...) -> BK.plotPeriodicPOTrap(x, M, Nx, Ny; ratio = 2, kwargs...),\n\trecordFromSolution = (u, p) -> BK.getAmplitude(poTrapMF, u, par_cgl; ratio = 2), normC = norminf)","category":"page"},{"location":"tutorialsCGL/#Continuation-of-Fold-of-periodic-orbits","page":"2d Ginzburg-Landau equation (finite differences)","title":"Continuation of Fold of periodic orbits","text":"","category":"section"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"We continue the Fold point of the first branch of the previous bifurcation diagram in the parameter plane (r c_5). To this end, we need to be able to compute the Hessian of the periodic orbit functional. This is not yet readily available so we turn to automatic differentiation.","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"using ForwardDiff\n\n# computation of the second derivative of a function f\nfunction d2Fcglpb(f, x, dx1, dx2)\n   return ForwardDiff.derivative(t2 -> ForwardDiff.derivative( t1-> f(x .+ t1 .* dx1 .+ t2 .* dx2,), 0.), 0.)\nend","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"We select the Fold point from the branch br_po and redefine our linear solver to get the ILU preconditioner tuned close to the Fold point.","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"indfold = 2\nfoldpt = FoldPoint(br_po, indfold)\n\nJpo = poTrap(Val(:JacFullSparse), orbitguess_f, (@set par_cgl.r = r_hopf - 0.1))\nPrecilu = @time ilu(Jpo, τ = 0.005)\nls = GMRESIterativeSolvers(verbose = false, reltol = 1e-4, N = size(Jpo, 1), restart = 40, maxiter = 60, Pl = Precilu)","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"We can then use our functional to call newtonFold unlike for a regular function (see Tutorial 1). Indeed, we specify the change the parameters too much to rely on a generic algorithm.","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"outfold, hist, flag = @time BK.newtonFold(\n\t(x, p) -> poTrap(x, p),\n\t(x, p) -> poTrap(Val(:JacFullSparse), x, p),\n\tbr_po , indfold; #index of the fold point\n\t# we change the linear solver for the one we \n\t# defined above\n\toptions = (@set opt_po.linsolver = ls),\n\td2F = (x, p, dx1, dx2) -> d2Fcglpb(z -> poTrap(z, p), x, dx1, dx2))\nflag && printstyled(color=:red, \"--> We found a Fold Point at α = \", outfold.p,\" from \", br_po.foldpoint[indfold].param,\"\\n\")","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"and this gives","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"┌─────────────────────────────────────────────────────┐\n│ Newton Iterations      f(x)      Linear Iterations  │\n├─────────────┬──────────────────────┬────────────────┤\n│       0     │       4.5937e-01     │        0       │\n│       1     │       5.6013e-01     │       20       │\n│       2     │       3.1385e-02     │       23       │\n│       3     │       6.0620e-05     │       29       │\n│       4     │       2.7839e-08     │       39       │\n│       5     │       8.1593e-12     │       45       │\n└─────────────┴──────-───────────────┴────────────────┘\n 27.289005 seconds (1.07 M allocations: 24.444 GiB, 10.12% gc time)\n--> We found a Fold Point at α = 0.9470569704262517 from 0.9481896723164748","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"Finally, one can perform continuation of the Fold bifurcation point as follows","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"optcontfold = ContinuationPar(dsmin = 0.001, dsmax = 0.05, ds= 0.01, pMax = 40.1, pMin = -10., newtonOptions = (@set opt_po.linsolver = ls), maxSteps = 20)\n\noutfoldco, hist, flag = @time BK.continuationFold(\n\t(x, p) -> poTrap(x, p),\n\t(x, p) -> poTrap(Val(:JacFullSparse), x, p),\n\tbr_po, indfold, (@lens _.c5), optcontfold;\n\td2F = (x, p, dx1, dx2) -> d2Fcglpb(z->poTrap(z,p), x, dx1, dx2),\n\tplot = true, verbosity = 2)","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"which yields:","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"(Image: )","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"There is still room for a lot of improvements here. Basically, the idea would be to use full Matrix-Free the jacobian functional and its transpose.","category":"page"},{"location":"tutorialsCGL/#Continuation-of-periodic-orbits-on-the-GPU-(Advanced)","page":"2d Ginzburg-Landau equation (finite differences)","title":"Continuation of periodic orbits on the GPU (Advanced)","text":"","category":"section"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"tip: \nThis is a very neat example all done on the GPU using the following ingredients: Matrix-Free computation of periodic orbits using preconditioners.","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"We now take advantage of the computing power of GPUs. The section is run on an NVIDIA Tesla V100. Given the small number of unknowns, we can (only) expect significant speedup in the application of the big preconditioner. ","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"Note that we use the parameters Nx = 82; Ny = 42; M=30.","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"# computation of the first derivative\nd1Fcgl(x, p, dx) = ForwardDiff.derivative(t -> Fcgl(x .+ t .* dx, p), 0.)\n\nd1NL(x, p, dx) = ForwardDiff.derivative(t -> NL(x .+ t .* dx, p), 0.)\n\nfunction dFcgl(x, p, dx)\n\tf = similar(dx)\n\tmul!(f, p.Δ, dx)\n\tnl = d1NL(x, p, dx)\n\tf .= f .+ nl\nend","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"We first load CuArrays","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"using CUDA\nCUDA.allowscalar(false)\nimport LinearAlgebra: mul!, axpby!\nmul!(x::CuArray, y::CuArray, α::T) where {T <: Number} = (x .= α .* y)\nmul!(x::CuArray, α::T, y::CuArray) where {T <: Number} = (x .= α .* y)\naxpby!(a::T, X::CuArray, b::T, Y::CuArray) where {T <: Number} = (Y .= a .* X .+ b .* Y)","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"and update the parameters","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"par_cgl_gpu = @set par_cgl.Δ = CUDA.CUSPARSE.CuSparseMatrixCSC(par_cgl.Δ);","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"Then, we precompute the preconditioner on the CPU:","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"Jpo = poTrap(Val(:JacFullSparse), orbitguess_f, @set par_cgl.r = r_hopf - 0.01)\nPrecilu = @time ilu(Jpo, τ = 0.003)","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"To invert Precilu on the GPU, we need to define a few functions which are not in CuArrays and which are related to LU decomposition:","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"struct LUperso\n\tL\n\tUt\t# transpose of U in LU decomposition\nend\n\nimport Base: ldiv!\nfunction LinearAlgebra.ldiv!(_lu::LUperso, rhs::CUDA.CuArray)\n\t_x = UpperTriangular(_lu.Ut) \\ (LowerTriangular(_lu.L) \\ rhs)\n\trhs .= vec(_x)\n\tCUDA.unsafe_free!(_x)\n\trhs\nend","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"Finally, for the methods in PeriodicOrbitTrapProblem to work, we need to redefine the following method. Indeed, we disable the use of scalar on the GPU to increase the speed.","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"import BifurcationKit: extractPeriodFDTrap\nextractPeriodFDTrap(x::CuArray) = x[end:end]","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"We can now define our functional:","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"# matrix-free problem on the gpu\nls0gpu = GMRESKrylovKit(rtol = 1e-9)\npoTrapMFGPU = PeriodicOrbitTrapProblem(\n\tFcgl, (x, p) ->  (dx -> dFcgl(x, p, dx)),\n\tCuArray(real.(eigvec)),\n\tCuArray(hopfpt.u),\n\tM, 2n, ls0gpu;\n\tongpu = true) # this is required to alter the way the constraint is handled","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"Let us have a look at the linear solvers and compare the speed on CPU and GPU:","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"ls = GMRESKrylovKit(verbose = 2, Pl = Precilu, rtol = 1e-3, dim  = 20)\n   # runs in \t2.990495 seconds (785 allocations: 31.564 MiB, 0.98% gc time)\n\touth, = @time ls((Jpo), orbitguess_f)\n\nPrecilu_gpu = LUperso(LowerTriangular(CUDA.CUSPARSE.CuSparseMatrixCSR(I+Precilu.L)), UpperTriangular(CUDA.CUSPARSE.CuSparseMatrixCSR(sparse(Precilu.U'))));\nlsgpu = GMRESKrylovKit(verbose = 2, Pl = Precilu_gpu, rtol = 1e-3, dim  = 20)\n\tJpo_gpu = CUDA.CUSPARSE.CuSparseMatrixCSR(Jpo);\n\torbitguess_cu = CuArray(orbitguess_f)\n\t# runs in 1.751230 seconds (6.54 k allocations: 188.500 KiB, 0.43% gc time)\n\toutd, = @time lsgpu(Jpo_gpu, orbitguess_cu)","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"So we can expect a pretty descent x2 speed up in computing the periodic orbits. We can thus call newton:","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"opt_po = @set opt_newton.verbose = true\n\toutpo_f, hist, flag = @time newton(poTrapMFGPU,\n\t\torbitguess_cu, (@set par_cgl_gpu.r = r_hopf - 0.01),\n\t\t(@set opt_po.linsolver = lsgpu), :FullMatrixFree;\n\t\tnormN = x->maximum(abs.(x))) ","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"The computing time is 6.914367 seconds (2.94 M allocations: 130.348 MiB, 1.10% gc time). The same computation on the CPU, runs in 13.972836 seconds (551.41 k allocations: 1.300 GiB, 1.05% gc time).","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"You can also perform continuation, here is a simple example:","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"opts_po_cont = ContinuationPar(dsmin = 0.0001, dsmax = 0.02, ds= 0.001, pMax = 2.2, maxSteps = 250, plotEveryStep = 3, newtonOptions = (@set opt_po.linsolver = lsgpu))\nbr_po, upo , _= @time continuation(poTrapMFGPU,\n   orbitguess_cu, (@set par_cgl_gpu.r = r_hopf - 0.01), (@lens _.r = p),\n   opts_po_cont, linearPO = :FullMatrixFree;\n   verbosity = 2,\n   recordFromSolution = (u,p) -> getAmplitude(poTrapMFGPU, u, par_cgl_gpu), normC = x->maximum(abs.(x)))","category":"page"},{"location":"tutorialsCGL/","page":"2d Ginzburg-Landau equation (finite differences)","title":"2d Ginzburg-Landau equation (finite differences)","text":"info: Preconditioner update\nFor now, the preconditioner has been precomputed on the CPU which forbids its (efficient) update during continuation of a branch of periodic orbits. This could be improved using ilu0! and friends in CuArrays.","category":"page"},{"location":"periodicOrbitShooting/#Periodic-orbits-based-on-the-shooting-method","page":"Shooting","title":"Periodic orbits based on the shooting method","text":"","category":"section"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"A set of shooting algorithms is provided which are called either Simple Shooting (SS) if a single shooting is used and Multiple Shooting (MS) otherwise. ","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"unknown: References\nFor the exposition, we follow the PhD thesis Numerical Bifurcation Analysis of Periodic Solutions of Partial Differential Equations, Lust, Kurt, 1997. ","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"We aim at finding periodic orbits for the Cauchy problem ","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"tag1 fracd xd t=f(x)","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"and we write phi^t(x_0) the associated flow (or semigroup of solutions).","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"tip: Tip about convenience functions\nFor convenience, we provide some functions plotPeriodicShooting for plotting, getAmplitude (resp. getMaximum) for getting the amplitude (resp. maximum) of the solution encoded by a shooting problem. See the tutorials for examples of use.","category":"page"},{"location":"periodicOrbitShooting/#Standard-Shooting","page":"Shooting","title":"Standard Shooting","text":"","category":"section"},{"location":"periodicOrbitShooting/#Simple-shooting","page":"Shooting","title":"Simple shooting","text":"","category":"section"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"A periodic orbit is found when we have a couple (x T) such that phi^T(x) = x and the trajectory is non constant. Therefore, we want to solve the equations G(xT)=0 given by","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"tagSS\nbeginarraylphi^T(x)-x=0  s(xT)=0endarray","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"The section s(xT)=0 is a phase condition to remove the indeterminacy of the point on the limit cycle.","category":"page"},{"location":"periodicOrbitShooting/#Multiple-shooting","page":"Shooting","title":"Multiple shooting","text":"","category":"section"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"This case is similar to the previous one but more sections are used. To this end, we partition the unit interval with M+1 points 0=s_0s_1cdotss_m-1s_m=1 and consider the equations G(x_1cdotsx_MT)=0","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"beginaligned \nphi^delta s_1T(x_1)-x_2 =0  \nphi^delta s_2T(x_2)-x_3 =0   vdots  \nphi^delta s_m-1T(x_m-1)-x_m =0  \nphi^delta s_mT(x_m)-x_1 =0  s(x_1 T) =0 endaligned","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"where delta s_i=s_i+1-s_i. The Jacobian of the system of equations w.r.t. (xT) is given by ","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"mathcalJ=left(beginarrayccmathcal J_c  partial_TG  star  dendarrayright)","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"where the cyclic matrix mathcal J_c is","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"mathcal J_c = \nleft(beginarrayccccc\nM_1  -I      \n  M_2  -I   \n    ddots  -I \n-I      M_m \nendarrayright)","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"and M_i=partial_xphi^delta s_i T(x_i).","category":"page"},{"location":"periodicOrbitShooting/#Encoding-of-the-functional","page":"Shooting","title":"Encoding of the functional","text":"","category":"section"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"The functional is encoded in the composite type ShootingProblem. In particular, the user can pass its own time stepper or one can use the different ODE solvers in  DifferentialEquations.jl which makes it very easy to choose a solver tailored for the a specific problem. See the link ShootingProblem for more information ;  for example on how to access the underlying functional, its jacobian...","category":"page"},{"location":"periodicOrbitShooting/#Poincaré-shooting","page":"Shooting","title":"Poincaré shooting","text":"","category":"section"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"The algorithm is based on the one described in Newton–Krylov Continuation of Periodic Orbits for Navier–Stokes Flows., Sánchez, J., M. Net, B. Garcı́a-Archilla, and C. Simó (2004) and Matrix-Free Continuation of Limit Cycles for Bifurcation Analysis of Large Thermoacoustic Systems. Waugh, Iain, Simon Illingworth, and Matthew Juniper (2013). ","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"We look for periodic orbits solutions of (1) using the hyperplanes Sigma_i=x   n_icdot(x-x^c_i)=0 for i=1cdotsM, centered on x^c_i, which intersect transversally an initial periodic orbit guess. We write Pi_iSigma_itoSigma_mod(i+1M), the Poincaré return map to Sigma_mod(i+1M). The main idea of the algorithm is to use the fact that the problem is (N-1)cdot M dimensional if x_iinmathbb R^N because each x_i lives in Sigma_i. Hence, one has to constrain the unknowns to these hyperplanes otherwise the Newton algorithm does not converge well.","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"To this end, we introduce the projection operator R_imathbb R^Nto mathbb R^N-1 such that ","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"R_ileft(x_1 x_2 ldots x_k_i-1 x_k_i x_k_i+1 ldots x_Nright)=left(x_1 x_2 ldots x_k_i-1 x_k_i+1 ldots x_Nright)","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"where k_i=argmax_p n_ip. The inverse operator is defined as (where bar x=R_i(x))","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"E_i(bar x) = E_ileft(x_1 x_2 ldots x_k_i-1 x_k_i+1 ldots x_Nright)=\nleft(x_1 x_2 ldots x_k_i-1 x^c_ik_i-fracbarn_i cdotleft(overlinex-overlinex^c_iright)n_ik_i x_k_i+1 ldots x_Nright)","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"We note that R_icirc E_i = I_mathbb R^N-1 and E_icirc R_i = I_mathbb R^N.","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"We then look for solutions of the following problem:","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"beginaligned \nbar x_1 - R_MPi_M(E_M(bar x_M))=0  \nbar x_2 - R_1Pi_1(E_i(bar x_1))=0   vdots  \nbar x_M - R_M-1Pi_M-1(E_M-1(bar x_M-1))=0 \nendaligned","category":"page"},{"location":"periodicOrbitShooting/#Computation-of-Floquet-exponents","page":"Shooting","title":"Computation of Floquet exponents","text":"","category":"section"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"The (non trivial) Floquet exponents are eigenvalues of the Poincare return map PiSigma_1toSigma_1. We have Pi = Pi_McircPi_M-1circcdotscircPi_2circPi_1. Its differential is thus","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"dPi(x)cdot h = dPi_M(x_M)dPi_M-1(x_M-1)cdots dPi_1(x_1)cdot h","category":"page"},{"location":"periodicOrbitShooting/#Encoding-of-the-functional-2","page":"Shooting","title":"Encoding of the functional","text":"","category":"section"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"The functional is encoded in the composite type PoincareShootingProblem. In particular, the user can pass their own time stepper or he can use the different ODE solvers in  DifferentialEquations.jl which makes it very easy to choose a tailored solver: the partial Poincaré return maps are implemented using callbacks. See the link PoincareShootingProblem for more information, in particular on how to access the underlying functional, its jacobian...","category":"page"},{"location":"periodicOrbitShooting/#Floquet-multipliers-computation","page":"Shooting","title":"Floquet multipliers computation","text":"","category":"section"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"These are the eigenvalues of M_Mcdots M_1.","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"Unlike the case with Finite differences, the matrices M_i are not sparse.","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"A not very precise algorithm for computing the Floquet multipliers is provided. The method, dubbed Quick and Dirty (QaD), is not numerically very precise for large / small Floquet exponents. It allows, nevertheless, to detect bifurcations of periodic orbits. It seems to work reasonably well for the tutorials considered here. For more information, have a look at FloquetQaD.","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"note: Algorithm\nA more precise algorithm, based on the periodic Schur decomposition will be implemented in the future.","category":"page"},{"location":"periodicOrbitShooting/#Computation-with-newton","page":"Shooting","title":"Computation with newton","text":"","category":"section"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"We provide a simplified call to newton to locate the periodic orbit. Have a look at the tutorial Continuation of periodic orbits (Standard Shooting) for a simple example on how to use the above methods. ","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"The docs for this specific newton are located at newton.","category":"page"},{"location":"periodicOrbitShooting/#Computation-with-newton-and-deflation","page":"Shooting","title":"Computation with newton and deflation","text":"","category":"section"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"We also provide a simplified call to newton to locate the periodic orbit with a deflation operator:","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"newton(prob:: AbstractShootingProblem, orbitguess, par0, options::NewtonPar; kwargs...)","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"and","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"newton(prob:: AbstractShootingProblem, orbitguess, par0, options::NewtonPar, defOp::DeflationOperator; kwargs...)","category":"page"},{"location":"periodicOrbitShooting/#Continuation","page":"Shooting","title":"Continuation","text":"","category":"section"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"Have a look at the Continuation of periodic orbits (Standard Shooting) example for the Brusselator.","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"The docs for this specific newton are located at continuation.","category":"page"},{"location":"codim2Continuation/#Fold-/-Hopf-Continuation","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation","text":"","category":"section"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"For this to work best, it is necessary to have an analytical expression for the jacobian. See the tutorial Temperature model (Simplest example) for more details.","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"In this page, we explain how to perform continuation of Fold / Hopf points and detect the associated bifurcations.","category":"page"},{"location":"codim2Continuation/#List-of-detected-bifurcation-points","page":"Fold / Hopf Continuation (codim 2)","title":"List of detected bifurcation points","text":"","category":"section"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"Bifurcation index used\nBogdanov-Takens bt\nBautin gh\nCusp cusp","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"In a nutshell, all you have to do (see below) is to call continuation(F, J, br, ind_bif) to continue the bifurcation point stored in br.specialpoint[ind_bif] and set proper options. ","category":"page"},{"location":"codim2Continuation/#Fold-continuation","page":"Fold / Hopf Continuation (codim 2)","title":"Fold continuation","text":"","category":"section"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"The continuation of Fold bifurcation points is based on a Minimally Augmented[Govaerts] formulation which is an efficient way to detect singularities. The continuation of Fold points is based on the formulation G(up) = (F(up) g(up))inmathbb R^n+1 where the test function g is solution of","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"leftbeginarraycc\ndF(up)  w \nv^top  0\nendarrayrightleftbeginarrayc\nr \ng(up)\nendarrayright=leftbeginarrayc0_n 1endarrayrightquadquad (M_f)","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"where wv are chosen in order to have a non-singular matrix (M_f). More precisely, v (resp. w) should be close to a null vector of dF(u,p) (resp. dF(u,p)'). During continuation, the vectors wv are updated so that the matrix (M_f) remains non-singular ; this is controlled with the argument updateMinAugEveryStep (see below).","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"note that there are very simplified calls for this, see Newton refinement below. In particular, you don't need to set up the Fold Minimally Augmented problem yourself. This is done in the background.","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"warning: Linear Method\nYou can pass the bordered linear solver to solve (M_f) using the option bdlinsolver (see below). Note that the choice bdlinsolver = BorderingBLS() can lead to singular systems. Indeed, in this case, (M_f) is solved by inverting dF(u,p) which is singular at Fold points.","category":"page"},{"location":"codim2Continuation/#Hopf-continuation","page":"Fold / Hopf Continuation (codim 2)","title":"Hopf continuation","text":"","category":"section"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"The continuation of Fold bifurcation points is based on a Minimally Augmented (see [Govaerts] p. 87) formulation which is an efficient way to detect singularities. The continuation of Hopf points is based on the formulation G(uomegap) = (F(uomegap) g(uomegap))inmathbb R^n+2 where the test function g is solution of","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"leftbeginarraycc\ndF(up)-iomega I_n  w \nv^top  0\nendarrayrightleftbeginarrayc\nr \ng(uomegap)\nendarrayright=leftbeginarrayc\n0_n \n1\nendarrayrightquadquad (M_h)","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"where wv are chosen in order to have a non-singular matrix (M_h). More precisely, w (resp. v) should be a left (resp. right) approximate null vector of dF(up)-iomega I_n. During continuation, the vectors wv are updated so that the matrix (M_h) remains non-singular ; this is controlled with the argument updateMinAugEveryStep (see below).","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"note that there are very simplified calls to this, see Newton refinement below. In particular, you don't need to set up the Hopf Minimally Augmented problem yourself. This is done in the background.","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"warning: Linear Method\nYou can pass the bordered linear solver to solve (M_h) using the option bdlinsolver (see below). Note that the choice bdlinsolver = BorderingBLS() can lead to singular systems. Indeed, in this case, (M_h) is solved by inverting dF(u,p) which is singular at Fold points.","category":"page"},{"location":"codim2Continuation/#Newton-refinement","page":"Fold / Hopf Continuation (codim 2)","title":"Newton refinement","text":"","category":"section"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"Once a Fold/Hopf point has been detected after a call to br, = continuation(...), it can be refined using newton iterations. Let us say that ind_bif is the index in br.specialpoint of a Fold/Hopf point. This guess can be refined as follows:","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"outfold, hist, flag =  newton(F, J, br::AbstractBranchResult, ind_bif::Int; \n\tissymmetric = false, Jᵗ = nothing, d2F = nothing, \n\tnormN = norm, options = br.contparams.newtonOptions, \n\tbdlinsolver = BorderingBLS(options.linsolver),\n\tstartWithEigen = false, kwargs...)","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"where par is the set of parameters used in the call to continuation to compute br. For the options parameters, we refer to Newton.","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"It is important to note that for improved performances, a function implementing the expression of the hessian should be provided. This is by far the fastest. Reader interested in this advanced usage should look at the code example/chan.jl of the tutorial Temperature model (Simplest example). ","category":"page"},{"location":"codim2Continuation/#Codim-2-continuation","page":"Fold / Hopf Continuation (codim 2)","title":"Codim 2 continuation","text":"","category":"section"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"To compute the codim 2 curve of Fold/Hopf points, one can call continuation with the following options","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":" continuation(F, J,\n\t\t\t\tbr::BifurcationKit.AbstractBranchResult, ind_bif::Int64,\n\t\t\t\tlens2::Lens, options_cont::ContinuationPar = br.contparams ;\n\t\t\t\tkwargs...)","category":"page"},{"location":"codim2Continuation/#BifurcationKit.continuation","page":"Fold / Hopf Continuation (codim 2)","title":"BifurcationKit.continuation","text":"continuation(F, J, br, ind_bif, lens2)\ncontinuation(F, J, br, ind_bif, lens2, options_cont; startWithEigen, issymmetric, Jᵗ, d2F, d3F, detectCodim2Bifurcation, kwargs...)\n\n\ncodim 2 continuation of Fold / Hopf points. This function turns an initial guess for a Fold/Hopf point into a curve of Fold/Hopf points based on a Minimally Augmented formulation. The arguments are as follows\n\nF = (x, p) ->\tF(x, p) where p is a set of parameters\nJ = (x, p) -> d_xF(x, p) associated jacobian\nbr results returned after a call to continuation\nind_bif bifurcation index in br\nlens2 parameters used for the vector field\noptions_cont = br.contparams arguments to be passed to the regular continuation\n\nOptional arguments:\n\nissymmetric whether the Jacobian is Symmetric (for Fold)\nJᵗ = (x, p) -> transpose(d_xF(x, p)) associated jacobian transpose\nd2F = (x, p, v1, v2) -> d2F(x, p, v1, v2) this is the hessian of F computed at (x, p) and evaluated at (v1, v2). This helps solving the linear problem associated to the minimally augmented formulation.\nd3F = (x, p, v1, v2, v3) -> d3F(x, p, v1, v2, v3) this is the third derivative of F computed at (x, p) and evaluated at (v1, v2, v3). This is used to detect Bautin bifurcation.\nbdlinsolver bordered linear solver for the constraint equation\nupdateMinAugEveryStep update vectors a,b in Minimally Formulation every updateMinAugEveryStep steps\nstartWithEigen = false whether to start the Minimally Augmented problem with information from eigen elements\ndetectCodim2Bifurcation ∈ {0,1,2} whether to detect Bogdanov-Takens, Bautin and Cusp. If equals 1 non precise detection is used. If equals 2, a bisection method is used to locate the bifurcations.\nkwargs keywords arguments to be passed to the regular continuation\n\nwhere the parameters are as above except that you have to pass the branch br from the result of a call to continuation with detection of bifurcations enabled and index is the index of Hopf point in br you want to refine.\n\ntip: Jacobian transpose\nThe adjoint of the jacobian J is computed internally when Jᵗ = nothing by using transpose(J) which works fine when J is an AbstractArray. In this case, do not pass the jacobian adjoint like Jᵗ = (x, p) -> transpose(d_xF(x, p)) otherwise the jacobian would be computed twice!\n\ntip: ODE problems\nFor ODE problems, it is more efficient to pass the Bordered Linear Solver using the option bdlinsolver = MatrixBLS()\n\n\n\n\n\n","category":"function"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"where the options are as above except with have an additional parameter axis lens2 which is used to locate the bifurcation points. ","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"See Temperature model (Simplest example) for an example of use. ","category":"page"},{"location":"codim2Continuation/#Advanced-use","page":"Fold / Hopf Continuation (codim 2)","title":"Advanced use","text":"","category":"section"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"Here, we expose the solvers that are used to perform newton refinement or codim 2 continuation in case the above methods fails. This is useful in case it is too involved to expose the linear solver options. An example of advanced use is the continuation of Folds of periodic orbits, see Continuation of Fold of periodic orbits.","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"newtonFold","category":"page"},{"location":"codim2Continuation/#BifurcationKit.newtonFold","page":"Fold / Hopf Continuation (codim 2)","title":"BifurcationKit.newtonFold","text":"newtonFold(F, J, foldpointguess, par, lens, eigenvec, eigenvec_ad, options; normN, issymmetric, Jᵗ, d2F, bdlinsolver, kwargs...)\n\n\nThis function turns an initial guess for a Fold point into a solution to the Fold problem based on a Minimally Augmented formulation. The arguments are as follows\n\nF   = (x, p) -> F(x, p) where p is a set of parameters.\ndF  = (x, p) -> d_xF(x, p) associated jacobian\nfoldpointguess initial guess (x0, p0) for the Fold point. It should be a BorderedArray as returned by the function FoldPoint\npar parameters used for the vector field\nlens parameter axis used to locate the Fold point.\neigenvec guess for the 0 eigenvector\neigenvec_ad guess for the 0 adjoint eigenvector\noptions::NewtonPar options for the Newton-Krylov algorithm, see NewtonPar.\n\nOptional arguments:\n\nissymmetric whether the Jacobian is Symmetric\nJᵗ = (x, p) -> transpose(d_xF(x, p)) jacobian adjoint, it should be implemented in an efficient manner. For matrix-free methods, transpose is not readily available and the user must provide a dedicated method. In the case of sparse based jacobian, Jᵗ should not be passed as it is computed internally more efficiently, i.e. it avoids recomputing the jacobian as it would be if you pass Jᵗ = (x, p) -> transpose(dF(x, p))\nd2F = (x, p, v1, v2) ->  d2F(x, p, v1, v2) a bilinear operator representing the hessian of F. It has to provide an expression for d2F(x, p)[v1, v2].\nnormN = norm\nbdlinsolver bordered linear solver for the constraint equation\nkwargs keywords arguments to be passed to the regular Newton-Krylov solver\n\nSimplified call\n\nSimplified call to refine an initial guess for a Fold point. More precisely, the call is as follows\n\nnewtonFold(F, J, br::AbstractBranchResult, ind_fold::Int, lens::Lens; options = br.contparams.newtonOptions, kwargs...)\n\nwhere the optional argument Jᵗ is the jacobian transpose and the Hessian is d2F. The parameters / options are as usual except that you have to pass the branch br from the result of a call to continuation with detection of bifurcations enabled and index is the index of bifurcation point in br you want to refine. You can pass newton parameters different from the ones stored in br by using the argument options.\n\ntip: Jacobian tranpose\nThe adjoint of the jacobian J is computed internally when Jᵗ = nothing by using transpose(J) which works fine when J is an AbstractArray. In this case, do not pass the jacobian adjoint like Jᵗ = (x, p) -> transpose(d_xF(x, p)) otherwise the jacobian will be computed twice!\n\ntip: ODE problems\nFor ODE problems, it is more efficient to pass the Bordered Linear Solver using the option bdlinsolver = MatrixBLS()\n\n\n\n\n\n","category":"function"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"newtonHopf","category":"page"},{"location":"codim2Continuation/#BifurcationKit.newtonHopf","page":"Fold / Hopf Continuation (codim 2)","title":"BifurcationKit.newtonHopf","text":"newtonHopf(F, J, hopfpointguess, par, lens, eigenvec, eigenvec_ad, options; Jᵗ, d2F, normN, bdlinsolver, kwargs...)\n\n\nThis function turns an initial guess for a Hopf point into a solution to the Hopf problem based on a Minimally Augmented formulation. The arguments are as follows\n\nF   = (x, p) -> F(x, p) where p is a set of parameters.\ndF  = (x, p) -> d_xF(x, p) associated jacobian\nhopfpointguess initial guess (x0, p0) for the Hopf point. It should a BorderedArray as returned by the function HopfPoint.\npar parameters used for the vector field\nlens parameter axis used to locate the Hopf point.\neigenvec guess for the  iω eigenvector\neigenvec_ad guess for the -iω eigenvector\noptions::NewtonPar options for the Newton-Krylov algorithm, see NewtonPar.\n\nOptional arguments:\n\nJᵗ = (x, p) -> transpose(d_xF(x, p)) jacobian adjoint, it should be implemented in an efficient manner. For matrix-free methods, transpose is not readily available and the user must provide a dedicated method. In the case of sparse based jacobian, Jᵗ should not be passed as it is computed internally more efficiently, i.e. it avoids recomputing the jacobian as it would be if you pass Jᵗ = (x, p) -> transpose(dF(x, p))\nd2F = (x, p, v1, v2) ->  d2F(x, p, v1, v2) a bilinear operator representing the hessian of F. It has to provide an expression for d2F(x, p)[v1, v2].\nnormN = norm\nbdlinsolver bordered linear solver for the constraint equation\nkwargs keywords arguments to be passed to the regular Newton-Krylov solver\n\nSimplified call:\n\nSimplified call to refine an initial guess for a Hopf point. More precisely, the call is as follows\n\nnewtonHopf(F, J, br::AbstractBranchResult, ind_hopf::Int, lens::Lens; Jᵗ = nothing, d2F = nothing, normN = norm, options = br.contparams.newtonOptions, kwargs...)\n\nwhere the optional argument Jᵗ is the jacobian transpose and the Hessian is d2F. The parameters / options are as usual except that you have to pass the branch br from the result of a call to continuation with detection of bifurcations enabled and index is the index of bifurcation point in br you want to refine. You can pass newton parameters different from the ones stored in br by using the argument options.\n\ntip: Jacobian tranpose\nThe adjoint of the jacobian J is computed internally when Jᵗ = nothing by using transpose(J) which works fine when J is an AbstractArray. In this case, do not pass the jacobian adjoint like Jᵗ = (x, p) -> transpose(d_xF(x, p)) otherwise the jacobian will be computed twice!\n\ntip: ODE problems\nFor ODE problems, it is more efficient to pass the Bordered Linear Solver using the option bdlinsolver = MatrixBLS()\n\n\n\n\n\n","category":"function"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"continuationFold","category":"page"},{"location":"codim2Continuation/#BifurcationKit.continuationFold","page":"Fold / Hopf Continuation (codim 2)","title":"BifurcationKit.continuationFold","text":"continuationFold(F, J, foldpointguess, par, lens1, lens2, eigenvec, eigenvec_ad, options_cont; normC, updateMinAugEveryStep, issymmetric, Jᵗ, d2F, bdlinsolver, kwargs...)\n\n\nCodim 2 continuation of Fold points. This function turns an initial guess for a Fold point into a curve of Fold points based on a Minimally Augmented formulation. The arguments are as follows\n\nF = (x, p) ->\tF(x, p) where p is a set of parameters\nJ = (x, p) -> d_xF(x, p) associated jacobian\nfoldpointguess initial guess (x0, p10) for the Fold point. It should be a BorderedArray as returned by the function FoldPoint\npar set of parameters\nlens1 parameter axis for parameter 1\nlens2 parameter axis for parameter 2\neigenvec guess for the 0 eigenvector at p1_0\neigenvec_ad guess for the 0 adjoint eigenvector\noptions_cont arguments to be passed to the regular continuation\n\nOptional arguments:\n\nissymmetric whether the Jacobian is Symmetric\nJᵗ = (x, p) -> transpose(d_xF(x, p)) associated jacobian transpose\nd2F = (x, p, v1, v2) -> d2F(x, p, v1, v2) this is the hessian of F computed at (x, p) and evaluated at (v1, v2).\nbdlinsolver bordered linear solver for the constraint equation\nupdateMinAugEveryStep update vectors a, b in Minimally Formulation every updateMinAugEveryStep steps\nkwargs keywords arguments to be passed to the regular continuation\n\nSimplified call\n\nThe call is as follows\n\ncontinuationFold(F, J, br::AbstractBranchResult, ind_fold::Int64, lens2::Lens, options_cont::ContinuationPar ; kwargs...)\n\nwhere the parameters are as above except that you have to pass the branch br from the result of a call to continuation with detection of bifurcations enabled and index is the index of Fold point in br you want to continue.\n\ntip: Jacobian tranpose\nThe adjoint of the jacobian J is computed internally when Jᵗ = nothing by using transpose(J) which works fine when J is an AbstractArray. In this case, do not pass the jacobian adjoint like Jᵗ = (x, p) -> transpose(d_xF(x, p)) otherwise the jacobian would be computed twice!\n\ntip: ODE problems\nFor ODE problems, it is more efficient to pass the Bordered Linear Solver using the option bdlinsolver = MatrixBLS()\n\ntip: Detection of Bogdanov-Takens and Cusp bifurcations\nIn order to trigger the detection, pass detectEvent = 1,2 in options_cont.\n\n\n\n\n\n","category":"function"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"continuationHopf","category":"page"},{"location":"codim2Continuation/#BifurcationKit.continuationHopf","page":"Fold / Hopf Continuation (codim 2)","title":"BifurcationKit.continuationHopf","text":"codim 2 continuation of Hopf points. This function turns an initial guess for a Hopf point into a curve of Hopf points based on a Minimally Augmented formulation. The arguments are as follows\n\nF = (x, p) ->\tF(x, p) where p is a set of parameters\nJ = (x, p) -> d_xF(x, p) associated jacobian\nhopfpointguess initial guess (x0, p10) for the Hopf point. It should be a Vector or a BorderedArray\npar set of parameters\nlens1 parameter axis for parameter 1\nlens2 parameter axis for parameter 2\neigenvec guess for the iω eigenvector at p1_0\neigenvec_ad guess for the -iω eigenvector at p1_0\noptions_cont keywords arguments to be passed to the regular continuation\n\nOptional arguments:\n\nJᵗ = (x, p) -> adjoint(d_xF(x, p)) associated jacobian adjoint\nd2F = (x, p, v1, v2) -> d2F(x, p, v1, v2) this is the hessian of F computed at (x, p) and evaluated at (v1, v2). This helps solving the linear problem associated to the Hopf minimally augmented formulation.\nd3F = (x, p, v1, v2, v3) -> d3F(x, p, v1, v2, v3) this is the third derivative of F computed at (x, p) and evaluated at (v1, v2, v3). This is used to detect Bautin bifurcation.\nbdlinsolver bordered linear solver for the constraint equation\nupdateMinAugEveryStep update vectors a,b in Minimally Formulation every updateMinAugEveryStep steps\nkwargs keywords arguments to be passed to the regular continuation\n\nSimplified call:\n\nThe call is as follows\n\ncontinuationHopf(F, J, br::AbstractBranchResult, ind_hopf::Int, lens2::Lens, options_cont::ContinuationPar ;  kwargs...)\n\nwhere the parameters are as above except that you have to pass the branch br from the result of a call to continuation with detection of bifurcations enabled and index is the index of Hopf point in br you want to refine.\n\ntip: ODE problems\nFor ODE problems, it is more efficient to pass the Bordered Linear Solver using the option bdlinsolver = MatrixBLS()\n\ntip: Jacobian tranpose\nThe adjoint of the jacobian J is computed internally when Jᵗ = nothing by using transpose(J) which works fine when J is an AbstractArray. In this case, do not pass the jacobian adjoint like Jᵗ = (x, p) -> transpose(d_xF(x, p)) otherwise the jacobian would be computed twice!\n\ntip: Detection of Bogdanov-Takens and Bautin bifurcations\nIn order to trigger the detection, pass detectEvent = 1,2 in options_cont. Note that you need to provide d3F.\n\n\n\n\n\n","category":"function"},{"location":"codim2Continuation/#References","page":"Fold / Hopf Continuation (codim 2)","title":"References","text":"","category":"section"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"[Govaerts]: Govaerts, Willy J. F. Numerical Methods for Bifurcations of Dynamical Equilibria. Philadelphia, Pa: Society for Industrial and Applied Mathematics, 2000.","category":"page"},{"location":"library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/#Parameters","page":"Library","title":"Parameters","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"NewtonPar","category":"page"},{"location":"library/#BifurcationKit.NewtonPar","page":"Library","title":"BifurcationKit.NewtonPar","text":"struct NewtonPar{T, L<:BifurcationKit.AbstractLinearSolver, E<:AbstractEigenSolver}\n\nReturns a variable containing parameters to affect the newton algorithm when solving F(x) = 0.\n\nArguments (with default values):\n\ntol::Any\nabsolute tolerance for F(x) Default: 1.0e-10\nmaxIter::Int64\nnumber of Newton iterations Default: 50\nverbose::Bool\ndisplay Newton iterations? Default: false\nlinsolver::BifurcationKit.AbstractLinearSolver\nlinear solver, must be <: AbstractLinearSolver Default: DefaultLS()\neigsolver::AbstractEigenSolver\neigen solver, must be <: AbstractEigenSolver Default: DefaultEig()\nlinesearch::Bool\nDefault: false\nα::Any\nDefault: convert(typeof(tol), 1.0)\nαmin::Any\nDefault: convert(typeof(tol), 0.001)\n\nArguments for line search (Armijo)\n\nlinesearch = false: use line search algorithm (i.e. Newton with Armijo's rule)\nα = 1.0: initial value of α (damping) parameter for line search algorithm\nαmin  = 0.001: minimal value of the damping alpha\n\ntip: Mutating\nFor performance reasons, we decided to use an immutable structure to hold the parameters. One can use the package Setfield.jl to drastically simplify the mutation of different fields. See the tutorials for examples.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"ContinuationPar","category":"page"},{"location":"library/#BifurcationKit.ContinuationPar","page":"Library","title":"BifurcationKit.ContinuationPar","text":"options = ContinuationPar(dsmin = 1e-4,...)\n\nReturns a variable containing parameters to affect the continuation algorithm used to solve F(x,p) = 0.\n\nArguments\n\ndsmin, dsmax are the minimum, maximum arclength allowed value. It controls the density of points in the computed branch of solutions.\nds is the initial arclength.\ntheta is a parameter in the arclength constraint. It is very important to tune it. See the docs of continuation. We quote them here \"It should be tuned for the continuation to work properly especially in the case of large problems where the < x - x0, dx0 > component in the constraint equation might be favoured too much. Also, large thetas favour p as the corresponding term in N involves the term 1-theta.\"\npMin, pMax allowed parameter range for p\nmaxSteps maximum number of continuation steps\nnewtonOptions::NewtonPar: options for the Newton algorithm\nsaveToFile = false: save to file. A name is automatically generated.\nsaveSolEveryStep::Int64 = 0 at which continuation steps do we save the current solution`\nplotEveryStep = 3\n\nHandling eigen elements, their computation is triggered by the argument detectBifurcation (see below)\n\nnev = 3 number of eigenvalues to be computed. It is automatically increased to have at least nev unstable eigenvalues. To be set for proper  bifurcation detection. See Detection of bifurcation points for more informations.\nsaveEigEveryStep = 1\trecord eigen vectors every specified steps. Important for memory limited resource, e.g. GPU.\nsaveEigenvectors\t= true\tImportant for memory limited resource, e.g. GPU.\n\nHandling bifurcation detection\n\nprecisionStability = 1e-10 lower bound on the real part of the eigenvalues to test for stability of equilibria and periodic orbits\ndetectFold = true detect Fold bifurcations? It is a useful option although the detection of Fold is cheap. Indeed, it may happen that there is a lot of Fold points and this can saturate the memory in memory limited devices (e.g. on GPU)\ndetectBifurcation::Int ∈ {0, 1, 2, 3} If set to 0, nothing is done. If set to 1, the eigen-elements are computed. If set to 2, the bifurcations points are detected during the continuation run, but not located precisely. If set to 3, a bisection algorithm is used to locate the bifurcations points (slower). The possibility to switch off detection is a useful option. Indeed, it may happen that there are a lot of bifurcation points and this can saturate the memory of memory limited devices (e.g. on GPU)\ndsminBisection dsmin for the bisection algorithm for locating bifurcation points\nnInversion number of sign inversions in bisection algorithm\nmaxBisectionSteps maximum number of bisection steps\ntolBisectionEigenvalue tolerance on real part of eigenvalue to detect bifurcation points in the bisection steps\n\nHandling ds adaptation (see continuation for more information)\n\na  = 0.5 aggressiveness factor. It is used to adapt ds in order to have a number of newton iterations per continuation step roughly constant. The higher a is, the larger the step size ds is changed at each continuation step.\nthetaMin = 1.0e-3 minimum value of theta\ndoArcLengthScaling trigger further adaptation of theta\n\nHandling event detection\n\ndetectEvent::Int ∈ {0, 1, 2} If set to 0, nothing is done. If set to 1, the event locations are seek during the continuation run, but not located precisely. If set to 2, a bisection algorithm is used to locate the event (slower).\ntolParamBisectionEvent tolerance on parameter to locate event\n\nMisc\n\nfinDiffEps::T  = 1e-9 ε used in finite differences computations\ndetectLoop [WORK IN PROGRESS] detect loops in the branch and stop the continuation\n\ntip: Mutating\nFor performance reasons, we decided to use an immutable structure to hold the parameters. One can use the package Setfield.jl to drastically simplify the mutation of different fields. See tutorials for more examples.\n\n\n\n\n\n","category":"type"},{"location":"library/#Results","page":"Library","title":"Results","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"ContResult","category":"page"},{"location":"library/#BifurcationKit.ContResult","page":"Library","title":"BifurcationKit.ContResult","text":"struct ContResult{Ta, Teigvals, Teigvec, Biftype, Ts, Tfunc, Tpar, Tl<:Lens} <: BifurcationKit.AbstractBranchResult\n\nStructure which holds the results after a call to continuation.\n\nYou can see the propertynames of a result by using propertynames(::ContResult) or by typing br. + TAB where br::ContResult.\n\nFields\n\nbranch::StructArrays.StructArray{Ta, N, C, I} where {Ta, N, C<:Union{Tuple, NamedTuple}, I}\nholds the low-dimensional information about the branch. More precisely, branch[:, i+1] contains the following information (recordFromSolution(u, param), param, itnewton, itlinear, ds, theta, n_unstable, n_imag, stable, step) for each continuation step i.\nitnewton number of Newton iterations\nitlinear total number of linear iterations during corrector\nn_unstable number of eigenvalues with positive real part for each continuation step (to detect stationary bifurcation)\nn_imag number of eigenvalues with positive real part and non zero imaginary part for each continuation step (to detect Hopf bifurcation).\nstable  stability of the computed solution for each continuation step. Hence, stable should match eig[step] which corresponds to branch[k] for a given k.\nstep continuation step (here equal i)\neig::Array{NamedTuple{(:eigenvals, :eigenvec, :step), Tuple{Teigvals, Teigvec, Int64}}, 1} where {Teigvals, Teigvec}\nA vector with eigen-elements at each continuation step.\nsol::Any\nVector of solutions sampled along the branch. This is set by the argument saveSolEveryNsteps::Int64 (default 0) in ContinuationPar.\ncontparams::ContinuationPar\nThe parameters used for the call to continuation which produced this branch.\ntype::Symbol\nType of solutions computed in this branch. Default: :Equilibrium\nfunctional::Any\nStructure associated to the functional, useful for branch switching. For example, when computing periodic orbits, the functional PeriodicOrbitTrapProblem, ShootingProblem... will be saved here. Default: nothing\nparams::Any\nParameters passed to continuation and used in the equation F(x, par) = 0. Default: nothing\nlens::Lens\nParameter axis used for computing the branch\nspecialpoint::Vector{Biftype} where Biftype\nA vector holding the set of detected bifurcation points. See SpecialPoint for a description of the fields.\n\nAssociated methods\n\nlength(br) number of the continuation steps\neigenvals(br, ind) returns the eigenvalues for the ind-th continuation step\neigenvec(br, ind, indev) returns the indev-th eigenvector for the ind-th continuation step\nbr[k+1] gives information about the k-th step\ngetSolx(br, k) returns the k-th solution on the branch\ngetSolp(br, k) returns the parameter  value associated with k-th solution on the branch\n\n\n\n\n\n","category":"type"},{"location":"library/#Problems","page":"Library","title":"Problems","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"DeflationOperator","category":"page"},{"location":"library/#BifurcationKit.DeflationOperator","page":"Library","title":"BifurcationKit.DeflationOperator","text":"struct DeflationOperator{Tp<:Real, Tdot, T<:Real, vectype}\n\nIt is used to handle the following situation. Assume you want to solve F(x)=0 with a Newton algorithm but you want to avoid the process to return some already known solutions roots_i. The deflation operator penalizes these roots ; the algorithm works very well despite its simplicity. You can use DeflationOperator to define a function M(u) used to find, with Newton iterations, the zeros of the following function F(u) cdot Π_i(u - root_i^-2p + alpha) = F(u) cdot M(u) where u^2 = dot(uu). The fields of the struct DeflationOperator are as follows:\n\npower::Real\npower p. You can use an  Int for example\ndot::Any\nfunction, this function has to be bilinear and symmetric for the linear solver to work well\nα::Real\nshift\nroots::Vector{vectype} where vectype\nroots\ntmp::Any\n\nGiven defOp::DeflationOperator, one can access its roots as defOp[n] as a shortcut for defOp.roots[n]. Also, one can add (resp.remove) a new root by using push!(defOp, newroot) (resp. pop!(defOp)). Finally length(defOp) is a shortcut for length(defOp.roots)\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"DeflatedProblem","category":"page"},{"location":"library/#BifurcationKit.DeflatedProblem","page":"Library","title":"BifurcationKit.DeflatedProblem","text":"pb = DeflatedProblem(F, J, M::DeflationOperator)\n\nThis creates a deflated problem M(u) cdot F(u) = 0 where M is a DeflationOperator which encodes the penalization term. J is the jacobian of F. Can be used to call newton and continuation.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"PeriodicOrbitTrapProblem","category":"page"},{"location":"library/#BifurcationKit.PeriodicOrbitTrapProblem","page":"Library","title":"BifurcationKit.PeriodicOrbitTrapProblem","text":"pb = PeriodicOrbitTrapProblem(F, J, ϕ, xπ, M::Int)\n\nThis composite type implements Finite Differences based on a Trapezoidal rule to locate periodic orbits. More details (maths, notations, linear systems) can be found here. The arguments are as follows\n\nF(x,p) vector field\nJ is the jacobian of F at (x, p). It can assume three forms.\nEither J is a function and J(x, p) returns a ::AbstractMatrix. In this case, the default arguments of contParams::ContinuationPar will make continuation work.\nOr J is a function and J(x, p) returns a function taking one argument dx and returning dr of the same type as dx. In our notation, dr = J * dx. In this case, the default parameters of contParams::ContinuationPar will not work and you have to use a Matrix Free linear solver, for example GMRESIterativeSolvers,\nOr J is a function and J(x, p) returns a variable j which can assume any type. Then, you must implement a linear solver ls as a composite type, subtype of AbstractLinearSolver which is called like ls(j, rhs) and which returns the solution of the jacobian linear system. See for example examples/SH2d-fronts-cuda.jl. This linear solver is passed to NewtonPar(linsolver = ls) which itself passed to ContinuationPar. Similarly, you have to implement an eigensolver eig as a composite type, subtype of AbstractEigenSolver.\nJᵗ = nothing jacobian transpose of F (optional), useful for continuation of Fold of periodic orbits. it should not be passed in case the jacobian is a (sparse) matrix as it is computed internally, and it would be computed twice in that case.\nd2F = nothing second derivative of F (optional), useful for continuation of Fold of periodic orbits. It has the definition d2F(x,p,dx1,dx2).`\nϕ used to set a section for the phase constraint equation\nxπ used in the section for the phase constraint equation\nM::Int number of time slices\nlinsolver: = DefaultLS() linear solver for each time slice, i.e. to solve J⋅sol = rhs. This is only needed for the computation of the Floquet multipliers.\nisinplace::Bool whether F and J are inplace functions (Experimental). In this case, the functions F and J must have the following definitions (o, x, p) ->  F(o, x, p) and (o, x, p, dx) -> J(o, x, p, dx).\nongpu::Bool whether the computation takes place on the gpu (Experimental)\n\nThe scheme is as follows. We first consider a partition of 01 given by 0s_0cdotss_m=1 and one looks for T = x[end] such that\n\nleft(x_i - x_i-1right) - fracTcdot h_i2 left(F(x_i) + F(x_i-1)right) = 0 i=1cdotsm-1\n\nwith u_0 = u_m-1 and the periodicity condition u_m - u_1 = 0 and\n\nwhere h_1 = s_i-s_i-1. Finally, the phase of the periodic orbit is constrained by using a section (but you could use your own)\n\nsum_ilangle x_i - x_pii phi_irangle=0\n\nOrbit guess\n\nYou will see below that you can evaluate the residual of the functional (and other things) by calling pb(orbitguess, p) on an orbit guess orbitguess. Note that orbitguess must be of size M * N + 1 where N is the number of unknowns in the state space and orbitguess[M*N+1] is an estimate of the period T of the limit cycle. More precisely, using the above notations, orbitguess must be orbitguess = x_1x_2cdotsx_M T.\n\nFunctional\n\nA functional, hereby called G, encodes this problem. The following methods are available\n\npb(orbitguess, p) evaluates the functional G on orbitguess\npb(orbitguess, p, du) evaluates the jacobian dG(orbitguess).du functional at orbitguess on du\npb(Val(:JacFullSparse), orbitguess, p) return the sparse matrix of the jacobian dG(orbitguess) at orbitguess without the constraints. It is called A_γ in the docs.\npb(Val(:JacFullSparseInplace), J, orbitguess, p). Same as pb(Val(:JacFullSparse), orbitguess, p) but overwrites J inplace. Note that the sparsity pattern must be the same independantly of the values of the parameters or of orbitguess. In this case, this is significantly faster than pb(Val(:JacFullSparse), orbitguess, p).\npb(Val(:JacCyclicSparse), orbitguess, p) return the sparse cyclic matrix Jc (see the docs) of the jacobian dG(orbitguess) at orbitguess\npb(Val(:BlockDiagSparse), orbitguess, p) return the diagonal of the sparse matrix of the jacobian dG(orbitguess) at orbitguess. This allows to design Jacobi preconditioner. Use blockdiag.\n\nnote: GPU call\nFor these methods to work on the GPU, for example with CuArrays in mode allowscalar(false), we face the issue that the function extractPeriodFDTrap won't be well defined because it is a scalar operation. One may have to redefine it like extractPeriodFDTrap(x::CuArray) = x[end:end] or something else. Also, note that you must pass the option ongpu = true for the functional to be evaluated efficiently on the gpu.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"ShootingProblem","category":"page"},{"location":"library/#BifurcationKit.ShootingProblem","page":"Library","title":"BifurcationKit.ShootingProblem","text":"pb = ShootingProblem(flow::Flow, ds, section; parallel = false)\n\nCreate a problem to implement the Standard Simple / Parallel Multiple Standard Shooting method to locate periodic orbits. More details (maths, notations, linear systems) can be found here. The arguments are as follows\n\nflow::Flow: implements the flow of the Cauchy problem though the structure Flow.\nds: vector of time differences for each shooting. Its length is written M. If M==1, then the simple shooting is implemented and the multiple one otherwise.\nsection: implements a phase condition. The evaluation section(x, T) must return a scalar number where x is a guess for one point the periodic orbit and T is the period of the guess. The type of x depends on what is passed to the newton solver. See SectionSS for a type of section defined as a hyperplane.\nparallel whether the shooting are computed in parallel (threading). Available through the use of Flows defined by EnsembleProblem.\n\nA functional, hereby called G, encodes the shooting problem. For example, the following methods are available:\n\npb(orbitguess, par) evaluates the functional G on orbitguess\npb(orbitguess, par, du; δ = 1e-9) evaluates the jacobian dG(orbitguess).du functional at orbitguess on du. The optional argument δ is used to compute a finite difference approximation of the derivative of the section.\npb(Val(:JacobianMatrixInplace), J, x, par)` compute the jacobian of the functional analytically. This is based on ForwardDiff.jl. Useful mainly for ODEs.\npb(Val(:JacobianMatrix), x, par) same as above but out-of-place.\n\nYou can then call pb(orbitguess, par) to apply the functional to a guess. Note that orbitguess::AbstractVector must be of size M * N + 1 where N is the number of unknowns of the state space and orbitguess[M * N + 1] is an estimate of the period T of the limit cycle. This form of guess is convenient for the use of the linear solvers in IterativeSolvers.jl (for example) which accepts only AbstractVectors. Another accepted guess is of the form BorderedArray(guess, T) where guess[i] is the state of the orbit at the ith time slice. This last form allows for non-vector state space which can be convenient for 2d problems for example, use GMRESKrylovKit for the linear solver in this case.\n\nSimplified constructors\n\nA simpler way to build the functional is to use\n\npb = ShootingProblem(F, p, prob::Union{ODEProblem, EnsembleProblem}, alg, centers::AbstractVector; kwargs...)\n\nwhere F(x,p) is the vector field, p is a parameter (to be passed to the vector field and the flow), prob is an ODEProblem (resp. EnsembleProblem) which is used to create a flow using the ODE solver alg (for example Tsit5()). centers is list of M points close to the periodic orbit, they will be used to build a constraint for the phase. parallel = false is an option to use Parallel simulations (Threading) to simulate the multiple trajectories in the case of multiple shooting. This is efficient when the trajectories are relatively long to compute. Finally, the arguments kwargs are passed to the ODE solver defining the flow. Look at DifferentialEquations.jl for more information. Note that, in this case, the derivative of the flow is computed internally using Finite Differences.\n\nAnother way to create a Shooting problem with more options is the following where in particular, one can provide its own scalar constraint section(x)::Number for the phase\n\npb = ShootingProblem(F, p, prob::Union{ODEProblem, EnsembleProblem}, alg, M::Int, section; parallel = false, kwargs...)\n\nor\n\npb = ShootingProblem(F, p, prob::Union{ODEProblem, EnsembleProblem}, alg, ds, section; parallel = false, kwargs...)\n\nThe next way is an elaboration of the previous one\n\npb = ShootingProblem(F, p, prob1::Union{ODEProblem, EnsembleProblem}, alg1, prob2::Union{ODEProblem, EnsembleProblem}, alg2, M::Int, section; parallel = false, kwargs...)\n\nor\n\npb = ShootingProblem(F, p, prob1::Union{ODEProblem, EnsembleProblem}, alg1, prob2::Union{ODEProblem, EnsembleProblem}, alg2, ds, section; parallel = false, kwargs...)\n\nwhere we supply now two ODEProblems. The first one prob1, is used to define the flow associated to F while the second one is a problem associated to the derivative of the flow. Hence, prob2 must implement the following vector field tilde F(xyp) = (F(xp)dF(xp)cdot y).\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"PoincareShootingProblem","category":"page"},{"location":"library/#BifurcationKit.PoincareShootingProblem","page":"Library","title":"BifurcationKit.PoincareShootingProblem","text":"pb = PoincareShootingProblem(flow::Flow, M, sections; δ = 1e-8, interp_points = 50, parallel = false)\n\nThis composite type implements the Poincaré Shooting method to locate periodic orbits by relying on Poincaré return maps. More details (maths, notations, linear systems) can be found here. The arguments are as follows\n\nflow::Flow: implements the flow of the Cauchy problem though the structure Flow.\nM: the number of Poincaré sections. If M==1, then the simple shooting is implemented and the multiple one otherwise.\nsections: function or callable struct which implements a Poincaré section condition. The evaluation sections(x) must return a scalar number when M==1. Otherwise, one must implement a function section(out, x) which populates out with the M sections. See SectionPS for type of section defined as a hyperplane.\nδ = 1e-8 used to compute the jacobian of the functional by finite differences. If set to 0, an analytical expression of the jacobian is used instead.\ninterp_points = 50 number of interpolation point used to define the callback (to compute the hitting of the hyperplane section)\nparallel = false whether the shooting are computed in parallel (threading). Only available through the use of Flows defined by EnsembleProblem.\n\nSimplified constructors\n\nA simpler way is to create a functional is\n\npb = PoincareShootingProblem(F, p, prob::ODEProblem, alg, section; kwargs...)\n\nfor simple shooting or\n\npb = PoincareShootingProblem(F, p, prob::Union{ODEProblem, EnsembleProblem}, alg, M::Int, section; kwargs...)\n\nfor multiple shooting . Here F(x,p) is the vector field, p is a parameter (to be passed to the vector and the flow), prob is an Union{ODEProblem, EnsembleProblem} which is used to create a flow using the ODE solver alg (for example Tsit5()). Finally, the arguments kwargs are passed to the ODE solver defining the flow. We refer to DifferentialEquations.jl for more information.\n\nAnother convenient call is\n\npb = PoincareShootingProblem(F, p, prob::Union{ODEProblem, EnsembleProblem}, alg, normals::AbstractVector, centers::AbstractVector; δ = 1e-8, kwargs...)\n\nwhere normals (resp. centers) is a list of normals (resp. centers) which defines a list of hyperplanes Sigma_i. These hyperplanes are used to define partial Poincaré return maps.\n\nComputing the functionals\n\nA functional, hereby called G encodes this shooting problem. You can then call pb(orbitguess, par) to apply the functional to a guess. Note that orbitguess::AbstractVector must be of size M * N where N is the number of unknowns in the state space and M is the number of Poincaré maps. Another accepted guess is such that guess[i] is the state of the orbit on the ith section. This last form allows for non-vector state space which can be convenient for 2d problems for example.\n\npb(orbitguess, par) evaluates the functional G on orbitguess\npb(orbitguess, par, du) evaluates the jacobian dG(orbitguess).du functional at orbitguess on du\npb(Val(:JacobianMatrixInplace), J, x, par)` compute the jacobian of the functional analytically. This is based on ForwardDiff.jl. Useful mainly for ODEs.\npb(Val(:JacobianMatrix), x, par) same as above but out-of-place.\n\ntip: Tip\nYou can use the function getPeriod(pb, sol, par) to get the period of the solution sol for the problem with parameters par.\n\n\n\n\n\n","category":"type"},{"location":"library/#Newton","page":"Library","title":"Newton","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"newton","category":"page"},{"location":"library/#BifurcationKit.newton","page":"Library","title":"BifurcationKit.newton","text":"\tnewton(F, J, x0, p0, options::NewtonPar; normN = norm, callback = (x, f, J, res, iteration, itlinear, optionsN; kwargs...) -> true, kwargs...)\n\nThis is the Newton-Krylov Solver for F(x, p0) = 0 with Jacobian w.r.t. x written J(x, p0) and initial guess x0. The function normN allows to specify a norm for the convergence criteria. It is important to set the linear solver options.linsolver properly depending on your problem. This linear solver is used to solve J(x p_0)u = -F(x p_0) in the Newton step. You can for example use linsolver = DefaultLS() which is the operator backslash: it works well for Sparse / Dense matrices. See Linear solvers (LS) for more informations.\n\nArguments:\n\nF is a function with input arguments (x, p) returning a vector r that represents the functional and for type stability, the types of x and r should match. In particular, it is not inplace.\nJ is the jacobian of F at (x, p). It can assume two forms. Either J is a function and J(x, p) returns a ::AbstractMatrix. In this case, the default arguments of NewtonPar will make newton work. Or J is a function and J(x, p) returns a function taking one argument dx and returns dr of the same type of dx. In our notation, dr = J * dx. In this case, the default parameters of NewtonPar will not work and you have to use a Matrix Free linear solver, for example GMRESIterativeSolvers.\nx0 initial guess\np0 set of parameters to be passed to F and J\noptions::NewtonPar variable holding the internal parameters used by the newton method\ncallback function passed by the user which is called at the end of each iteration. The default one is the following cbDefault(x, f, J, res, it, itlinear, options; k...) = true. Can be used to update a preconditionner for example. The arguments passed to the callback are as follows\nx current solution\nf current residual\nJ current jacobian\nres current norm of the residual\niteration current newton iteration\nitlinear number of iterations to solve the linear system\noptionsN a copy of the argument options passed to newton\nkwargs kwargs arguments, contain your initial guess x0\nkwargs arguments passed to the callback. Useful when newton is called from continuation\n\nOutput:\n\nsolution\nhistory of residuals\nflag of convergence\nnumber of newton iterations\ntotal number of linear iterations\n\nSimplified calls\n\nWhen J is not passed, the jacobian matrix is then computed with finite differences (beware of large systems of equations!). The call is as follows:\n\nnewton(F, x0, p0, options::NewtonPar; kwargs...)\n\nYou can also pass functions which do not have parameters x -> F(x), x -> J(x) as follows\n\nnewton(F, J, x0, options::NewtonPar;  kwargs...)\n\nor\n\nnewton(F, x0, options::NewtonPar;  kwargs...)\n\nExample\n\njulia> F(x, p) = x.^3 .- 1\njulia> Jac(x, p) = spdiagm(0 => 3 .* x.^2) # sparse jacobian\njulia> x0 = rand(1_000)\njulia> opts = NewtonPar()\njulia> sol, hist, flag, _ = newton(F, Jac, x0, nothing, opts, normN = x -> norm(x, Inf))\n\ntip: Other formulation\nIf you don't have parameters, you can still use newton as follows newton((x,p) -> F(x), (x,p)-> J(x), x0, nothing, options)\n\nwarning: Linear solver\nMake sure that the linear solver (Matrix-Free...) corresponds to your jacobian (Matrix-Free vs. Matrix based).\n\n\n\n\n\nnewton(F, J, x0, p0, options, defOp)\nnewton(F, J, x0, p0, options, defOp, linsolver; kwargs...)\n\n\nThis is the deflated version of the Krylov-Newton Solver for F(x, p0) = 0 with Jacobian J(x, p0). We refer to newton for more information. It penalises the roots saved in defOp.roots. The other arguments are as for newton. See DeflationOperator for more information.\n\nArguments\n\nCompared to newton, the only different arguments are\n\ndefOp::DeflationOperator deflation operator\nlinsolver linear solver used to invert the Jacobian of the deflated functional.\nWe have a custom solver DeflatedLinearSolver() with requires solving two linear systems J⋅x = rhs.\nFor other linear solvers <: AbstractLinearSolver, a matrix free method is used for the deflated functional.\nif passed Val(:autodiff), then ForwardDiff.jl is used to compute the jacobian of the deflated problem\n\nOutput:\n\nsolution:\nhistory of residuals\nflag of convergence\nnumber of iterations\n\nSimplified call\n\nWhen J is not passed. It then computed with finite differences. The call is as follows:\n\nnewton(F, x0, p0, options, defOp; kwargs...)\n\n\n\n\n\nThis specific Newton-Krylov method first tries to converge to a solution sol0 close the guess x0. It then attempts to converge from the guess x1 while avoiding the previous coonverged solution close to sol0. This is very handy for branch switching. The method is based on a deflated Newton-Krylov solver.\n\n\n\n\n\nnewton(F, J, br, ind_bif; Jᵗ, d2F, normN, options, startWithEigen, issymmetric, kwargs...)\n\n\nThis function turns an initial guess for a Fold/Hopf point into a solution to the Fold/Hopf problem based on a Minimally Augmented formulation. The arguments are as follows\n\nF  = (x, p) -> F(x, p) where p is a set of parameters.\nJ  = (x, p) -> d_xF(x, p) associated jacobian\nbr results returned after a call to continuation\nind_bif bifurcation index in br\nlens parameter axis used to locate the Fold/Hopf point.\noptions::NewtonPar\n\nOptional arguments:\n\nissymmetric whether the Jacobian is Symmetric (for Fold)\nJᵗ = (x, p) -> transpose(d_xF(x, p)) jacobian adjoint, it should be implemented in an efficient manner. For matrix-free methods, transpose is not readily available and the user must provide a dedicated method. In the case of Matrix / Sparse based jacobian, Jᵗ should not be passed as it is computed internally more efficiently, i.e. it avoids recomputing the jacobian as it would be if you pass Jᵗ = (x, p) -> transpose(dF(x, p))\nd2F = (x, p, v1, v2) ->  d2F(x, p, v1, v2) a bilinear operator representing the hessian of F. It has to provide an expression for d2F(x,p)[v1,v2].\nnormN = norm\noptions You can pass newton parameters different from the ones stored in br by using this argument options.\nbdlinsolver bordered linear solver for the constraint equation\nstartWithEigen = false whether to start the Minimally Augmented problem with information from eigen elements\nkwargs keywords arguments to be passed to the regular Newton-Krylov solver\n\ntip: ODE problems\nFor ODE problems, it is more efficient to pass the Bordered Linear Solver using the option bdlinsolver = MatrixBLS()\n\n\n\n\n\nnewton(prob, orbitguess, par, options; linearPO, δ, kwargs...)\n\n\nThis is the Newton-Krylov Solver for computing a periodic orbit using (Standard / Poincaré) Shooting method. Note that the linear solver has to be apropriately set up in options.\n\nArguments\n\nSimilar to newton except that prob is either a ShootingProblem or a PoincareShootingProblem. These two problems have specific options to be tuned, we refer to their link for more information and to the tutorials.\n\nprob a problem of type <: AbstractShootingProblem encoding the shooting functional G.\norbitguess a guess for the periodic orbit. See ShootingProblem and See PoincareShootingProblem for information regarding the shape of orbitguess.\npar parameters to be passed to the functional\noptions same as for the regular newton method.\n\nOptional argument\n\nlinearPO Specify the choice of the linear algorithm, which must belong to [:autodiffMF, :MatrixFree, :autodiffDense, :FiniteDifferences]. This is used to select a way of inverting the jacobian dG\nFor :MatrixFree, we use an iterative solver (e.g. GMRES) to solve the linear system. The jacobian was specified by the user in prob.\nFor :autodiffMF, we use iterative solver (e.g. GMRES) to solve the linear system. We use Automatic Differentiation to compute the (matrix-free) derivative of x -> prob(x, p).\nFor :autodiffDense. Same as for :autodiffMF but the jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one using options.\nFor :FiniteDifferencesDense, same as for :autodiffDense but we use Finite Differences to compute the jacobian of x -> prob(x, p) using the δ = 1e-8 which can be passed as an argument.\n\nOutput:\n\nsolution\nhistory of residuals\nflag of convergence\nnumber of iterations\n\n\n\n\n\nnewton(prob, orbitguess, par, options, defOp; linearPO, kwargs...)\n\n\nThis is the deflated Newton-Krylov Solver for computing a periodic orbit using a (Standard / Poincaré) Shooting method.\n\nArguments\n\nSimilar to newton except that prob is either a ShootingProblem or a PoincareShootingProblem.\n\nOptional argument\n\nlinearPO Specify the choice of the linear algorithm, which must belong to [:autodiffMF, :MatrixFree, :autodiffDense, :FiniteDifferences]. This is used to select a way of inverting the jacobian dG\nFor :MatrixFree, we use an iterative solver (e.g. GMRES) to solve the linear system. The jacobian was specified by the user in prob.\nFor :autodiffMF, we use iterative solver (e.g. GMRES) to solve the linear system. We use Automatic Differentiation to compute the (matrix-free) derivative of x -> prob(x, p).\nFor :autodiffDense. Same as for :autodiffMF but the jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one using options.\nFor :FiniteDifferencesDense, same as for :autodiffDense but we use Finite Differences to compute the jacobian of x -> prob(x, p) using the δ = 1e-8 which can be passed as an argument.\n\nOutput:\n\nsolution\nhistory of residuals\nflag of convergence\nnumber of iterations\n\n\n\n\n\nnewton(probPO, orbitguess, par, options; linearPO, kwargs...)\n\n\nThis is the Newton-Krylov Solver for computing a periodic orbit using a functional G based on Finite Differences and a Trapezoidal rule.\n\nArguments:\n\nprob a problem of type PeriodicOrbitTrapProblem encoding the functional G\norbitguess a guess for the periodic orbit where orbitguess[end] is an estimate of the period of the orbit. It should be a vector of size N * M + 1 where M is the number of time slices, N is the dimension of the phase space. This must be compatible with the numbers N,M in prob.\npar parameters to be passed to the functional\noptions same as for the regular newton method\nlinearPO = :BorderedLU. Specify the choice of the linear algorithm, which must belong to [:FullLU, :FullSparseInplace, :BorderedLU, :FullMatrixFree, :BorderedMatrixFree, :FullSparseInplace]. This is used to select a way of inverting the jacobian dG of the functional G.\nFor :FullLU, we use the default linear solver based on a sparse matrix representation of dG. This matrix is assembled at each newton iteration. This is the default algorithm.\nFor :FullSparseInplace, this is the same as for :FullLU but the sparse matrix dG is updated inplace. This method allocates much less. In some cases, this is significantly faster than using :FullLU. Note that this method can only be used if the sparsity pattern of the jacobian is always the same.\nFor :Dense, same as above but the matrix dG is dense. It is also updated inplace. This option is useful to study ODE of small dimension.\nFor :BorderedLU, we take advantage of the bordered shape of the linear solver and use a LU decomposition to invert dG using a bordered linear solver. This is the default algorithm.\nFor :BorderedSparseInplace, this is the same as for :BorderedLU but the cyclic matrix dG is updated inplace. This method allocates much less. In some cases, this is significantly faster than using :FullLU. Note that this method can only be used if the sparsity pattern of the jacobian is always the same.\nFor :FullMatrixFree, a matrix free linear solver is used for dG: note that a preconditioner is very likely required here because of the cyclic shape of dG which affects negatively the convergence properties of GMRES.\nFor :BorderedMatrixFree, a matrix free linear solver is used but for Jc only (see docs): it means that options.linsolver is used to invert Jc. These two Matrix-Free options thus expose different part of the jacobian dG in order to use specific preconditioners. For example, an ILU preconditioner on Jc could remove the constraints in dG and lead to poor convergence. Of course, for these last two methods, a preconditioner is likely to be required.\n\nOutput:\n\nsolution\nhistory of residuals\nflag of convergence\nnumber of iterations\n\n\n\n\n\nnewton(probPO::PeriodicOrbitTrapProblem, orbitguess, options::NewtonPar, defOp::DeflationOperator{T, Tf, vectype}, linearPO = :BorderedLU; kwargs...) where {T, Tf, vectype}\n\nThis function is similar to newton(probPO, orbitguess, options, linearPO; kwargs...) except that it uses deflation in order to find periodic orbits different from the ones stored in defOp. We refer to the mentioned method for a full description of the arguments. The current method can be used in the vicinity of a Hopf bifurcation to prevent the Newton-Krylov algorithm from converging to the equilibrium point.\n\n\n\n\n\n","category":"function"},{"location":"library/#Library-Continuation","page":"Library","title":"Continuation","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"continuation","category":"page"},{"location":"library/#BifurcationKit.continuation","page":"Library","title":"BifurcationKit.continuation","text":"continuation(F, J, x0, par, lens::Lens, contParams::ContinuationPar; plot = false, normC = norm, dotPALC = (x,y) -> dot(x,y) / length(x), recordFromSolution = norm, plotSolution = (x, p; kwargs...)->nothing, finaliseSolution = (z, tau, step, contResult; kwargs...) -> true, callbackN = (x, f, J, res, iteration, itlinear, options; kwargs...) -> true, linearAlgo = BorderingBLS(), tangentAlgo = SecantPred(), verbosity = 0)\n\nCompute the continuation curve associated to the functional F and its jacobian J.\n\nArguments:\n\nF is a function with input arguments (x, p), where p is the set of parameters passed to F, and returning a vector r which represents the functional. For type stability, the types of x and r should match. In particular, it is not inplace,\nJ is the jacobian of F at (x, p). It can assume three forms.\nEither J is a function and J(x, p) returns a ::AbstractMatrix. In this case, the default arguments of contParams::ContinuationPar will make continuation work.\nOr J is a function and J(x, p) returns a function taking one argument dx and returning dr of the same type as dx. In our notation, dr = J * dx. In this case, the default parameters of contParams::ContinuationPar will not work and you have to use a Matrix Free linear solver, for example GMRESIterativeSolvers,\nOr J is a function and J(x, p) returns a variable j which can assume any type. Then, you must implement a linear solver ls as a composite type, subtype of AbstractLinearSolver which is called like ls(j, rhs) and which returns the solution of the jacobian linear system. See for example examples/SH2d-fronts-cuda.jl. This linear solver is passed to NewtonPar(linsolver = ls) which itself is passed to ContinuationPar. Similarly, you have to implement an eigensolver eig as a composite type, subtype of AbstractEigenSolver.\nx0 initial guess,\npar initial set of parameters,\nlens::Lens specifies which parameter axis among par is used for continuation. For example, if par = (α = 1.0, β = 1), we can perform continuation w.r.t. α by using lens = (@lens _.α). If you have an array par = [ 1.0, 2.0] and want to perform continuation w.r.t. the first variable, you can use lens = (@lens _[1]). For more information, we refer to SetField.jl.\ncontParams parameters for continuation. See ContinuationPar for more information about the options\n\nOptional Arguments:\n\nplot = false whether to plot the solution while computing\nrecordFromSolution = (x, p) -> norm(x) function used record a few indicators about the solution. It could be norm or (x, p) -> x[1]. This is also useful when saving several huge vectors is not possible for memory reasons (for example on GPU...). This function can return pretty much everything but you should keep it small. For example, you can do (x, p) -> (x1 = x[1], x2 = x[2], nrm = norm(x)) or simply (x, p) -> (sum(x), 1). This will be stored in contres.branch (see below). Finally, the first component is used to plot in the continuation curve.\nplotSolution = (x, p; kwargs...) -> nothing function implementing the plot of the solution. For example, you can pass something like (x, p; kwargs...) -> plot(x; kwargs...).\nfinaliseSolution = (z, tau, step, contResult; kwargs...) -> true Function called at the end of each continuation step. Can be used to alter the continuation procedure (stop it by returning false), saving personal data, plotting... The notations are z=(x p), tau is the tangent at z (see below), step is the index of the current continuation step and ContResult is the current branch. For advanced use, the current state::ContState of the continuation is passed in kwargs. Note that you can have a better control over the continuation procedure by using an iterator, see Iterator Interface.\ncallbackN callback for newton iterations. see docs for newton. Can be used to change preconditioners\ntangentAlgo = SecantPred() controls the algorithm used to predict the tangents along the curve of solutions or the corrector. Can be NaturalPred, SecantPred or BorderedPred. See below for more information.\nlinearAlgo = BorderingBLS(). Used to control the way the extended linear system associated to the continuation problem is solved. Can be MatrixBLS, BorderingBLS or MatrixFreeBLS.\nverbosity::Int controls the amount of information printed during the continuation process. Must belong to {0,1,2,3}. In case contParams.newtonOptions.verbose = false, the following is valid (Otherwise the newton iterations are shown). Each case prints more information then the previous one:\ncase 0: print nothing\ncase 1: print basic information about the continuation: used predictor, step size and parameter values\ncase 2: print newton iterations number, stability of solution, detected bifurcations / events\ncase 3: print information during bisection to detect bifurcation / events\nnormC = norm norm used in the different Newton solves\ndotPALC = (x, y) -> dot(x, y) / length(x), dot product used to define the weighted dot product (resp. norm) (x p)^2_theta in the constraint N(x p) (see below). This argument can be used to remove the factor 1/length(x) for example in problems where the dimension of the state space changes (mesh adaptation, ...)\nfilename name of a file to save the computed branch during continuation. The identifier .jld2 will be appended to this filename\nbothside=true compute the branches on the two sides of p0, merge them and return it.\n\nOutputs:\n\ncontres::ContResult composite type which contains the computed branch. See ContResult for more information.\nu::BorderedArray the last solution computed on the branch\n\ntip: Controlling the argument `linearAlgo`\nIn this simplified interface to continuation, the argument linearAlgo is internally overwritten to provide a valid argument to the algorithm. If you do not want this to happen, call directly continuation(F, J, x0, par, lens, contParams, linearAlgo; kwargs...).\n\ntip: Continuing the branch in the opposite direction\nJust change the sign of ds in ContinuationPar.\n\nSimplified call:\n\nYou can also use the following call for which the jacobian matrix (beware of large systems of equations!) is computed internally using Finite Differences\n\ncontinuation(Fhandle, x0, par, lens, contParams::ContinuationPar; kwargs...)\n\nMethod\n\nBordered system of equations\n\nIn what follows, we abuse of notations, p refers to the scalar value of the parameter we perform continuation with. Hence, it should be p = get(par, lens).\n\nThe pseudo-arclength continuation method solves the equation F(x p) = 0 (of dimension N) together with the pseudo-arclength constraint N(x p) = fracthetalength(x) langle x - x_0 dx_0rangle + (1 - theta)cdot(p - p_0)cdot dp_0 - ds = 0 and thetain01 (see Keller, Herbert B. Lectures on Numerical Methods in Bifurcation Problems. Springer, 1988). In practice, a curve gamma of solutions is sought and is parametrised by s: gamma(s) = (x(s) p(s)) is a curve of solutions to F(x p). This formulation allows to pass turning points (where the implicit theorem fails). In the previous formula, (x_0 p_0) is a solution for a given s_0, tau_0equiv(dx_0 dp_0) is the tangent to the curve gamma at s_0. Hence, to compute the curve of solutions, we need to solve an equation of dimension N+1 which is called a Bordered system.\n\nwarning: Parameter `theta`\nThe parameter theta in the struct ContinuationParis very important. It should be tuned for the continuation to work properly especially in the case of large problems where the langle x - x_0 dx_0rangle component in the constraint might be favoured too much. Also, large thetas favour p as the corresponding term in N involves the term 1-theta.\n\nThe parameter ds is adjusted internally depending on the number of Newton iterations and other factors. See the function stepSizeControl for more information. An important parameter to adjust the magnitude of this adaptation is the parameter a in the struct ContinuationPar.\n\nAlgorithm\n\nThe algorithm works as follows:\n\nStart from a known solution (x_0 p_0) with tangent to the curve of solutions: (dx_0 dp_0)\nPredictor: set (x_1 p_1) = (x_0 p_0) + dscdot (dx_0 dp_0). Note that a different predictor can be used.\nCorrector: solve F(x p)=0 N(x p)=0 with a (Bordered) Newton Solver with initial guess (x_1 p_1).\nif Newton in 3. did not converge, update ds/2 ⟶ ds in N and go to 1.\nNew tangent: Compute a new tangent (see below) (dx_1 dp_1) and update N with it. Set (x_0 p_0 dx_0 dp_0) = (x_1 p_1 dx_1 dp_1) and return to step 2\n\nNatural continuation\n\nMore information is available at Predictors - Correctors\n\nWe speak of natural continuation when we do not consider the constraint N(x p)=0. Knowing (x_0 p_0), we use x_0 as a guess for solving F(x p_1)=0 with p_1 close to p_0. Again, this fails at Turning points but it can be faster to compute than the constrained case. This is set by the option tangentAlgo = NaturalPred() in continuation.\n\nTangent computation (step 4)\n\nMore information is available at Predictors - Correctors\n\nThere are various ways to compute (dx_1 dp_1). The first one is called secant and is parametrised by the option tangentAlgo = SecantPred(). It is computed by (dx_1 dp_1) = (z_1 p_1) - (z_0 p_0) and normalised by the norm (x p)^2_theta = fracthetalength(x) langle xxrangle + (1 - theta)cdot p^2. Another method is to compute (dx_1 dp_1) by solving solving the bordered linear system beginbmatrix F_x  F_p\t  fracthetalength(x)dx_0  (1-theta)dp_0endbmatrixbeginbmatrixdx_1   dp_1endbmatrix =beginbmatrix0  1endbmatrix ; it is set by the option tangentAlgo = BorderedPred().\n\nBordered linear solver\n\nMore information is available at Bordered linear solvers (BLS)\n\nWhen solving the Bordered system F(x p) = 0 N(x p)=0, one faces the issue of solving the Bordered linear system beginbmatrix J  a\t b^T  cendbmatrixbeginbmatrixX   yendbmatrix =beginbmatrixR  nendbmatrix. This can be solved in many ways via bordering (which requires two Jacobian inverses), by forming the bordered matrix (which works well for sparse matrices) or by using a full Matrix Free formulation. The choice of method is set by the argument linearAlgo. Have a look at the struct linearBorderedSolver for more information.\n\nLinear Algebra\n\nLet us discuss here more about the norm and dot product. First, the option normC gives a norm that is used to evaluate the residual in the following way: max(normC(F(xp)) N(xp))tol. It is thus used as a stopping criterion for a Newton algorithm. The dot product (resp. norm) used in N and in the (iterative) linear solvers is LinearAlgebra.dot (resp. LinearAlgebra.norm). It can be changed by importing these functions and redefining it. Not that by default, the L^2 norm is used. These details are important because of the constraint N which incorporates the factor length. For some custom composite type implementing a Vector space, the dot product could already incorporates the length factor in which case you should either redefine the dot product or change theta.\n\nStep size control\n\nAs explained above, each time the corrector phased failed, the step size ds is halved. This has the disadvantage of having lost Newton iterations (which costs time) and impose small steps (which can be slow as well). To prevent this, the step size is controlled internally with the idea of having a constant number of Newton iterations per point. This is in part controlled by the aggressiveness factor a in ContinuationPar. Further tuning is performed by using doArcLengthScaling=true in ContinuationPar. This adjusts internally theta so that the relative contributions of x and p are balanced in the constraint N.\n\n\n\n\n\ncontinuation(F, J, br, ind_bif, lens2)\ncontinuation(F, J, br, ind_bif, lens2, options_cont; startWithEigen, issymmetric, Jᵗ, d2F, d3F, detectCodim2Bifurcation, kwargs...)\n\n\ncodim 2 continuation of Fold / Hopf points. This function turns an initial guess for a Fold/Hopf point into a curve of Fold/Hopf points based on a Minimally Augmented formulation. The arguments are as follows\n\nF = (x, p) ->\tF(x, p) where p is a set of parameters\nJ = (x, p) -> d_xF(x, p) associated jacobian\nbr results returned after a call to continuation\nind_bif bifurcation index in br\nlens2 parameters used for the vector field\noptions_cont = br.contparams arguments to be passed to the regular continuation\n\nOptional arguments:\n\nissymmetric whether the Jacobian is Symmetric (for Fold)\nJᵗ = (x, p) -> transpose(d_xF(x, p)) associated jacobian transpose\nd2F = (x, p, v1, v2) -> d2F(x, p, v1, v2) this is the hessian of F computed at (x, p) and evaluated at (v1, v2). This helps solving the linear problem associated to the minimally augmented formulation.\nd3F = (x, p, v1, v2, v3) -> d3F(x, p, v1, v2, v3) this is the third derivative of F computed at (x, p) and evaluated at (v1, v2, v3). This is used to detect Bautin bifurcation.\nbdlinsolver bordered linear solver for the constraint equation\nupdateMinAugEveryStep update vectors a,b in Minimally Formulation every updateMinAugEveryStep steps\nstartWithEigen = false whether to start the Minimally Augmented problem with information from eigen elements\ndetectCodim2Bifurcation ∈ {0,1,2} whether to detect Bogdanov-Takens, Bautin and Cusp. If equals 1 non precise detection is used. If equals 2, a bisection method is used to locate the bifurcations.\nkwargs keywords arguments to be passed to the regular continuation\n\nwhere the parameters are as above except that you have to pass the branch br from the result of a call to continuation with detection of bifurcations enabled and index is the index of Hopf point in br you want to refine.\n\ntip: Jacobian transpose\nThe adjoint of the jacobian J is computed internally when Jᵗ = nothing by using transpose(J) which works fine when J is an AbstractArray. In this case, do not pass the jacobian adjoint like Jᵗ = (x, p) -> transpose(d_xF(x, p)) otherwise the jacobian would be computed twice!\n\ntip: ODE problems\nFor ODE problems, it is more efficient to pass the Bordered Linear Solver using the option bdlinsolver = MatrixBLS()\n\n\n\n\n\ncontinuation(F, J, x0, par0, x1, p1, lens, contParams; linearAlgo, kwargs...)\n\n\nThis function is the analog of continuation when the two first points on the branch are passed (instead of a single one). Hence x0 is the first point on the branch (with palc s=0) with parameter par0 and x1 is the second point with parameter set(par0, lens, p1).\n\n\n\n\n\ncontinuation(F, dF, d2F, d3F, br, ind_bif)\ncontinuation(F, dF, d2F, d3F, br, ind_bif, optionsCont; Jᵗ, δ, δp, ampfactor, nev, issymmetric, usedeflation, Teigvec, scaleζ, verbosedeflation, maxIterDeflation, perturb, kwargs...)\n\n\nAutomatic branch switching at branch points based on a computation of the normal form. More information is provided in Branch switching. An example of use is provided in 2d generalized Bratu–Gelfand problem.\n\nArguments\n\nF, dF, d2F, d3F: function (x, p) -> F(x, p) and its differentials (x, p, dx) -> d1F(x, p, dx), (x, p, dx1, dx2) -> d2F(x, p, dx1, dx2)...\nbr branch result from a call to continuation\nind_bif index of the bifurcation point in br from which you want to branch from\noptionsCont options for the call to continuation\n\nOptional arguments\n\nJᵗ associated jacobian transpose, it should be implemented in an efficient manner. For matrix-free methods, transpose is not readily available and the user must provide a dedicated method. In the case of sparse based jacobian, Jᵗ should not be passed as it is computed internally more efficiently, i.e. it avoid recomputing the jacobian as it would be if you pass Jᵗ = (x, p) -> transpose(dF(x, p)).\nδ used internally to compute derivatives w.r.t the parameter p.\nδp used to specify a particular guess for the parameter on the bifurcated branch which is otherwise determined by optionsCont.ds. This allows to use a step larger than optionsCont.dsmax.\nampfactor = 1 factor which alters the amplitude of the bifurcated solution. Useful to magnify the bifurcated solution when the bifurcated branch is very steep.\nnev number of eigenvalues to be computed to get the right eigenvector\nissymmetric whether the Jacobian is Symmetric, avoid computing the left eigenvectors in the computation of the reduced equation.\nusedeflation = true whether to use nonlinear deflation (see Deflated problems) to help finding the guess on the bifurcated branch\nkwargs optional arguments to be passed to continuation, the regular continuation one.\n\ntip: Advanced use\nIn the case of a very large model and use of special hardware (GPU, cluster), we suggest to discouple the computation of the reduced equation, the predictor and the bifurcated branches. Have a look at methods(BifurcationKit.multicontinuation) to see how to call these versions. These methods has been tested on GPU with very high memory pressure.\n\n\n\n\n\ncontinuation(F, J, par, lens, contParams, defOp; verbosity, maxBranches, seekEveryStep, maxIterDefOp, plot, tangentAlgo, linearAlgo, dotPALC, 459, recordFromSolution, plotSolution, 462, perturbSolution, callbackN, acceptSolution, updateDeflationOp, normN)\n\n\nThis function computes the set of curves of solutions γ(s) = (x(s), p(s)) to the equation F(x,p)=0 based on the algorithm of deflated continuation as described in Farrell, Patrick E., Casper H. L. Beentjes, and Ásgeir Birkisson. “The Computation of Disconnected Bifurcation Diagrams.” ArXiv:1603.00809 [Math], March 2, 2016. http://arxiv.org/abs/1603.00809.\n\nDepending on the options in contParams, it can locate the bifurcation points on each branch. Note that you can specify different predictors using tangentAlgo.\n\nArguments:\n\nF is a function with input arguments (x, p), where p is the set of parameters passed to F, and returning a vector r that represents the functional. For type stability, the types of x and r should match. In particular, it is not inplace,\nJ is the jacobian of F at (x, p). It can assume three forms.\nEither J is a function and J(x, p) returns a ::AbstractMatrix. In this case, the default arguments of contParams::ContinuationPar will make continuation work.\nOr J is a function and J(x, p) returns a function taking one argument dx and returning dr of the same type as dx. In our notation, dr = J * dx. In this case, the default parameters of contParams::ContinuationPar will not work and you have to use a Matrix Free linear solver, for example GMRESIterativeSolvers,\nOr J is a function and J(x, p) returns a variable j which can assume any type. Then, you must implement a linear solver ls as a composite type, subtype of AbstractLinearSolver which is called like ls(j, rhs) and which returns the solution of the jacobian linear system. See for example examples/SH2d-fronts-cuda.jl. This linear solver is passed to NewtonPar(linsolver = ls) which itself passed to ContinuationPar. Similarly, you have to implement an eigensolver eig as a composite type, subtype of AbstractEigenSolver.\npar initial set of parameters,\nlens::Lens specifies which parameter axis among par is used for continuation. For example, if par = (α = 1.0, β = 1), we can perform continuation w.r.t. α by using lens = (@lens _.α). If you have an array par = [ 1.0, 2.0] and want to perform continuation w.r.t. the first variable, you can use lens = (@lens _[1]). For more information, we refer to SetField.jl,\ncontParams parameters for continuation. See ContinuationPar for more information about the options,\ndefOp::DeflationOperator a Deflation Operator (see DeflationOperator) which contains the set of solution guesses for the parameter par.\n\nOptional Arguments:\n\nseekEveryStep::Int = 1 we look for additional solution, using deflated newton, every seekEveryStep step,\nmaxBranches::Int = 100 maximum number of branches considered,\nmaxIterDefOp::Int maximum number of deflated Newton iterations\nplot = false whether to plot the solution while computing,\nrecordFromSolution = (x, p) -> norm(x) function used to plot in the continuation curve. It is also used in the way results are saved. It could be norm or (x, p) -> x[1]. This is also useful when saving several huge vectors is not possible for memory reasons (for example on GPU...),\nplotSolution = (x, p; kwargs...) -> nothing function implementing the plot of the solution,\ncallbackN callback for newton iterations. see docs for newton. Can be used to change preconditioners or affect the newton iterations. In the deflation part of the algorithm, when seeking for new branches, the callback is passed the keyword argument fromDeflatedNewton = true to tell the user can it is not in the continuation part (regular newton) of the algorithm,\ntangentAlgo = NaturalPred() controls the algorithm used to predict the tangents along the curve of solutions or the corrector. Can be NaturalPred, SecantPred or BorderedPred,\nverbosity::Int controls the amount of information printed during the continuation process. Must belong to {0,⋯,5},\nnormN = norm norm used in the different Newton solves,\ndotPALC = (x, y) -> dot(x, y) / length(x), dot product used to define the weighted dot product (resp. norm) (x p)^2_theta in the constraint N(x p) (see below). This argument can be used to remove the factor 1/length(x) for example in problems where the dimension of the state space changes (mesh adaptation, ...),\nperturbSolution = (x, p, id) -> x perturbation applied to the solution when trying to find new solutions using Deflated Newton. You can use for example (x, p, id) -> x .+ (1 .+ 0.001 * rand(size(x)...))\n\nOutputs:\n\ncontres::Vector{ContResult} composite type which contains the computed branches. See ContResult for more information,\nthe iterator associated with the computation\nthe solutions at the last parameter value,\ncurrent parameter value.\n\n\n\n\n\ncontinuation(prob, orbitguess, par, lens, _contParams; linearAlgo, kwargs...)\n\n\nThis is the continuation routine for computing a periodic orbit using a (Standard / Poincaré) Shooting method.\n\nArguments\n\nSimilar to continuation except that prob is either a ShootingProblem or a PoincareShootingProblem.\n\nprintPeriod boolean to print the period of the solution. This is useful for prob::PoincareShootingProblem as this information is not easily available.\n\n\n\n\n\ncontinuation(F, dF, d2F, d3F, br, ind_bif, _contParams, prob; Jᵗ, δ, δp, ampfactor, usedeflation, nev, updateSectionEveryStep, kwargs...)\n\n\nPerform automatic branch switching from a Hopf bifurcation point labelled ind_bif in the list of the bifurcated points of a previously computed branch br::ContResult. It first computes a Hopf normal form.\n\nArguments\n\nF, dF, d2F, d3F: function (x,p) -> F(x,p) and its differentials (x,p,dx) -> d1F(x,p,dx), (x,p,dx1,dx2) -> d2F(x,p,dx1,dx2)... These are used to compute the Hopf normal form.\nbr branch result from a call to continuation\nind_hopf index of the bifurcation point in br\ncontParams parameters for the call to continuation\nprob problem used to specify the way the periodic orbit is computed. It can be PeriodicOrbitTrapProblem, ShootingProblem or PoincareShootingProblem .\n\nOptional arguments\n\nlinearPO linear algorithm used for the computation of periodic orbits when prob is PeriodicOrbitTrapProblem)\nJᵗ is the jacobian adjoint, used for computation of the eigen-elements of the jacobian adjoint, needed to compute the spectral projector for the Hopf normal form. For matrix-free methods, transpose is not readily available and the user must provide a dedicated method. In the case of Matrix / Sparse based jacobian, Jᵗ should not be passed as it is computed internally more efficiently, i.e. it avoid recomputing the jacobian as it would be if you pass Jᵗ = (x, p) -> transpose(dF(x, p))\nδ = 1e-8 used for finite differences\nδp used to specify a particular guess for the parameter on the bifurcated branch which is otherwise determined by contParams.ds. This allows to use a step larger than contParams.dsmax.\nampfactor = 1 factor which alter the amplitude of the bifurcated solution. Useful to magnify the bifurcated solution when the bifurcated branch is very steep.\nusedeflation = true whether to use nonlinear deflation (see Deflated problems) to help finding the guess on the bifurcated branch\nupdateSectionEveryStep = 0 updates the section every updateSectionEveryStep step during continuation\nlinearPO specify the way the jacobian is computed.\nall kwargs from continuation\n\nA modified version of prob is passed to plotSolution and finaliseSolution.\n\nnote: Linear solver\nYou have to be careful about the options contParams.newtonOptions.linsolver. In the case of Matrix-Free solver, you have to pass the right number of unknowns N * M + 1. Note that the options for the preconditioner are not accessible yet.\n\ntip: Jacobian transpose\nThe adjoint of the jacobian J is computed internally when Jᵗ = nothing by using transpose(J) which works fine when J is an AbstractArray. In this case, do not pass the jacobian adjoint like Jᵗ = (x, p) -> transpose(d_xF(x, p)) otherwise the jacobian would be computed twice!\n\nwarning: Hessian\nThe hessian of F, when d2F is not nothing, is computed with Finite differences.\n\n\n\n\n\ncontinuation(prob, orbitguess, par, lens, _contParams; linearPO, recordFromSolution, linearAlgo, updateSectionEveryStep, kwargs...)\n\n\nThis is the continuation routine for computing a periodic orbit using a functional G based on Finite Differences and a Trapezoidal rule.\n\nArguments\n\nprob::PeriodicOrbitTrapProblem encodes the functional G\norbitguess a guess for the periodic orbit where orbitguess[end] is an estimate of the period of the orbit. It could be a vector of size N * M + 1 where M is the number of time slices, N is the dimension of the phase space. This must be compatible with the numbers N, M in prob.\np0 set of parameters passed to the vector field\ncontParams same as for the regular continuation method\nlinearAlgo same as in continuation\nlinearPO = :BorderedLU. Same as newton when applied to a PeriodicOrbitTrapProblem. More precisely:\nFor :FullLU, we use the default linear solver on a sparse matrix representation of dG. This matrix is assembled at each newton iteration.\nFor :FullSparseInplace, this is the same as :FullLU but the sparse matrix dG is updated inplace. This method thus allocates much less. In some cases, this is significantly faster than using :FullLU. Note that this method can only be used if the sparsity pattern of the jacobian is always the same.\nFor :Dense, same as above but the matrix dG is dense. It is also updated inplace. This option is useful to study ODE of small dimension.\nFor :BorderedLU, we take advantage of the bordered shape of the linear solver and use LU decomposition to invert dG using a bordered linear solver. This is the default algorithm.\nFor :FullMatrixFree, a matrix free linear solver is used for dG: note that a preconditioner is very likely required here because of the cyclic shape of dG which affects negatively the convergence properties of GMRES.\nFor :BorderedMatrixFree, a matrix free linear solver is used but for Jc only (see docs): it means that options.linsolver is used to invert Jc. These two Matrix-Free options thus expose different part of the jacobian dG in order to use specific preconditioners. For example, an ILU preconditioner on Jc could remove the constraints in dG and lead to poor convergence. Of course, for these last two methods, a preconditioner is likely to be required.\nupdateSectionEveryStep = 1 updates the section every when mod(step, updateSectionEveryStep) == 1 during continuation\n\nNote that by default, the method prints the period of the periodic orbit as function of the parameter. This can be changed by providing your recordFromSolution argument.\n\n\n\n\n\n","category":"function"},{"location":"library/#Events","page":"Library","title":"Events","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"BifurcationKit.DiscreteEvent","category":"page"},{"location":"library/#BifurcationKit.DiscreteEvent","page":"Library","title":"BifurcationKit.DiscreteEvent","text":"struct DiscreteEvent{Tcb, Tl} <: BifurcationKit.AbstractDiscreteEvent\n\nStructure to pass a DiscreteEvent function to the continuation algorithm. A continuous call back returns a discrete value and we seek when it changes.\n\nnb::Int64\nnumber of events, ie the length of the result returned by the callback function\ncondition::Any\n, (iter, state) -> NTuple{nb, Int64} callback function which at each continuation state, returns a tuple. For example, to detect a value change.\ncomputeEigenElements::Bool\nwhether the event requires to compute eigen elements\nlabels::Any\nLabels used to display information. For example labels[1] is used top qualify an event occuring in the first component. For example, you can use labels = (\"hopf\",) or labels = (\"hopf\", \"fold\"). You must have labels::Union{Nothing, NTuple{N, String}}.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"BifurcationKit.ContinuousEvent","category":"page"},{"location":"library/#BifurcationKit.ContinuousEvent","page":"Library","title":"BifurcationKit.ContinuousEvent","text":"struct ContinuousEvent{Tcb, Tl} <: BifurcationKit.AbstractContinuousEvent\n\nStructure to pass a ContinuousEvent function to the continuation algorithm. A continuous call back returns a tuple/scalar value and we seek its zeros.\n\nnb::Int64\nnumber of events, ie the length of the result returned by the callback function\ncondition::Any\n, (iter, state) -> NTuple{nb, T} callback function which, at each continuation state, returns a tuple. For example, to detect crossing 1.0 and -2.0, you can pass (iter, state) -> (getp(state)+2, getx(state)[1]-1)),. Note that the type T should match the one of the parameter specified by the ::Lens in continuation.\ncomputeEigenElements::Bool\nwhether the event requires to compute eigen elements\nlabels::Any\nLabels used to display information. For example labels[1] is used top qualify an event of the type (0,1.3213,3.434). For example, you can use labels = (\"hopf\",) or labels = (\"hopf\", \"fold\"). You must have labels::Union{Nothing, NTuple{N, String}}.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"BifurcationKit.SetOfEvents","category":"page"},{"location":"library/#BifurcationKit.SetOfEvents","page":"Library","title":"BifurcationKit.SetOfEvents","text":"struct SetOfEvents{Tc<:Tuple, Td<:Tuple} <: BifurcationKit.AbstractEvent\n\nMultiple events can be chained together to form a SetOfEvents. A SetOfEvents is constructed by passing the constructor ContinuousEvent, DiscreteEvent or other SetOfEvents instances:\n\nSetOfEvents(cb1, cb2, cb3)\n\nExample\n\n BK.SetOfEvents(BK.FoldDetectCB, BK.BifDetectCB)\n\nYou can pass as many events as you like.\n\neventC::Tuple\nContinuous event\neventD::Tuple\nDiscrete event\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"BifurcationKit.PairOfEvents","category":"page"},{"location":"library/#BifurcationKit.PairOfEvents","page":"Library","title":"BifurcationKit.PairOfEvents","text":"struct PairOfEvents{Tc<:BifurcationKit.AbstractContinuousEvent, Td<:BifurcationKit.AbstractDiscreteEvent} <: BifurcationKit.AbstractEvent\n\nStructure to pass a PairOfEvents function to the continuation algorithm. It is composed of a pair ContinuousEvent / DiscreteEvent.\n\neventC::BifurcationKit.AbstractContinuousEvent\nContinuous event\neventD::BifurcationKit.AbstractDiscreteEvent\nDiscrete event\n\n\n\n\n\n","category":"type"},{"location":"library/#Branch-switching-(branch-point)","page":"Library","title":"Branch switching (branch point)","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"continuation(F, dF, d2F, d3F, br::ContResult, ind_bif::Int, optionsCont::ContinuationPar ; Jᵗ = nothing, δ = 1e-8, δp = nothing, ampfactor = 1, nev = optionsCont.nev, issymmetric = false, usedeflation = false, Teigvec = getvectortype(br), scaleζ = norm, verbosedeflation = false, maxIterDeflation = min(50, 15optionsCont.newtonOptions.maxIter), perturb = identity, kwargs...)","category":"page"},{"location":"library/#BifurcationKit.continuation-Tuple{Any, Any, Any, Any, ContResult, Int64, ContinuationPar}","page":"Library","title":"BifurcationKit.continuation","text":"continuation(F, dF, d2F, d3F, br, ind_bif)\ncontinuation(F, dF, d2F, d3F, br, ind_bif, optionsCont; Jᵗ, δ, δp, ampfactor, nev, issymmetric, usedeflation, Teigvec, scaleζ, verbosedeflation, maxIterDeflation, perturb, kwargs...)\n\n\nAutomatic branch switching at branch points based on a computation of the normal form. More information is provided in Branch switching. An example of use is provided in 2d generalized Bratu–Gelfand problem.\n\nArguments\n\nF, dF, d2F, d3F: function (x, p) -> F(x, p) and its differentials (x, p, dx) -> d1F(x, p, dx), (x, p, dx1, dx2) -> d2F(x, p, dx1, dx2)...\nbr branch result from a call to continuation\nind_bif index of the bifurcation point in br from which you want to branch from\noptionsCont options for the call to continuation\n\nOptional arguments\n\nJᵗ associated jacobian transpose, it should be implemented in an efficient manner. For matrix-free methods, transpose is not readily available and the user must provide a dedicated method. In the case of sparse based jacobian, Jᵗ should not be passed as it is computed internally more efficiently, i.e. it avoid recomputing the jacobian as it would be if you pass Jᵗ = (x, p) -> transpose(dF(x, p)).\nδ used internally to compute derivatives w.r.t the parameter p.\nδp used to specify a particular guess for the parameter on the bifurcated branch which is otherwise determined by optionsCont.ds. This allows to use a step larger than optionsCont.dsmax.\nampfactor = 1 factor which alters the amplitude of the bifurcated solution. Useful to magnify the bifurcated solution when the bifurcated branch is very steep.\nnev number of eigenvalues to be computed to get the right eigenvector\nissymmetric whether the Jacobian is Symmetric, avoid computing the left eigenvectors in the computation of the reduced equation.\nusedeflation = true whether to use nonlinear deflation (see Deflated problems) to help finding the guess on the bifurcated branch\nkwargs optional arguments to be passed to continuation, the regular continuation one.\n\ntip: Advanced use\nIn the case of a very large model and use of special hardware (GPU, cluster), we suggest to discouple the computation of the reduced equation, the predictor and the bifurcated branches. Have a look at methods(BifurcationKit.multicontinuation) to see how to call these versions. These methods has been tested on GPU with very high memory pressure.\n\n\n\n\n\n","category":"method"},{"location":"library/#Branch-switching-(Hopf-point)","page":"Library","title":"Branch switching (Hopf point)","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"continuation(F, dF, d2F, d3F, br::BifurcationKit.AbstractBranchResult, ind_bif::Int, _contParams::ContinuationPar, prob::BifurcationKit.AbstractPeriodicOrbitProblem ; Jᵗ = nothing, δ = 1e-8, δp = nothing, ampfactor = 1, usedeflation = false, nev = _contParams.nev, updateSectionEveryStep = 0, kwargs...)","category":"page"},{"location":"library/#BifurcationKit.continuation-Tuple{Any, Any, Any, Any, BifurcationKit.AbstractBranchResult, Int64, ContinuationPar, BifurcationKit.AbstractPeriodicOrbitProblem}","page":"Library","title":"BifurcationKit.continuation","text":"continuation(F, dF, d2F, d3F, br, ind_bif, _contParams, prob; Jᵗ, δ, δp, ampfactor, usedeflation, nev, updateSectionEveryStep, kwargs...)\n\n\nPerform automatic branch switching from a Hopf bifurcation point labelled ind_bif in the list of the bifurcated points of a previously computed branch br::ContResult. It first computes a Hopf normal form.\n\nArguments\n\nF, dF, d2F, d3F: function (x,p) -> F(x,p) and its differentials (x,p,dx) -> d1F(x,p,dx), (x,p,dx1,dx2) -> d2F(x,p,dx1,dx2)... These are used to compute the Hopf normal form.\nbr branch result from a call to continuation\nind_hopf index of the bifurcation point in br\ncontParams parameters for the call to continuation\nprob problem used to specify the way the periodic orbit is computed. It can be PeriodicOrbitTrapProblem, ShootingProblem or PoincareShootingProblem .\n\nOptional arguments\n\nlinearPO linear algorithm used for the computation of periodic orbits when prob is PeriodicOrbitTrapProblem)\nJᵗ is the jacobian adjoint, used for computation of the eigen-elements of the jacobian adjoint, needed to compute the spectral projector for the Hopf normal form. For matrix-free methods, transpose is not readily available and the user must provide a dedicated method. In the case of Matrix / Sparse based jacobian, Jᵗ should not be passed as it is computed internally more efficiently, i.e. it avoid recomputing the jacobian as it would be if you pass Jᵗ = (x, p) -> transpose(dF(x, p))\nδ = 1e-8 used for finite differences\nδp used to specify a particular guess for the parameter on the bifurcated branch which is otherwise determined by contParams.ds. This allows to use a step larger than contParams.dsmax.\nampfactor = 1 factor which alter the amplitude of the bifurcated solution. Useful to magnify the bifurcated solution when the bifurcated branch is very steep.\nusedeflation = true whether to use nonlinear deflation (see Deflated problems) to help finding the guess on the bifurcated branch\nupdateSectionEveryStep = 0 updates the section every updateSectionEveryStep step during continuation\nlinearPO specify the way the jacobian is computed.\nall kwargs from continuation\n\nA modified version of prob is passed to plotSolution and finaliseSolution.\n\nnote: Linear solver\nYou have to be careful about the options contParams.newtonOptions.linsolver. In the case of Matrix-Free solver, you have to pass the right number of unknowns N * M + 1. Note that the options for the preconditioner are not accessible yet.\n\ntip: Jacobian transpose\nThe adjoint of the jacobian J is computed internally when Jᵗ = nothing by using transpose(J) which works fine when J is an AbstractArray. In this case, do not pass the jacobian adjoint like Jᵗ = (x, p) -> transpose(d_xF(x, p)) otherwise the jacobian would be computed twice!\n\nwarning: Hessian\nThe hessian of F, when d2F is not nothing, is computed with Finite differences.\n\n\n\n\n\n","category":"method"},{"location":"library/#Bifurcation-diagram","page":"Library","title":"Bifurcation diagram","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"bifurcationdiagram","category":"page"},{"location":"library/#BifurcationKit.bifurcationdiagram","page":"Library","title":"BifurcationKit.bifurcationdiagram","text":"bifurcationdiagram(F, dF, d2F, d3F, x0, par0, lens, level, options; kwargs...)\n\n\nCompute the bifurcation diagram associated with the problem F(x, p) = 0 recursively.\n\nArguments\n\nF, dF, d2F, d3F functional and its derivatives\nx0 initial guess\npar0 parameter values at x0\nlens lens to select the parameter axis\nlevel maximum branching (or recursion) level for computing the bifurcation diagram\noptions = (x, p, level) -> contparams this function allows to change the continuation options depending on the branching level. The argument x, p denotes the current solution to F(x, p)=0.\nkwargs optional arguments. Look at bifurcationdiagram! for more details.\n\nSimplified call:\n\nWe also provide the call\n\nbifurcationdiagram(F, dF, d2F, d3F, br::ContResult, level::Int, options; kwargs...)\n\nwhere br is a branch computed after a call to continuation from which we want to compute the bifurcating branches recursively.\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"bifurcationdiagram!","category":"page"},{"location":"library/#BifurcationKit.bifurcationdiagram!","page":"Library","title":"BifurcationKit.bifurcationdiagram!","text":"bifurcationdiagram!(F, dF, d2F, d3F, node, maxlevel, options; code, usedeflation, halfbranch, kwargs...)\n\n\nSimilar to bifurcationdiagram but you pass a previously computed node from which you want to further compute the bifurcated branches. It is usually used with node = getBranch(diagram, code) from a previously computed bifurcation diagram.\n\nArguments\n\nnode::BifDiagNode a node in the bifurcation diagram\nmaxlevel = 1 required maximal level of recursion.\noptions = (x, p, level) -> contparams this function allows to change the continuation options depending on the branching level. The argument x, p denotes the current solution to F(x, p)=0.\n\nOptional arguments\n\ncode = \"0\"\nusedeflation = false\nhalfbranch = false for Pitchfork/Transcritical bifurcations, compute only half of the branch. Can be useful when there are symmetries.\nkwargs optional arguments as for continuation but also for the different versions listed in Continuation.\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"getBranch","category":"page"},{"location":"library/#BifurcationKit.getBranch","page":"Library","title":"BifurcationKit.getBranch","text":"getBranch(tree, code)\n\n\nReturn the part of the tree (bifurcation diagram) by recursively descending down the tree using the Int valued tuple code. For example getBranch(tree, (1,2,3,)) returns tree.child[1].child[2].child[3].\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"getBranchesFromBP","category":"page"},{"location":"library/#BifurcationKit.getBranchesFromBP","page":"Library","title":"BifurcationKit.getBranchesFromBP","text":"getBranchesFromBP(tree, indbif)\n\n\nReturn the part of the tree corresponding to the indbif-th bifurcation point on the root branch.\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"BifurcationKit.SpecialPoint","category":"page"},{"location":"library/#BifurcationKit.SpecialPoint","page":"Library","title":"BifurcationKit.SpecialPoint","text":"struct SpecialPoint{T, Tp, Tv} <: BifurcationKit.AbstractBifurcationPoint\n\nStructure to record a generic special (bifurcation) point.\n\ntype::Symbol\nBifurcation type, :hopf, :bp.... Default: :none\nidx::Int64\nIndex in br.eig (see ContResult) for which the bifurcation occurs. Default: 0\nparam::Any\nParameter value at the special (bifurcation) point, this is an estimate. Default: 0.0\nnorm::Any\nNorm of the equilibrium at the special (bifurcation) point Default: 0.0\nprintsol::Any\nprintsol = recordFromSolution(x, param) where recordFromSolution is one of the arguments to continuation Default: 0.0\nx::Any\nEquilibrium at the special (bifurcation) point Default: Vector{T}(undef, 0)\ntau::BorderedArray{Tv, T} where {T, Tv}\nTangent along the branch at the special (bifurcation) point Default: BorderedArray(x, T(0))\nind_ev::Int64\nEigenvalue index responsible for the special (bifurcation) (if applicable) Default: 0\nstep::Int64\nContinuation step at which the special (bifurcation) occurs Default: 0\nstatus::Symbol\nstatus ∈ {:converged, :guess} indicates whether the bisection algorithm was successful in detecting the special (bifurcation) point Default: :guess\nδ::Tuple{Int64, Int64}\nδ = (δr, δi) where δr indicates the change in the number of unstable eigenvalues and δi indicates the change in the number of unstable eigenvalues with nonzero imaginary part. abs(δr) is thus an estimate of the dimension of the kernel of the Jacobian at the special (bifurcation) point. Default: (0, 0)\nprecision::Any\nPrecision in the location of the special (bifurcation) point Default: -1\ninterval::Tuple{T, T} where T\nInterval containing the special (bifurcation) point Default: (0, 0)\n\n\n\n\n\n","category":"type"},{"location":"library/#Utils-for-periodic-orbits","page":"Library","title":"Utils for periodic orbits","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"getPeriod","category":"page"},{"location":"library/#BifurcationKit.getPeriod","page":"Library","title":"BifurcationKit.getPeriod","text":"getPeriod(prob, x, p)\n\n\nCompute the period of the periodic orbit associated to x.\n\n\n\n\n\ngetPeriod(sh, x)\ngetPeriod(sh, x, par)\n\n\nCompute the period of the periodic orbit associated to x.\n\n\n\n\n\ngetPeriod(psh, x_bar, par)\n\n\nCompute the period of the periodic orbit associated to x_bar.\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"getAmplitude","category":"page"},{"location":"library/#BifurcationKit.getAmplitude","page":"Library","title":"BifurcationKit.getAmplitude","text":"getAmplitude(prob, x, p; ratio)\n\n\nCompute the amplitude of the periodic orbit associated to x. The keyword argument ratio = 1 is used as follows. If length(x) = 1 + ratio * n, the call returns the amplitude over x[1:n].\n\n\n\n\n\ngetAmplitude(prob, x, p; ratio)\n\n\nCompute the amplitude of the periodic orbit associated to x. The keyword argument ratio = 1 is used as follows. If length(x) = ratio * n, the call returns the amplitude over x[1:n].\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"getMaximum","category":"page"},{"location":"library/#BifurcationKit.getMaximum","page":"Library","title":"BifurcationKit.getMaximum","text":"getMaximum(prob, x, p; ratio)\n\n\nCompute the maximum of the periodic orbit associated to x. The keyword argument ratio = 1 is used as follows. If length(x) = 1 + ratio * n, the call returns the amplitude over x[1:n].\n\n\n\n\n\ngetMaximum(prob, x, p; ratio)\n\n\nCompute the maximum of the periodic orbit associated to x. The keyword argument ratio = 1 is used as follows. If length(x) = ratio * n, the call returns the amplitude over x[1:n].\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"SectionSS","category":"page"},{"location":"library/#BifurcationKit.SectionSS","page":"Library","title":"BifurcationKit.SectionSS","text":"struct SectionSS{Tn, Tc} <: BifurcationKit.AbstractSection\n\nThis composite type (named for Section Standard Shooting) encodes a type of section implemented by a hyperplane. It can be used in conjunction with ShootingProblem. The hyperplane is defined by a point center and a normal.\n\nnormal::Any\nNormal to define hyperplane\ncenter::Any\nRepresentative point on hyperplane\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"SectionPS","category":"page"},{"location":"library/#BifurcationKit.SectionPS","page":"Library","title":"BifurcationKit.SectionPS","text":"struct SectionPS{Tn, Tc, Tnb, Tcb} <: BifurcationKit.AbstractSection\n\nThis composite type (named for SectionPoincaréShooting) encodes a type of Poincaré sections implemented by hyperplanes. It can be used in conjunction with PoincareShootingProblem. Each hyperplane is defined par a point (one example in centers) and a normal (one example in normals).\n\nM::Int64\nnormals::Any\ncenters::Any\nindices::Vector{Int64}\nnormals_bar::Any\ncenters_bar::Any\n\nConstructor(s)\n\nSectionPS(normals::Vector{Tv}, centers::Vector{Tv})\n\n\n\n\n\n","category":"type"},{"location":"library/#Misc.","page":"Library","title":"Misc.","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"PrecPartialSchurKrylovKit","category":"page"},{"location":"library/#BifurcationKit.PrecPartialSchurKrylovKit","page":"Library","title":"BifurcationKit.PrecPartialSchurKrylovKit","text":"PrecPartialSchurKrylovKit(J, x0, nev, which = :LM; krylovdim = max(2nev, 20), verbosity = 0)\n\nBuilds a preconditioner based on deflation of nev eigenvalues chosen according to which. A partial Schur decomposition is computed (Matrix-Free), using the package KrylovKit.jl, from which a projection is built. The options are similar to the ones of EigKrylovKit().\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"PrecPartialSchurArnoldiMethod","category":"page"},{"location":"library/#BifurcationKit.PrecPartialSchurArnoldiMethod","page":"Library","title":"BifurcationKit.PrecPartialSchurArnoldiMethod","text":"PrecPartialSchurArnoldiMethod(J, N, nev, which = LM(); tol = 1e-9, kwargs...)\n\nBuilds a preconditioner based on deflation of nev eigenvalues chosen according to which. A partial Schur decomposition is computed (Matrix-Free), using the package ArnoldiMethod.jl, from which a projection is built. See the package ArnoldiMethod.jl for how to pass the proper options.\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"Flow","category":"page"},{"location":"library/#BifurcationKit.Flow","page":"Library","title":"BifurcationKit.Flow","text":"struct Flow{TF, Tf, Tts, Tff, Td, Tse, Tprob, TprobMono, Tfs}\n\nF::Any\nThe vector field (x, p) -> F(x, p) associated to a Cauchy problem, Default: nothing\nflow::Any\nThe flow (or semigroup) associated to the Cauchy problem (x, p, t) -> flow(x, p, t). Only the last time point must be returned. Default: nothing\nflowTimeSol::Any\nFlow which returns the tuple (t, u(t)). Optional, mainly used for plotting on the user side. Please use nothing as default. Default: nothing\nflowFull::Any\nThe flow (or semigroup) associated to the Cauchy problem (x, p, t) -> flow(x, p, t). The whole solution on the time interval [0,t] must be returned. It is not strictly necessary to provide this, mainly used for plotting on the user side. Please use nothing as default. Default: nothing\ndflow::Any\nThe differential dflow of the flow w.r.t. x, (x, p, dx, t) -> dflow(x, p, dx, t). One important thing is that we require dflow(x, dx, t) to return a Named Tuple: (t = t, u = flow(x, p, t), du = dflow(x, p, dx, t)), the last component being the value of the derivative of the flow. Default: nothing\ndfSerial::Any\nSerial version of dflow. Used internally when using parallel multiple shooting. Please use nothing as default. Default: nothing\nprob::Any\n[Internal] store the ODEProblem associated to the flow of the Cauchy problem Default: nothing\nprobMono::Any\n[Internal] store the ODEProblem associated to the flow of the variational problem Default: nothing\nflowSerial::Any\n[Internal] Serial version of the flow Default: nothing\n\nSimplified constructor(s)\n\nWe provide a simple constructor where you only pass the vector field F, the flow ϕ and its differential dϕ:\n\nfl = Flow(F, ϕ, dϕ)\n\nSimplified constructors for DifferentialEquations.jl\n\nThere are some simple constructors for which you only have to pass a prob::ODEProblem or prob::EnsembleProblem (for parallel computation) from DifferentialEquations.jl and an ODE time stepper like Tsit5(). Hence, you can do for example\n\nfl = Flow(F, prob, Tsit5(); kwargs...)\n\nwhere kwargs is passed to DiffEqBase::solve. If your vector field depends on parameters p, you can define a Flow using\n\nfl = Flow(F, p, prob, Tsit5(); kwargs...)\n\nFinally, you can pass two ODEProblem where the second one is used to compute the variational equation:\n\nfl = Flow(F, p, prob1::ODEProblem, alg1, prob2::ODEProblem, alg2; kwargs...)\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"FloquetQaD","category":"page"},{"location":"library/#BifurcationKit.FloquetQaD","page":"Library","title":"BifurcationKit.FloquetQaD","text":"floquet = FloquetQaD(eigsolver::AbstractEigenSolver)\n\nThis composite type implements the computation of the eigenvalues of the monodromy matrix in the case of periodic orbits problems (based on the Shooting method or Finite Differences (Trapeze method)), also called the Floquet multipliers. The method, dubbed Quick and Dirty (QaD), is not numerically very precise for large / small Floquet exponents. It allows, nevertheless, to detect bifurcations. The arguments are as follows:\n\neigsolver::AbstractEigenSolver solver used to compute the eigenvalues.\n\nIf eigsolver == DefaultEig(), then the monodromy matrix is formed and its eigenvalues are computed. Otherwise, a Matrix-Free version of the monodromy is used.\n\ndanger: Floquet multipliers computation\nThe computation of Floquet multipliers is necessary for the detection of bifurcations of periodic orbits (which is done by analyzing the Floquet exponents obtained from the Floquet multipliers). Hence, the eigensolver eigsolver needs to compute the eigenvalues with largest modulus (and not with largest real part which is their default behavior). This can be done by changing the option which = :LM of eigsolver. Nevertheless, note that for most implemented eigensolvers in the current Package, the proper option is set.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"guessFromHopf(br, ind_hopf, eigsolver::AbstractEigenSolver, M, amplitude; phase = 0)","category":"page"},{"location":"library/#BifurcationKit.guessFromHopf-Tuple{Any, Any, AbstractEigenSolver, Any, Any}","page":"Library","title":"BifurcationKit.guessFromHopf","text":"guessFromHopf(br, ind_hopf, eigsolver::AbstractEigenSolver, M, amplitude; phase = 0)\n\nThis function returns several useful quantities regarding a Hopf bifurcation point. More precisely, it returns:\n\nthe parameter value at which a Hopf bifurcation occurs\nthe period of the bifurcated periodic orbit\na guess for the bifurcated periodic orbit\nthe equilibrium at the Hopf bifurcation point\nthe eigenvector at the Hopf bifurcation point.\n\nThe arguments are\n\nbr: the continuation branch which lists the Hopf bifurcation points\nind_hopf: index of the bifurcation branch, as in br.specialpoint\neigsolver: the eigen solver used to find the eigenvectors\nM number of time slices in the periodic orbit guess\namplitude: amplitude of the periodic orbit guess\n\n\n\n\n\n","category":"method"},{"location":"library/","page":"Library","title":"Library","text":"computeNormalForm","category":"page"},{"location":"library/#BifurcationKit.computeNormalForm","page":"Library","title":"BifurcationKit.computeNormalForm","text":"computeNormalForm(F, dF, d2F, d3F, br, id_bif; δ, nev, Jᵗ, verbose, ζs, lens, issymmetric, Teigvec, scaleζ)\n\n\nCompute the normal form of the bifurcation point located at br.specialpoint[ind_bif].\n\nArguments\n\nF, dF, d2F, d3F vector field (x, p) -> F(x, p) and its derivatives w.r.t. x.\nbr result from a call to continuation\nind_bif index of the bifurcation point in br.specialpoint\n\nOptional arguments\n\nδ used to compute ∂pF with finite differences\nnev number of eigenvalues used to compute the spectral projection. This number has to be adjusted when used with iterative methods.\nJᵗ = (x,p) -> ... jacobian adjoint, it should be implemented in an efficient manner. For matrix-free methods, transpose is not readily available and the user must provide a dedicated method. In the case of sparse based jacobian, Jᵗ should not be passed as it is computed internally more efficiently, i.e. it avoids recomputing the jacobian as it would be if you pass Jᵗ = (x, p) -> transpose(dF(x, p)).\nverbose whether to display information\nζs list of vectors spanning the kernel of dF at the bifurcation point. Useful to enforce the basis for the normal form.\nlens::Lens specify which parameter to take the partial derivative ∂pF\nissymmetric whether the Jacobian is Symmetric, avoid computing the left eigenvectors.\nscaleζ function to normalise the kernel basis. Indeed, when used with large vectors and norm, it results in ζs and the normal form coefficient being super small.\n\nBased on Golubitsky, Martin, David G Schaeffer, and Ian Stewart. Singularities and Groups in Bifurcation Theory. New York: Springer-Verlag, 1985, VI.1.d page 295.\n\n\n\n\n\n","category":"function"},{"location":"tutorials1b/#Temperature-model-with-ApproxFun-(intermediate)","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"","category":"section"},{"location":"tutorials1b/","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"Pages = [\"tutorials1b.md\"]\nDepth = 3","category":"page"},{"location":"tutorials1b/","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"We reconsider the first example by relying on the package ApproxFun.jl which allows very precise function approximation. ","category":"page"},{"location":"tutorials1b/","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"This is one example where the state space, the space of solutions to the nonlinear equation, is not a subtype of AbstractArray. See Requested methods for Custom State for more informations.","category":"page"},{"location":"tutorials1b/","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"We start with some imports:","category":"page"},{"location":"tutorials1b/","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"using ApproxFun, LinearAlgebra, Parameters, Setfield\n\nusing BifurcationKit, Plots\nconst BK = BifurcationKit","category":"page"},{"location":"tutorials1b/","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"We then need to add some methods not available in ApproxFun because the state space is not a subtype of AbstractArray:","category":"page"},{"location":"tutorials1b/","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"# specific methods for ApproxFun\nimport Base: eltype, similar, copyto!, length\nimport LinearAlgebra: mul!, rmul!, axpy!, axpby!, dot, norm\n\nsimilar(x::ApproxFun.Fun, T) = (copy(x))\nsimilar(x::ApproxFun.Fun) = copy(x)\nmul!(w::ApproxFun.Fun, v::ApproxFun.Fun, α) = (w .= α * v)\n\neltype(x::ApproxFun.Fun) = eltype(x.coefficients)\nlength(x::ApproxFun.Fun) = length(x.coefficients)\n\ndot(x::ApproxFun.Fun, y::ApproxFun.Fun) = sum(x * y)\n\naxpy!(a, x::ApproxFun.Fun, y::ApproxFun.Fun) = (y .= a * x + y)\naxpby!(a::Float64, x::ApproxFun.Fun, b::Float64, y::ApproxFun.Fun) = (y .= a * x + b * y)\nrmul!(y::ApproxFun.Fun, b::Float64) = (y.coefficients .*= b; y)\nrmul!(y::ApproxFun.Fun, b::Bool) = b == true ? y : (y.coefficients .*= 0; y)\n\ncopyto!(x::ApproxFun.Fun, y::ApproxFun.Fun) = ( (x.coefficients = copy(y.coefficients);x))","category":"page"},{"location":"tutorials1b/","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"We can easily write our functional with boundary conditions in a convenient manner using ApproxFun:","category":"page"},{"location":"tutorials1b/","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"N(x; a = 0.5, b = 0.01) = 1 + (x + a*x^2)/(1 + b*x^2)\ndN(x; a = 0.5, b = 0.01) = (1-b*x^2+2*a*x)/(1+b*x^2)^2\n\nfunction F_chan(u, p)\n\t@unpack alpha, beta = p\n\treturn [Fun(u(0.), domain(u)) - beta,\n\t\tFun(u(1.), domain(u)) - beta,\n\t\tΔ * u + alpha * N(u, b = beta)]\nend\n\nfunction Jac_chan(u, p)\n\t@unpack alpha, beta = p\n\treturn [Evaluation(u.space, 0.),\n\t\tEvaluation(u.space, 1.),\n\t\tΔ + alpha * dN(u, b = beta)]\nend","category":"page"},{"location":"tutorials1b/","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"We want to call a Newton solver. We first need an initial guess and the Laplacian operator:","category":"page"},{"location":"tutorials1b/","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"sol = Fun(x -> x * (1-x), Interval(0.0, 1.0))\nconst Δ = Derivative(sol.space, 2)\n# set of parameters\npar_af = (alpha = 3., beta = 0.01)","category":"page"},{"location":"tutorials1b/","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"Finally, we need to provide some parameters for the Newton iterations. This is done by calling","category":"page"},{"location":"tutorials1b/","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"optnewton = NewtonPar(tol = 1e-12, verbose = true)","category":"page"},{"location":"tutorials1b/","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"We call the Newton solver:","category":"page"},{"location":"tutorials1b/","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"out, = @time BK.newton(F_chan, Jac_chan, sol, par_af, optnewton, normN = x -> norm(x, Inf64))","category":"page"},{"location":"tutorials1b/","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"and you should see","category":"page"},{"location":"tutorials1b/","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"┌─────────────────────────────────────────────────────┐\n│ Newton Iterations      f(x)      Linear Iterations  │\n├─────────────┐──────────────────────┐────────────────┤\n│       0     │       1.5707e+00     │        0       │\n│       1     │       1.1546e-01     │        1       │\n│       2     │       8.0149e-04     │        1       │\n│       3     │       3.9038e-08     │        1       │\n│       4     │       7.9049e-13     │        1       │\n└─────────────┴──────-───────────────┴────────────────┘\n  0.103869 seconds (362.15 k allocations: 14.606 MiB)","category":"page"},{"location":"tutorials1b/","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"We can also perform numerical continuation with respect to the parameter alpha. Again, we need to provide some parameters for the continuation:","category":"page"},{"location":"tutorials1b/","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"optcont = ContinuationPar(dsmin = 0.0001, dsmax = 0.05, ds= 0.005, pMax = 4.1, plotEveryStep = 10, newtonOptions = NewtonPar(tol = 1e-8, maxIter = 20, verbose = true), maxSteps = 200)","category":"page"},{"location":"tutorials1b/","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"We provide a callback function to check how the ApproxFun solution vector grows during the continuation:","category":"page"},{"location":"tutorials1b/","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"function finalise_solution(z, tau, step, contResult; k...)\n\tprintstyled(color=:red,\"--> AF length = \", (z, tau) .|> length ,\"\\n\")\n\ttrue\nend","category":"page"},{"location":"tutorials1b/","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"Then, we can call the continuation routine","category":"page"},{"location":"tutorials1b/","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"br, = @time continuation(F_chan, Jac_chan, out, par_af, (@lens _.alpha), optcont,\n\tplot = true,\n\tplotSolution = (x, p; kwargs...) -> plot!(x; label = \"l = $(length(x))\", kwargs...),\n\tverbosity = 2,\n\tnormC = x -> norm(x, Inf64))","category":"page"},{"location":"tutorials1b/","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"and you should see","category":"page"},{"location":"tutorials1b/","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"(Image: )","category":"page"},{"location":"faq/#FAQ","page":"Frequently Asked Questions","title":"FAQ","text":"","category":"section"},{"location":"faq/#How-can-I-save-a-solution-every-n-steps,-or-at-specific-parameter-values?","page":"Frequently Asked Questions","title":"How can I save a solution every n steps, or at specific parameter values?","text":"","category":"section"},{"location":"faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"You can use the callback finaliseSolution in the function call continuation. For example, you can use something like this to save all steps","category":"page"},{"location":"faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"function mySave(u, tau, step, contResult, personaldata)\n\tpush!(personaldata, u)\nend","category":"page"},{"location":"faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"and pass it like continuation(F, J, u, p0, finaliseSolution = (z, tau, step, contResult; k...) -> mySave(z, tau, step, contResult, myData))","category":"page"},{"location":"faq/#The-Fold-/-Hopf-Continuation-does-not-work,-why?","page":"Frequently Asked Questions","title":"The Fold / Hopf Continuation does not work, why?","text":"","category":"section"},{"location":"faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"This requires some precise computations. Have you tried passing the expression of the Jacobian instead of relying on finite differences.","category":"page"},{"location":"faq/#What-is-the-parameter-theta-about-in-ContinuationPar?","page":"Frequently Asked Questions","title":"What is the parameter theta about in ContinuationPar?","text":"","category":"section"},{"location":"faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"See the description of continuation on the page Library.","category":"page"},{"location":"faq/#How-can-I-change-the-preconditioner-during-computations?","page":"Frequently Asked Questions","title":"How can I change the preconditioner during computations?","text":"","category":"section"},{"location":"faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"The easiest way to achieve this is by using the callbacks provided by newton and continuation. See the documentation about these two methods. See also the example 2d Ginzburg-Landau equation (finite differences)","category":"page"},{"location":"faq/#How-can-I-implement-my-own-bifurcation-detection-method?","page":"Frequently Asked Questions","title":"How can I implement my own bifurcation detection method?","text":"","category":"section"},{"location":"faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"You can use the callback finaliseSolution but the best way is probably to use the Iterator Interface to inject your code anywhere in the continuation procedure. ","category":"page"},{"location":"faq/#How-do-I-dissociate-the-computation-of-eigenvalues-from-the-jacobian-that-I-passed?","page":"Frequently Asked Questions","title":"How do I dissociate the computation of eigenvalues from the jacobian that I passed?","text":"","category":"section"},{"location":"faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Sometimes, for example when implementing boundary conditions, you pass a jacobian J but the eigenvalues, and the bifurcation points are not simply related to J. One way to bypass this issue is to define a new eigensolver <: AbstractEigenSolver and pass it to the NewtonPar field eigsolver. This is done for example in example/SH2d-fronts-cuda.jl.","category":"page"},{"location":"faq/#How-can-I-print-the-eigenvalues-during-continuation?","page":"Frequently Asked Questions","title":"How can I print the eigenvalues during continuation?","text":"","category":"section"},{"location":"faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"You can print the eigenvalues using the following callback:","category":"page"},{"location":"faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"finaliseSolution = (z, tau, step, contResult; k...) -> begin\n\t\tBK.haseigenvalues(contResult) && Base.display(contResult.eig[end].eigenvals)\n\t\treturn true\n\tend,","category":"page"},{"location":"faq/#How-can-I-reject-a-Newton-Step?","page":"Frequently Asked Questions","title":"How can I reject a Newton Step?","text":"","category":"section"},{"location":"faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"You can reject a newton step by passing to continuation the argument callbackN ","category":"page"},{"location":"faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"function mycallback(x, f, J, res, iteration, itlinear, options; kwargs...)\n\t# stop Newton algo if residual too large\n\tif res > 1e2\n\t\t@warn \"Reject Newton step!!\"\n\t\treturn false\n\tend\n\treturn true\nend","category":"page"},{"location":"faq/#How-do-I-stop-continuation?","page":"Frequently Asked Questions","title":"How do I stop continuation?","text":"","category":"section"},{"location":"faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Using the argument finaliseSolution in continuation. Simply make this function finaliseSolution return false.","category":"page"},{"location":"faq/#How-do-I-compute-both-sides-of-a-branch?","page":"Frequently Asked Questions","title":"How do I compute both sides of a branch?","text":"","category":"section"},{"location":"faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Instead of using two calls to continuation, you can pass the keyword bothside=true to continuation","category":"page"},{"location":"branchswitching/#Branch-switching-page","page":"Branch switching","title":"Branch switching","text":"","category":"section"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"The precise definition of the methods are given Branch switching (branch point) and Branch switching (Hopf point).","category":"page"},{"location":"branchswitching/#Branch-switching-from-simple-branch-point-to-equilibria","page":"Branch switching","title":"Branch switching from simple branch point to equilibria","text":"","category":"section"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"You can perform automatic branch switching by calling continuation with the following options:","category":"page"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"continuation(F, dF, d2F, d3F, br::ContResult, ind_bif::Int, optionsCont::ContinuationPar;\n\tJᵗ = nothing, δ = 1e-8, nev = 5, verbose = false, kwargs...)","category":"page"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"where br is a branch computed after a call to continuation with detection of bifurcation points enabled. This call computes the branch bifurcating from the ind_bifth bifurcation point in br. An example of use is provided in 2d generalized Bratu–Gelfand problem.","category":"page"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"See Branch switching (branch point) precise method definition","category":"page"},{"location":"branchswitching/#Branch-switching-from-non-simple-branch-point-to-equilibria","page":"Branch switching","title":"Branch switching from non simple branch point to equilibria","text":"","category":"section"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"We provide an experimental automatic branch switching method in this case. The method is to first compute the reduced equation (see Non-simple branch point) and use it to compute the nearby solutions. These solutions are seeded as initial guess for continuation. Hence, you can perform automatic branch switching by calling continuation with the following options:","category":"page"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"continuation(F, dF, d2F, d3F, br::ContResult, ind_bif::Int, optionsCont::ContinuationPar;\n\tJᵗ = nothing, δ = 1e-8, nev = 5, verbose = false, kwargs...)","category":"page"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"An example of use is provided in 2d generalized Bratu–Gelfand problem.","category":"page"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"See Branch switching (branch point) for precise method definition","category":"page"},{"location":"branchswitching/#Branch-switching-from-Hopf-point-to-periodic-orbits","page":"Branch switching","title":"Branch switching from Hopf point to periodic orbits","text":"","category":"section"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"In order to compute the bifurcated branch of periodic solutions at a Hopf bifurcation point, you need to choose a method. Indeed, we provide two methods to compute periodic orbits:","category":"page"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"Periodic orbits based on trapezoidal rule\nPeriodic orbits based on the shooting method","category":"page"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"Once you have decided which method you want, you can call the following method.","category":"page"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"continuation(F, dF, d2F, d3F, br::ContResult, ind_bif::Int, _contParams::ContinuationPar, prob::AbstractPeriodicOrbitProblem ;\n\tJᵗ = nothing, δ = 1e-8, δp = nothing, ampfactor = 1, kwargs...)","category":"page"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"We refer to continuation for more information about the arguments. Here, we just say a few words about how we can specify prob::AbstractPeriodicOrbitProblem. For Periodic orbits based on trapezoidal rule, you can pass prob = PeriodicOrbitTrapProblem(M = 51) where M is the number of times slices in the periodic orbit. For Periodic orbits based on the shooting method, you need more parameters. For example, you can pass prob = ShootingProblem(2, par, prob, Euler()) or prob = PoincareShootingProblem(2, par, prob, Euler()) where prob::ODEProblem is an ODE problem to specify the Cauchy problem and par is the set of parameters passed to the vector field and which must be the same as br.params.","category":"page"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"Several examples are provided like 1d Brusselator (automatic) or 2d Ginzburg-Landau equation (finite differences).","category":"page"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"See Branch switching (Hopf point) precise method definition","category":"page"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"tip: Precise options\nAlthough very convenient, the automatic branch switching does not allow the very fine tuning of parameters. It must be used as a first attempt before recurring to manual branch switching","category":"page"},{"location":"branchswitching/#Branch-switching-from-Branch-point-of-curve-of-periodic-orbits","page":"Branch switching","title":"Branch switching from Branch point of curve of periodic orbits","text":"","category":"section"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"We only provide (for now) this method for the case of PeriodicOrbitTrapProblem. The call is as follows. Please note that a deflation is included in this method to simplify branch switching. ","category":"page"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"An example of use is provided in 1d Brusselator (automatic).","category":"page"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"continuationPOTrapBPFromPO","category":"page"},{"location":"branchswitching/#BifurcationKit.continuationPOTrapBPFromPO","page":"Branch switching","title":"BifurcationKit.continuationPOTrapBPFromPO","text":"continuationPOTrapBPFromPO(br, ind_bif, _contParams; Jᵗ, δ, δp, ampfactor, usedeflation, linearPO, recordFromSolution, linearAlgo, updateSectionEveryStep, kwargs...)\n\n\nBranch switching at a Branch point of periodic orbits specified by a PeriodicOrbitTrapProblem. This is still experimental. A deflated Newton-Krylov solver is used to improve the branch switching capabilities.\n\nArguments\n\nbr branch of periodic orbits computed with a PeriodicOrbitTrapProblem\nind_bif index of the branch point\n_contParams parameters to be used by a regular continuation\n\nOptional arguments\n\nJᵗ = (x, p) -> transpose(d_xF(x, p)) jacobian adjoint, it should be implemented in an efficient manner. For matrix-free methods, transpose is not readily available and the user must provide a dedicated method. In the case of sparse based jacobian, Jᵗ should not be passed as it is computed internally more efficiently, i.e. it avoid recomputing the jacobian as it would be if you pass Jᵗ = (x, p) -> transpose(dF(x, p))\nδ used internally to compute derivatives w.r.t the parameter p.\nδp = 0.1 used to specify a particular guess for the parameter in the branch which is otherwise determined by contParams.ds. This allows to use a step larger than contParams.dsmax.\nampfactor = 1 factor which alter the amplitude of the bifurcated solution. Useful to magnify the bifurcated solution when the bifurcated branch is very steep.\nusedeflation = true whether to use nonlinear deflation (see Deflated problems) to help finding the guess on the bifurcated branch\nlinearPO = :BorderedLU linear solver used for the Newton-Krylov solver when applied to PeriodicOrbitTrapProblem.\nrecordFromSolution = (u, p) -> u[end], print method used in the bifurcation diagram, by default this prints the period of the periodic orbit.\nlinearAlgo = BorderingBLS(), same as for continuation\nkwargs keywords arguments used for a call to the regular continuation\nupdateSectionEveryStep = 1 updates the section every when mod(step, updateSectionEveryStep) == 1 during continuation\n\n\n\n\n\n","category":"function"},{"location":"simplehopf/#Simple-Hopf-point","page":"Simple Hopf point","title":"Simple Hopf point","text":"","category":"section"},{"location":"simplehopf/","page":"Simple Hopf point","title":"Simple Hopf point","text":"At a Hopf branch point (x_0p_0) for the problem F(xp)=0, we have Sigma dF(x_0p_0) = pm iomega  omega  0. At such point, we can compute the normal form to transform the initial Cauchy problem","category":"page"},{"location":"simplehopf/","page":"Simple Hopf point","title":"Simple Hopf point","text":"dot x = F(xp)","category":"page"},{"location":"simplehopf/","page":"Simple Hopf point","title":"Simple Hopf point","text":"in large dimensions to a complex polynomial vector field (delta pequiv p-p_0): ","category":"page"},{"location":"simplehopf/","page":"Simple Hopf point","title":"Simple Hopf point","text":"dot z = zleft(a cdotdelta p + iomega + bz^2right)quadtext(E)","category":"page"},{"location":"simplehopf/","page":"Simple Hopf point","title":"Simple Hopf point","text":"whose solutions give access to the solutions of the Cauchy problem in a neighborhood of (xp).","category":"page"},{"location":"simplehopf/","page":"Simple Hopf point","title":"Simple Hopf point","text":"More precisely, if J equiv dF(x_0p_0), then we have Jzeta = iomegazeta and Jbarzeta = -iomegabarzeta for some complex eigenvector zeta. It can be shown that x(t) approx x_0 + 2Re(z(t)zeta) when p=p_0+delta p.","category":"page"},{"location":"simplehopf/#Normal-form-computation","page":"Simple Hopf point","title":"Normal form computation","text":"","category":"section"},{"location":"simplehopf/","page":"Simple Hopf point","title":"Simple Hopf point","text":"The normal form (E) is automatically computed as follows","category":"page"},{"location":"simplehopf/","page":"Simple Hopf point","title":"Simple Hopf point","text":"computeNormalForm(F, dF, d2F, d3F, br::ContResult, ind_bif::Int ; δ = 1e-8,\n\tnev = 5, Jᵗ = nothing, verbose = false, ζs = nothing, lens = br.param_lens)","category":"page"},{"location":"simplehopf/","page":"Simple Hopf point","title":"Simple Hopf point","text":"where dF, d2F,d3F are the differentials of F. br is a branch computed after a call to continuation with detection of bifurcation points enabled and ind_bif is the index of the bifurcation point on the branch br. The above call returns a point with information needed to compute the bifurcated branch. For more information about the optional parameters, we refer to [computeNormalForm`](@ref). The above call returns a point with information needed to compute the bifurcated branch.","category":"page"},{"location":"simplehopf/","page":"Simple Hopf point","title":"Simple Hopf point","text":"mutable struct Hopf{Tv, T, Tω, Tevr, Tevl, Tnf} <: BifurcationPoint\n\t\"Hopf point\"\n\tx0::Tv\n\n\t\"Parameter value at the Hopf point\"\n\tp::T\n\n\t\"Frequency of the Hopf point\"\n\tω::Tω\n\n\t\"Right eigenvector\"\n\tζ::Tevr\n\n\t\"Left eigenvector\"\n\tζstar::Tevl\n\n\t\"Normal form coefficient (a = 0., b = 1 + 1im)\"\n\tnf::Tnf\n\n\t\"Type of Hopf bifurcation\"\n\ttype::Symbol\nend","category":"page"},{"location":"simplehopf/","page":"Simple Hopf point","title":"Simple Hopf point","text":"info: Note\nYou should not need to call computeNormalForm except if you need the full information about the branch point. ","category":"page"},{"location":"tutorialPP2/#pp2-example-from-AUTO07p-(aBD-Hopf-aBS)","page":"pp2 example from AUTO07p (aBD + Hopf aBS)","title":"pp2 example from AUTO07p (aBD + Hopf aBS)","text":"","category":"section"},{"location":"tutorialPP2/","page":"pp2 example from AUTO07p (aBD + Hopf aBS)","title":"pp2 example from AUTO07p (aBD + Hopf aBS)","text":"Pages = [\"tutorialsPP2.md\"]\nDepth = 3","category":"page"},{"location":"tutorialPP2/","page":"pp2 example from AUTO07p (aBD + Hopf aBS)","title":"pp2 example from AUTO07p (aBD + Hopf aBS)","text":"The goal of this example is to show how to use automatic bifurcation diagram computation for a simple ODE.","category":"page"},{"location":"tutorialPP2/","page":"pp2 example from AUTO07p (aBD + Hopf aBS)","title":"pp2 example from AUTO07p (aBD + Hopf aBS)","text":"The following equations are a model of type predator-prey. The example is taken from Auto07p:","category":"page"},{"location":"tutorialPP2/","page":"pp2 example from AUTO07p (aBD + Hopf aBS)","title":"pp2 example from AUTO07p (aBD + Hopf aBS)","text":"beginarrayl\nu_1^prime=3 u_1left(1-u_1right)-u_1 u_2-p_1left(1-e^-5 u_1right) \nu_2^prime=-u_2+3 u_1 u_2\nendarray","category":"page"},{"location":"tutorialPP2/","page":"pp2 example from AUTO07p (aBD + Hopf aBS)","title":"pp2 example from AUTO07p (aBD + Hopf aBS)","text":"It is easy to encode the ODE as follows","category":"page"},{"location":"tutorialPP2/","page":"pp2 example from AUTO07p (aBD + Hopf aBS)","title":"pp2 example from AUTO07p (aBD + Hopf aBS)","text":"using Revise, Parameters, Setfield, Plots, LinearAlgebra\nusing BifurcationKit\nconst BK = BifurcationKit\n\n# define the sup norm\nnorminf(x) = norm(x, Inf)\n\n# function to record information from a solution\nrecordFromSolution(x, p) = (u1 = x[1], u2 = x[2])\n####################################################################################################\nfunction pp2!(dz, z, p, t)\n\t@unpack p1, p2, p3, p4 = p\n\tu1, u2 = z\n\tdz[1] = p2 * u1 * (1 - u1) - u1 * u2 - p1 * (1 - exp(-p3 * u1))\n\tdz[2] =\t-u2 + p4 * u1 * u2\n\tdz\nend\n\npp2(z, p) = pp2!(similar(z), z, p, 0)\njet  = BK.getJet(pp2; matrixfree=false)\n\n# parameters of the model\npar_pp2 = (p1 = 1., p2 = 3., p3 = 5., p4 = 3.)\n\n# initial condition\nz0 = zeros(2)\n\nnothing #hide","category":"page"},{"location":"tutorialPP2/#Automatic-bifurcation-diagram-computation","page":"pp2 example from AUTO07p (aBD + Hopf aBS)","title":"Automatic bifurcation diagram computation","text":"","category":"section"},{"location":"tutorialPP2/","page":"pp2 example from AUTO07p (aBD + Hopf aBS)","title":"pp2 example from AUTO07p (aBD + Hopf aBS)","text":"We set up the options or the continuation","category":"page"},{"location":"tutorialPP2/","page":"pp2 example from AUTO07p (aBD + Hopf aBS)","title":"pp2 example from AUTO07p (aBD + Hopf aBS)","text":"# continuation options\nopts_br = ContinuationPar(pMin = 0.1, pMax = 1.0, dsmax = 0.01,\n\t# options to detect bifurcations\n\tdetectBifurcation = 3, nInversion = 8, maxBisectionSteps = 25,\n\t# number of eigenvalues\n\tnev = 2,\n\t# maximal number of continuation steps\n\tmaxSteps = 1000,\n\t# parameter theta, see `? continuation`. Setting this to a non \n\t# default value helps passing the transcritical bifurcation\n\ttheta = 0.3)\n\nnothing #hide","category":"page"},{"location":"tutorialPP2/","page":"pp2 example from AUTO07p (aBD + Hopf aBS)","title":"pp2 example from AUTO07p (aBD + Hopf aBS)","text":"We are now. Ready to compute the diagram","category":"page"},{"location":"tutorialPP2/","page":"pp2 example from AUTO07p (aBD + Hopf aBS)","title":"pp2 example from AUTO07p (aBD + Hopf aBS)","text":"diagram = bifurcationdiagram(jet...,\n\t# initial point and parameter\n\tz0, par_pp2,\n\t# specify the continuation parameter\n\t(@lens _.p1),\n\t# very important parameter. This specifies the maximum amount of recursion\n\t# when computing the bifurcation diagram. It means we allow computing branches of branches\n\t# at most in the present case.\n\t3,\n\t(args...) -> setproperties(opts_br; ds = -0.001, dsmax = 0.01, nInversion = 8, detectBifurcation = 3);\n\t# δp = -0.01,\n\trecordFromSolution = recordFromSolution,\n\tverbosity = 0, plot = true)\n\nscene = plot(diagram; code = (), title=\"$(size(diagram)) branches\", legend = false)","category":"page"},{"location":"tutorialPP2/#Branch-of-periodic-orbits-with-finite-differences","page":"pp2 example from AUTO07p (aBD + Hopf aBS)","title":"Branch of periodic orbits with finite differences","text":"","category":"section"},{"location":"tutorialPP2/","page":"pp2 example from AUTO07p (aBD + Hopf aBS)","title":"pp2 example from AUTO07p (aBD + Hopf aBS)","text":"As you can see on the diagram, there is a Hopf bifurcation indicated by a red dot.  Let us compute the periodic orbit branching from the Hopf point.","category":"page"},{"location":"tutorialPP2/","page":"pp2 example from AUTO07p (aBD + Hopf aBS)","title":"pp2 example from AUTO07p (aBD + Hopf aBS)","text":"We first find the branch ","category":"page"},{"location":"tutorialPP2/","page":"pp2 example from AUTO07p (aBD + Hopf aBS)","title":"pp2 example from AUTO07p (aBD + Hopf aBS)","text":"# branch of the diagram with Hopf point\nbrH = BK.getBranch(diagram, (2,1)).γ\n\n# newton parameters\noptn_po = NewtonPar(tol = 1e-8,  maxIter = 25)\n\n# continuation parameters\nopts_po_cont = ContinuationPar(dsmax = 0.1, ds= -0.001, dsmin = 1e-4, newtonOptions = (@set optn_po.tol = 1e-8), precisionStability = 1e-2, detectBifurcation = 1, saveSolEveryStep=1)\n\nMt = 101 # number of time sections\n\tbr_po, utrap = continuation(\n\tjet..., brH, 1, opts_po_cont,\n\tPeriodicOrbitTrapProblem(M = Mt);\n\t# help branching from Hopf\n\tusedeflation = true,\n\t# specific linear solver for ODEs\n\tlinearPO = :Dense,\n\trecordFromSolution = (x, p) -> (xtt=reshape(x[1:end-1],2,Mt); \n\t\treturn (max = maximum(xtt[1,:]), \n\t\t\tmin = minimum(xtt[1,:]), \n\t\t\tperiod = x[end])),\n\tfinaliseSolution = (z, tau, step, contResult; prob = nothing, kwargs...) -> begin\n\t\t# limit the period\n\t\tz.u[end] < 100\n\t\tend,\n\tnormC = norminf)\n\n\nplot(diagram); plot!(br_po, label = \"Periodic orbits\", legend = :bottomright)","category":"page"},{"location":"tutorialPP2/","page":"pp2 example from AUTO07p (aBD + Hopf aBS)","title":"pp2 example from AUTO07p (aBD + Hopf aBS)","text":"Let us now plot an orbit","category":"page"},{"location":"tutorialPP2/","page":"pp2 example from AUTO07p (aBD + Hopf aBS)","title":"pp2 example from AUTO07p (aBD + Hopf aBS)","text":"# extract the different components\norbit  = BK.getTrajectory(br_po, 10)\nplot(orbit.t, orbit.u[1,:]; label = \"u1\", markersize = 2)\nplot!(orbit.t, orbit.u[2,:]; label = \"u2\", xlabel = \"time\", title = \"period = $(orbit.t[end])\")","category":"page"},{"location":"detectionBifurcation/#Detection-of-bifurcation-points","page":"Bifurcation detection (codim 1)","title":"Detection of bifurcation points","text":"","category":"section"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"The bifurcations are detected during a call to br, _ = continuation(F, J, u0, p0, lens, contParams::ContinuationPar;kwargs...) by turning on the following flags:","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"contParams.detectBifurcation = 2","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"The bifurcation points are located by looking at the spectrum e.g. by monitoring the unstable eigenvalues. The eigenvalue λ is declared unstable if real(λ) > contParams.precisionStability. The located bifurcation points are then returned in br.specialpoint. ","category":"page"},{"location":"detectionBifurcation/#Precise-detection-of-bifurcation-points-using-Bisection","page":"Bifurcation detection (codim 1)","title":"Precise detection of bifurcation points using Bisection","text":"","category":"section"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"Note that the bifurcation points detected when detectBifurcation = 2 are only approximate bifurcation points. Indeed, we only signal that, in between two continuation steps which can be large, a (several) bifurcation has been detected. Hence, we only have a rough idea of where the bifurcation is located, unless your dsmax is very small... This can be improved as follows.","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"If you choose detectBifurcation = 3, a bisection algorithm is used to locate the bifurcation points more precisely. It means that we recursively track down the change in stability. Some options in ContinuationPar control this behavior:","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"nInversion: number of sign inversions in the bisection algorithm\nmaxBisectionSteps maximum number of bisection steps\ntolBisectionEigenvalue tolerance on real part of eigenvalue to detect bifurcation points in the bisection steps","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"If this is still not enough, you can use a Newton solver to locate them very precisely. See Fold / Hopf Continuation.","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"tip: Bisection mode\nDuring the bisection, the eigensolvers are called like eil(J, nev; bisection = true) in order to be able to adapt the solver precision.","category":"page"},{"location":"detectionBifurcation/#Large-scale-computations","page":"Bifurcation detection (codim 1)","title":"Large scale computations","text":"","category":"section"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"The user must specify the number of eigenvalues to be computed (like nev = 10) in the parameters ::ContinuationPar passed to continuation. Note that nev is automatically incremented whenever a bifurcation point is detected [1]. Also, there is an option in ::ContinuationPar to save (or not) the eigenvectors. This can be useful in memory limited environments (like on GPUs).","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"[1]: In this case, the Krylov dimension is not increased because the eigensolver could be a direct solver. You might want to increase this dimension using the callbacks in continuation. ","category":"page"},{"location":"detectionBifurcation/#List-of-detected-bifurcation-points","page":"Bifurcation detection (codim 1)","title":"List of detected bifurcation points","text":"","category":"section"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"Bifurcation index used\nFold fold\nHopf hopf\nBifurcation point (single eigenvalue stability change, Fold or branch point) bp\nNeimark-Sacker ns\nPeriod doubling pd\nNot documented nd","category":"page"},{"location":"detectionBifurcation/#Eigensolver","page":"Bifurcation detection (codim 1)","title":"Eigensolver","text":"","category":"section"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"The user must provide an eigensolver by setting NewtonOptions.eigsolver where NewtonOptions is located in the parameter ::ContinuationPar passed to continuation. See NewtonPar and ContinuationPar for more information on the composite type of the options passed to newton and continuation.","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"The eigensolver is highly problem dependent and this is why the user should implement / parametrize its own eigensolver through the abstract type AbstractEigenSolver or select one among List of implemented eigen solvers.","category":"page"},{"location":"detectionBifurcation/#Generic-bifurcation","page":"Bifurcation detection (codim 1)","title":"Generic bifurcation","text":"","category":"section"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"By this we mean a change in the dimension of the Jacobian kernel. The detection of Branch point is done by analysis of the spectrum of the Jacobian.","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"The detection is triggered by setting detectBifurcation > 0 in the parameter ::ContinuationPar passed to continuation. ","category":"page"},{"location":"detectionBifurcation/#Fold-bifurcation","page":"Bifurcation detection (codim 1)","title":"Fold bifurcation","text":"","category":"section"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"The detection of Fold point is done by monitoring  the monotonicity of the parameter.","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"The detection is triggered by setting detectFold = true in the parameter ::ContinuationPar passed to continuation. When a Fold is detected on a branch br, a point is added to br.foldpoint allowing for later refinement using the function newtonFold.","category":"page"},{"location":"detectionBifurcation/#Hopf-bifurcation","page":"Bifurcation detection (codim 1)","title":"Hopf bifurcation","text":"","category":"section"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"The detection of Branch point is done by analysis of the spectrum of the Jacobian.","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"The detection is triggered by setting detectBifurcation > 0 in the parameter ::ContinuationPar passed to continuation. When a Hopf point is detected, a point is added to br.specialpoint allowing for later refinement using the function newtonHopf.","category":"page"},{"location":"detectionBifurcation/#Bifurcations-of-periodic-orbits","page":"Bifurcation detection (codim 1)","title":"Bifurcations of periodic orbits","text":"","category":"section"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"The detection is triggered by setting detectBifurcation > 0 in the parameter ::ContinuationPar passed to continuation. The detection of bifurcation points is done by analysis of the spectrum of the Monodromy matrix composed of the Floquet multipliers. The following bifurcations are currently detected:","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"Fold of periodic orbit\nNeimark-Sacker \nPeriod doubling","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"danger: Floquet multipliers computation\nThe computation of Floquet multipliers is necessary for the detection of bifurcations of periodic orbits (which is done by analyzing the Floquet exponents obtained from the Floquet multipliers). Hence, the eigensolver needs to compute the eigenvalues with largest modulus (and not with largest real part which is their default behavior). This can be done by changing the option which = :LM of the eigensolver. Nevertheless, note that for most implemented eigensolvers in the current Package, the proper option is set.   ","category":"page"},{"location":"tutorialsCGLShoot/#d-Ginzburg-Landau-equation-(shooting)","page":"2d Ginzburg-Landau equation (shooting)","title":"2d Ginzburg-Landau equation (shooting)","text":"","category":"section"},{"location":"tutorialsCGLShoot/","page":"2d Ginzburg-Landau equation (shooting)","title":"2d Ginzburg-Landau equation (shooting)","text":"Pages = [\"tutorialsCGLShoot.md\"]\nDepth = 3","category":"page"},{"location":"tutorialsCGLShoot/","page":"2d Ginzburg-Landau equation (shooting)","title":"2d Ginzburg-Landau equation (shooting)","text":"In this tutorial, we re-visit the example 2d Ginzburg-Landau equation (finite differences) using a Standard Simple Shooting method. In the tutorial 1d Brusselator (advanced user), we used the implicit solver Rodas4P for the shooting. We will use the exponential-RK scheme ETDRK2 ODE solver to compute the solution of cGL equations. This method is convenient for solving semilinear problems of the form ","category":"page"},{"location":"tutorialsCGLShoot/","page":"2d Ginzburg-Landau equation (shooting)","title":"2d Ginzburg-Landau equation (shooting)","text":"dot x = Ax+g(x)","category":"page"},{"location":"tutorialsCGLShoot/","page":"2d Ginzburg-Landau equation (shooting)","title":"2d Ginzburg-Landau equation (shooting)","text":"where A is the infinitesimal generator of a C_0-semigroup. We use the same beginning as in 2d Ginzburg-Landau equation (finite differences):","category":"page"},{"location":"tutorialsCGLShoot/","page":"2d Ginzburg-Landau equation (shooting)","title":"2d Ginzburg-Landau equation (shooting)","text":"using Revise\n\tusing DiffEqOperators, DifferentialEquations\n\tusing BifurcationKit, LinearAlgebra, Plots, SparseArrays, Parameters, Setfield\n\tconst BK = BifurcationKit\n\nnorminf = x -> norm(x, Inf)\n\nfunction Laplacian2D(Nx, Ny, lx, ly)\n\thx = 2lx/Nx\n\thy = 2ly/Ny\n\tD2x = CenteredDifference(2, 2, hx, Nx)\n\tD2y = CenteredDifference(2, 2, hy, Ny)\n\t\n\tQx = Dirichlet0BC(typeof(hx))\n\tQy = Dirichlet0BC(typeof(hy))\n\t\n\tD2xsp = sparse(D2x * Qx)[1]\n\tD2ysp = sparse(D2y * Qy)[1]\n\n\tA = kron(sparse(I, Ny, Ny), D2xsp) + kron(D2ysp, sparse(I, Nx, Nx))\n\treturn A, D2x\nend","category":"page"},{"location":"tutorialsCGLShoot/","page":"2d Ginzburg-Landau equation (shooting)","title":"2d Ginzburg-Landau equation (shooting)","text":"We then encode the PDE:","category":"page"},{"location":"tutorialsCGLShoot/","page":"2d Ginzburg-Landau equation (shooting)","title":"2d Ginzburg-Landau equation (shooting)","text":"function NL!(f, u, p, t = 0.)\n\t@unpack r, μ, ν, c3, c5 = p\n\tn = div(length(u), 2)\n\tu1 = @view u[1:n]\n\tu2 = @view u[n+1:2n]\n\n\tua = u1.^2 .+ u2.^2\n\n\tf1 = @view f[1:n]\n\tf2 = @view f[n+1:2n]\n\n\t@. f1 .= r * u1 - ν * u2 - ua * (c3 * u1 - μ * u2) - c5 * ua^2 * u1\n\t@. f2 .= r * u2 + ν * u1 - ua * (c3 * u2 + μ * u1) - c5 * ua^2 * u2\n\n\treturn f\nend\n\nfunction Fcgl!(f, u, p, t = 0.)\n\tmul!(f, p.Δ, u)\n\tf .= f .+ NL(u, p)\nend\n\nNL(u, p) = NL!(similar(u), u, p)\nFcgl(u, p, t = 0.) = Fcgl!(similar(u), u, p, t)\n\nfunction Jcgl(u, p, t = 0.)\n\t@unpack r, μ, ν, c3, c5, Δ = p\n\n\tn = div(length(u), 2)\n\tu1 = @view u[1:n]\n\tu2 = @view u[n+1:2n]\n\n\tua = u1.^2 .+ u2.^2\n\n\tf1u = zero(u1)\n\tf2u = zero(u1)\n\tf1v = zero(u1)\n\tf2v = zero(u1)\n\n\t@. f1u =  r - 2 * u1 * (c3 * u1 - μ * u2) - c3 * ua - 4 * c5 * ua * u1^2 - c5 * ua^2\n\t@. f1v = -ν - 2 * u2 * (c3 * u1 - μ * u2)  + μ * ua - 4 * c5 * ua * u1 * u2\n\t@. f2u =  ν - 2 * u1 * (c3 * u2 + μ * u1)  - μ * ua - 4 * c5 * ua * u1 * u2\n\t@. f2v =  r - 2 * u2 * (c3 * u2 + μ * u1) - c3 * ua - 4 * c5 * ua * u2 ^2 - c5 * ua^2\n\n\tjacdiag = vcat(f1u, f2v)\n\n\tΔ + spdiagm(0 => jacdiag, n => f1v, -n => f2u)\nend","category":"page"},{"location":"tutorialsCGLShoot/","page":"2d Ginzburg-Landau equation (shooting)","title":"2d Ginzburg-Landau equation (shooting)","text":"with parameters ","category":"page"},{"location":"tutorialsCGLShoot/","page":"2d Ginzburg-Landau equation (shooting)","title":"2d Ginzburg-Landau equation (shooting)","text":"Nx = 41\nNy = 21\nn = Nx*Ny\nlx = pi\nly = pi/2\n\nΔ = Laplacian2D(Nx, Ny, lx, ly)[1]\npar_cgl = (r = 0.5, μ = 0.1, ν = 1.0, c3 = -1.0, c5 = 1.0, Δ = blockdiag(Δ, Δ))\nsol0 = 0.1rand(2Nx, Ny)\nsol0_f = vec(sol0)","category":"page"},{"location":"tutorialsCGLShoot/","page":"2d Ginzburg-Landau equation (shooting)","title":"2d Ginzburg-Landau equation (shooting)","text":"and the ODE problem","category":"page"},{"location":"tutorialsCGLShoot/","page":"2d Ginzburg-Landau equation (shooting)","title":"2d Ginzburg-Landau equation (shooting)","text":"f1 = DiffEqArrayOperator(par_cgl.Δ)\nf2 = NL!\nprob_sp = SplitODEProblem(f1, f2, sol0_f, (0.0, 120.0), (@set par_cgl.r = 1.2), dt = 0.1)\n# we solve the PDE!!!\nsol = @time solve(prob_sp, ETDRK2(krylov=true); abstol=1e-14, reltol=1e-14)","category":"page"},{"location":"tutorialsCGLShoot/#Automatic-branch-switching-from-the-Hopf-points","page":"2d Ginzburg-Landau equation (shooting)","title":"Automatic branch switching from the Hopf points","text":"","category":"section"},{"location":"tutorialsCGLShoot/","page":"2d Ginzburg-Landau equation (shooting)","title":"2d Ginzburg-Landau equation (shooting)","text":"We show how to use automatic branch switching from the Hopf points computed in the previous section. To compute the periodic orbits, we use a Standard Shooting method. ","category":"page"},{"location":"tutorialsCGLShoot/","page":"2d Ginzburg-Landau equation (shooting)","title":"2d Ginzburg-Landau equation (shooting)","text":"We first recompute the Hopf points as in the previous tutorial:","category":"page"},{"location":"tutorialsCGLShoot/","page":"2d Ginzburg-Landau equation (shooting)","title":"2d Ginzburg-Landau equation (shooting)","text":"eigls = EigArpack(1.0, :LM)\nopt_newton = NewtonPar(tol = 1e-9, verbose = true, eigsolver = eigls, maxIter = 20)\nopts_br = ContinuationPar(dsmax = 0.02, ds = 0.01, pMax = 2., detectBifurcation = 3, nev = 15, newtonOptions = (@set opt_newton.verbose = false), nInversion = 4)\n\nbr, = @time continuation(Fcgl, Jcgl, vec(sol0), par_cgl, (@lens _.r), opts_br, verbosity = 0)","category":"page"},{"location":"tutorialsCGLShoot/","page":"2d Ginzburg-Landau equation (shooting)","title":"2d Ginzburg-Landau equation (shooting)","text":"We then compute the differentials of the vector field, this is needed by the branch switching method because it first computes the Hopf normal form. Thankfully, this is little work using Automatic Differentiation:","category":"page"},{"location":"tutorialsCGLShoot/","page":"2d Ginzburg-Landau equation (shooting)","title":"2d Ginzburg-Landau equation (shooting)","text":"using ForwardDiff\n\nD(f, x, p, dx) = ForwardDiff.derivative(t -> f(x .+ t .* dx, p), 0.)\nd1Fcgl(x,p,dx1) = D((z, p0) -> Fcgl(z, p0), x, p, dx1)\nd2Fcgl(x,p,dx1,dx2) = D((z, p0) -> d1Fcgl(z, p0, dx1), x, p, dx2)\nd3Fcgl(x,p,dx1,dx2,dx3) = D((z, p0) -> d2Fcgl(z, p0, dx1, dx2), x, p, dx3)\n\njet = (Fcgl, Jcgl, d2Fcgl, d3Fcgl)","category":"page"},{"location":"tutorialsCGLShoot/","page":"2d Ginzburg-Landau equation (shooting)","title":"2d Ginzburg-Landau equation (shooting)","text":"We define the linear solvers to be use by the (Matrix-Free) shooting method","category":"page"},{"location":"tutorialsCGLShoot/","page":"2d Ginzburg-Landau equation (shooting)","title":"2d Ginzburg-Landau equation (shooting)","text":"ls = GMRESIterativeSolvers(reltol = 1e-4, maxiter = 50, verbose = false)\neig = EigKrylovKit(tol = 1e-7, x₀ = rand(2Nx*Ny), verbose = 2, dim = 40)\noptn = NewtonPar(verbose = true, tol = 1e-9,  maxIter = 25, linsolver = ls, eigsolver = eig)\nopts_po_cont = ContinuationPar(dsmin = 0.001, dsmax = 0.02, ds= 0.01, pMax = 2.5, maxSteps = 32, newtonOptions = optn, nev = 7, precisionStability = 1e-3, detectBifurcation = 3, plotEveryStep = 1)","category":"page"},{"location":"tutorialsCGLShoot/","page":"2d Ginzburg-Landau equation (shooting)","title":"2d Ginzburg-Landau equation (shooting)","text":"as","category":"page"},{"location":"tutorialsCGLShoot/","page":"2d Ginzburg-Landau equation (shooting)","title":"2d Ginzburg-Landau equation (shooting)","text":"Mt = 1 # number of time sections\nbr_po, = continuation(\n\t# we want to compute the bifurcated branch from \n\t# the first Hopf point\n\tjet..., br, 1,\n\t# arguments for continuation\n\topts_po_cont,\n\t# this is how to pass the method to compute the periodic\n\t# orbits. We shall use 1 section and the ODE solver ETDRK2\n\tShootingProblem(Mt, par_cgl, prob_sp, ETDRK2(krylov = true); atol = 1e-10, rtol = 1e-8) ;\n\t# linear solver for bordered linear system\n\t# we combine the 2 solves. It is here faster than BorderingBLS()\n\tlinearAlgo = MatrixFreeBLS(@set ls.N = Mt*2n+2),\n\t# to help branching from the Hopf point\n\tampfactor = 1.5, δp = 0.01,\n\t# regular parameters for the continuation\n\tverbosity = 3, plot = true,\n\t# a few parameters saved during run\n\trecordFromSolution = (u, p) -> (amp = BK.getAmplitude(p.prob, u, (@set par_cgl.r = p.p)), period = u[end]),\n\t# plotting of a section\n\tplotSolution = (x, p; k...) -> heatmap!(reshape(x[1:Nx*Ny], Nx, Ny); color=:viridis, k...),\n\t# print the Floquet exponent\n\tfinaliseSolution = (z, tau, step, contResult; k...) ->\n\t\t(Base.display(contResult.eig[end].eigenvals) ;true),\n\tnormC = norminf)","category":"page"},{"location":"tutorialsCGLShoot/","page":"2d Ginzburg-Landau equation (shooting)","title":"2d Ginzburg-Landau equation (shooting)","text":"(Image: )","category":"page"},{"location":"tutorialsCGLShoot/#Manual-branch-switching-from-the-Hopf-points","page":"2d Ginzburg-Landau equation (shooting)","title":"Manual branch switching from the Hopf points","text":"","category":"section"},{"location":"tutorialsCGLShoot/","page":"2d Ginzburg-Landau equation (shooting)","title":"2d Ginzburg-Landau equation (shooting)","text":"The goal of this section is to show how to use the package in case automatic branch switching fails. This can happen for tedious PDEs and \"one has to get his hands dirty\".","category":"page"},{"location":"tutorialsCGLShoot/","page":"2d Ginzburg-Landau equation (shooting)","title":"2d Ginzburg-Landau equation (shooting)","text":"We decide to use Standard Shooting and thus define a Shooting functional","category":"page"},{"location":"tutorialsCGLShoot/","page":"2d Ginzburg-Landau equation (shooting)","title":"2d Ginzburg-Landau equation (shooting)","text":"probSh = ShootingProblem(\n\t# pass the vector field and parameter (to be passed to the vector field)\n\tFcgl, par_cgl,\n\n\t# we pass the ODEProblem encoding the flow and the time stepper\n\tprob_sp, ETDRK2(krylov = true),\n\n\t# this is the phase condition\n\t[sol[:, end]];\n\n\t# these are options passed to the ODE time stepper\n\tatol = 1e-14, rtol = 1e-14)","category":"page"},{"location":"tutorialsCGLShoot/","page":"2d Ginzburg-Landau equation (shooting)","title":"2d Ginzburg-Landau equation (shooting)","text":"We use the solution from the ODE solver as a starting guess for the shooting method.","category":"page"},{"location":"tutorialsCGLShoot/","page":"2d Ginzburg-Landau equation (shooting)","title":"2d Ginzburg-Landau equation (shooting)","text":"# initial guess with period 6.9 using solution at time t = 116\ninitpo = vcat(sol(116.), 6.9) |> vec\n\n# linear solver for shooting functional\nls = GMRESIterativeSolvers(reltol = 1e-4, N = 2Nx * Ny + 1, maxiter = 50, verbose = true)\n\n# newton parameters\noptn = NewtonPar(verbose = true, tol = 1e-9,  maxIter = 20, linsolver = ls)\n\n# continuation parameters\neig = EigKrylovKit(tol=1e-7, x₀ = rand(2Nx*Ny), verbose = 2, dim = 40)\nopts_po_cont = ContinuationPar(dsmin = 0.001, dsmax = 0.01, ds= -0.01, pMax = 1.5, maxSteps = 60, newtonOptions = (@set optn.eigsolver = eig), nev = 5, precisionStability = 1e-3, detectBifurcation = 3)\n\nbr_po, = @time continuation(probSh,\n\tinitpo, (@set par_cgl.r = 1.2), (@lens _.r), opts_po_cont;\n\tverbosity = 3, plot = true,\n\tplotSolution = (x, p; kwargs...) -> heatmap!(reshape(x[1:Nx*Ny], Nx, Ny); color=:viridis, kwargs...),\n\trecordFromSolution = (u, p) -> BK.getAmplitude(probSh, u, (@set par_cgl.r = p); ratio = 2), normC = norminf)","category":"page"},{"location":"simplebp/#Simple-bifurcation-branch-point","page":"Simple branch point","title":"Simple bifurcation branch point","text":"","category":"section"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"unknown: References\nThe general method is exposed in Golubitsky, Martin, David G Schaeffer, and Ian Stewart. Singularities and Groups in Bifurcation Theory. New York: Springer-Verlag, 1985, VI.1.d page 295","category":"page"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"A simple branch point (x_0p_0) for the problem F(xp)=0 satisfies dim ker dF(x_0p_0) = 1. At such point, we can apply Lyapunov-Schmidt reduction to transform the initial problem in large dimensions to a scalar polynomial (delta p equiv p-p_0): ","category":"page"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"adelta p + zleft(b_1delta p + fracb_22z + fracb_36z^2right) = 0 tagE","category":"page"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"whose solutions give access to all solutions in a neighborhood of (xp).","category":"page"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"More precisely, if ker dF(x_0p_0) = mathbb Rzeta, one can show that x_0+zzeta is close to a solution on a new branch, thus satisfying F(x_0+zzetap_0+delta p)approx 0.","category":"page"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"In the above scalar equation,","category":"page"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"if aneq 0, this is a Saddle-Node bifurcation\nif a=0b_2neq 0, the bifurcation point is a Transcritical one where the bifurcated branch exists on each side of p.\nif a=0b_2=0 b_3neq 0, the bifurcation point is a Pitchfork one where the bifurcated branch only exists on one side of p. If it exists at smaller values then p, this is a subcritical Pitchfork bifurcation. In the other case, this is a supercritical Pitchfork bifurcation.","category":"page"},{"location":"simplebp/#Normal-form-computation","page":"Simple branch point","title":"Normal form computation","text":"","category":"section"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"The reduced equation (E) can be automatically computed as follows","category":"page"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"computeNormalForm(F, dF, d2F, d3F, br::ContResult, ind_bif::Int ; δ = 1e-8,\n\tnev = 5, Jᵗ = nothing, verbose = false, ζs = nothing, lens = br.param_lens)","category":"page"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"where dF, d2F,d3F are the differentials of F. br is a branch computed after a call to continuation with detection of bifurcation points enabled and ind_bif is the index of the bifurcation point on the branch br. The above call returns a point with information needed to compute the bifurcated branch. For more information about the optional parameters, we refer to computeNormalForm. The result returns the following:","category":"page"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"mutable struct SimpleBranchPoint{Tv, T, Tevl, Tevr, Tnf} <: BranchPoint\n\t\"bifurcation point\"\n\tx0::Tv\n\n\t\"Parameter value at the bifurcation point\"\n\tp::T\n\n\t\"Right eigenvector(s)\"\n\tζ::Tevr\n\n\t\"Left eigenvector(s)\"\n\tζstar::Tevl\n\n\t\"Normal form coefficients\"\n\tnf::Tnf\n\n\t\"Type of bifurcation point\"\n\ttype::Symbol\nend","category":"page"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"info: Note\nYou should not need to call computeNormalForm except if you need the full information about the branch point.","category":"page"},{"location":"BifurcationDiagram/#Automatic-Bifurcation-diagram-computation","page":"Bifurcation diagram","title":"Automatic Bifurcation diagram computation","text":"","category":"section"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"info: Experimental\nThis feature is still experimental. It has not been tested thoroughly.","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"Thanks to the functionality presented in this part, we can compute the bifurcation diagram of a system recursively and fully automatically. More precisely, the function bifurcationdiagram allows to:","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"compute a branch gamma of equilibria\ndetect all bifurcations on the branch\nrecursively compute the branches emanating from branch points on gamma.","category":"page"},{"location":"BifurcationDiagram/#Pitfalls","page":"Bifurcation diagram","title":"Pitfalls","text":"","category":"section"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"For now, there is no way to decide if two branches gamma_1gamma_2 are the same. As a consequence:","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"there is no loop detection. Hence, if the branch gamma has a component akin to a circle, you may experience a large number of branches\nif the bifurcation diagram itself has loops (see example below), you may experience a large number of branches","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"warning: Memory\nThe whole diagram is stored in RAM and you might be careful computing it on GPU. We'll add a file system for this in the future. ","category":"page"},{"location":"BifurcationDiagram/#Basic-example-with-simple-branch-points","page":"Bifurcation diagram","title":"Basic example with simple branch points","text":"","category":"section"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"using Revise, Plots\nusing BifurcationKit, Setfield, ForwardDiff\nconst BK = BifurcationKit\n\nFbpSecBif(u, p) = @. -u * (p + u * (2-5u)) * (p -.15 - u * (2+20u))\ndFbpSecBif(x,p) =  ForwardDiff.jacobian( z-> FbpSecBif(z,p), x)\n# we group the differential together\njet = BK.getJet(FbpSecBif, dFbpSecBif)\n\n# options for Krylov-Newton\nopt_newton = NewtonPar(tol = 1e-9, maxIter = 20)\n\n# options for continuation\nopts_br = ContinuationPar(dsmin = 0.001, dsmax = 0.05, ds = 0.01,\n\tmaxSteps = 100, nev = 2, newtonOptions = opt_newton,\n\t# parameter interval\n\tpMax = 0.4, pMin = -0.5,\n\t# detect bifurcations with bisection method\n\tdetectBifurcation = 3, nInversion = 4, tolBisectionEigenvalue = 1e-8, dsminBisection = 1e-9)\n\ndiagram = bifurcationdiagram(jet..., \n\t# initial point and parameter\n\t[0.0], -0.2, \n\t# specify the continuation parameter\n\t(@lens _), \n\t# very important parameter. This specifies the maximum amount of recursion\n\t# when computing the bifurcation diagram. It means we allow computing branches of branches \n\t# at most in the present case.\n\t2,\n\t(args...) -> setproperties(opts_br; pMin = -1.0, pMax = .3, ds = 0.001, dsmax = 0.005, nInversion = 8, detectBifurcation = 3, dsminBisection =1e-18, maxBisectionSteps=20);\n\trecordFromSolution = (x, p) -> x[1])\n\t\n# You can plot the diagram like \nplot(diagram; putspecialptlegend=false, markersize=2, plotfold=false, title = \"#branches = $(size(diagram))\")","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"This gives","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"julia> diagram\nBifurcation diagram. Root branch (level 1) has 4 children and is such that:\nBranch number of points: 76\nBranch of Equilibrium\nBifurcation points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1,      bp point around p ≈ 0.00000281, step =  31, eigenelements in eig[ 32], ind_ev =   1 [converged], δ = ( 1,  0)\n- #  2,      bp point around p ≈ 0.15000005, step =  53, eigenelements in eig[ 54], ind_ev =   1 [converged], δ = (-1,  0)","category":"page"},{"location":"BifurcationDiagram/#Example-with-nonsimple-branch-points","page":"Bifurcation diagram","title":"Example with nonsimple branch points","text":"","category":"section"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"To show the ability of the branch switching method to cope with non simple branch points, we look at the normal form of the Pitchfork with D6 symmetry which occurs frequently in problems with hexagonal symmetry. You may want to look at Automatic diagram of 2d Bratu–Gelfand problem (Intermediate) for a non trivial example of use.","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"using Revise, Plots\nusing BifurcationKit, Setfield, ForwardDiff, LinearAlgebra\nconst BK = BifurcationKit\nnorminf = x -> norm(x, Inf)\n\nfunction FbpD6(x, p)\n\treturn [ p.μ * x[1] + (p.a * x[2] * x[3] - p.b * x[1]^3 - p.c*(x[2]^2 + x[3]^2) * x[1]),\n\t\tp.μ * x[2] + (p.a * x[1] * x[3] - p.b * x[2]^3 - p.c*(x[3]^2 + x[1]^2) * x[2]),\n\t\tp.μ * x[3] + (p.a * x[1] * x[2] - p.b * x[3]^3 - p.c*(x[2]^2 + x[1]^2) * x[3])]\nend\n\n# we group the differential together\njet = BK.getJet(FbpD6, (x, p) -> ForwardDiff.jacobian(z -> FbpD6(z, p), x))\n\n# model parameters\npard6 = (μ = -0.2, a = 0.3, b = 1.5, c = 2.9)\n\n# newton options\nopt_newton = NewtonPar(tol = 1e-9, maxIter = 20)\n\n# continuation options\nopts_br = ContinuationPar(dsmin = 0.001, dsmax = 0.05, ds = 0.01, pMax = 0.4, pMin = -0.5, detectBifurcation = 2, nev = 2, newtonOptions = opt_newton, maxSteps = 100, nInversion = 4, tolBisectionEigenvalue = 1e-8, dsminBisection = 1e-9)\n\nbdiag = bifurcationdiagram(jet..., zeros(3), pard6, (@lens _.μ), 3,\n\t(args...) -> setproperties(opts_br; pMin = -0.250, pMax = .4, ds = 0.001, dsmax = 0.005, nInversion = 4, detectBifurcation = 3, maxBisectionSteps=20, newtonOptions = opt_newton);\n\trecordFromSolution = (x, p) -> norminf(x),\n\txwnormC = norminf)","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"We can now plot the result:","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"plot(bdiag; putspecialptlegend =false, markersize=2, plotfold=false, title=\"#branch = $(size(bdiag))\")","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"(Image: )","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"We can access the different branches with BK.getBranch(bdiag, (1,)). Alternatively, you can plot a specific branch:","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"(Image: )","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"Finally, you can resume the computation of the bifurcation diagram if not complete by using the syntax","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":" bifurcationdiagram!(jet...,\n\t# this resume the computation of the diagram from the 2nd node\n\t# bdiag is written inplace\n\tgetBranch(bdiag, (2,)), (current = 3, maxlevel = 6), \n\t(args...) -> setproperties(opts_br; pMin = -0.250, pMax = .4, ds = 0.001, dsmax = 0.005, nInversion = 4, detectBifurcation = 3, dsminBisection =1e-18, tolBisectionEigenvalue=1e-11, maxBisectionSteps=20, newtonOptions = (@set opt_newton.verbose=false)))","category":"page"},{"location":"BifurcationDiagram/#Printing-the-structure-of-the-diagram","page":"Bifurcation diagram","title":"Printing the structure of the diagram","text":"","category":"section"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"It is sometimes useful to have a global representation of the bifurcation diagram. Here, we provide a text representation","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"using AbstractTrees\n\nAbstractTrees.children(node::BK.BifDiagNode) = node.child\n\n## Things that make printing prettier\nAbstractTrees.printnode(io::IO, node::BifDiagNode) = print(io, \"$(node.code) [ $(node.level)]\")\n\nprint_tree(bdiag)","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"which should return","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"\njulia> print_tree(bdiag)\n0 [ 1]\n├─ 1 [ 2]\n│  ├─ 2 [ 3]\n│  ├─ 2 [ 3]\n│  ├─ 4 [ 3]\n│  ├─ 4 [ 3]\n│  ├─ 4 [ 3]\n│  ├─ 4 [ 3]\n│  ├─ 4 [ 3]\n│  └─ 4 [ 3]\n└─ 1 [ 2]\n   ├─ 2 [ 3]\n   └─ 2 [ 3]","category":"page"},{"location":"BifurcationDiagram/#Plotting-the-structure-of-the-diagram","page":"Bifurcation diagram","title":"Plotting the structure of the diagram","text":"","category":"section"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"We can also use GraphPlot to plot the tree underlying the bifurcation diagram:","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"using LightGraphs, MetaGraphs, GraphPlot\n\nfunction graphFromDiagram!(_graph, diagram, indp)\n\t# ind is the index of the parent node\n\t# add vertex and associated information\n\tadd_vertex!(_graph)\n\tset_props!(_graph, nv(_graph), Dict(:code => diagram.code, :level => diagram.level))\n\tif nv(_graph) > 1\n\t\tadd_edge!(_graph, indp, nv(_graph))\n\tend\n\tif length(diagram.child) > 0\n\t\t# we now run through the children\n\t\tnew_indp = nv(_graph)\n\t\tfor diag in diagram.child\n\t\t\tgraphFromDiagram!(_graph, diag, new_indp)\n\t\tend\n\tend\nend\n\nfunction graphFromDiagram(diagram) \n\t_g = MetaGraph()\n\tgraphFromDiagram!(_g, diagram, 1)\n\treturn _g\nend\n\n_g = graphFromDiagram(bdiag)\n\ngplot(_g, nodelabel = [props(_g, ve)[:code] for ve in vertices(_g)])","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"which gives the following picture. The node label represent the index of the bifurcation point from which the branch branches.","category":"page"},{"location":"BifurcationDiagram/#Using-GraphRecipes","page":"Bifurcation diagram","title":"Using GraphRecipes","text":"","category":"section"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"Another solution is to use GraphRecipes and ","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"using GraphRecipes\n\ngraphplot(_g, \n\tnode_weights = ones(nv(_g)).*10, \n\tnames=[props(_g, ve)[:code] for ve in vertices(_g)], \n\tcurvature_scalar=0.)","category":"page"},{"location":"periodicOrbitTrapeze/#Periodic-orbits-based-on-trapezoidal-rule","page":"Finite Differences","title":"Periodic orbits based on trapezoidal rule","text":"","category":"section"},{"location":"periodicOrbitTrapeze/","page":"Finite Differences","title":"Finite Differences","text":"We have implemented a method where we compute M slices of a periodic orbit. This is done by the structure PeriodicOrbitTrapProblem for which the problem of finding periodic orbits is discretized using Finite Differences based on a trapezoidal rule. ","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Finite Differences","title":"Finite Differences","text":"unknown: References\nThe general method is very well exposed in Hopf Bifurcation and Time Periodic Orbits with Pde2path – Algorithms and Applications., Uecker, Hannes, Communications in Computational Physics 25, no. 3 (2019) and in the PhD thesis Numerical Bifurcation Analysis of Periodic Solutions of Partial Differential Equations, Lust, Kurt, 1997. We adopt the notations of the first reference.","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Finite Differences","title":"Finite Differences","text":"We look for periodic orbits as solutions (x(0)T) of","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Finite Differences","title":"Finite Differences","text":"dot x = Tcdot F(x) x(0)=x(1)","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Finite Differences","title":"Finite Differences","text":"In order to have a unique solution, we need to remove the phase freedom. This is done by imposing a phase condition sum_ilangle x_i - x_pii phi_irangle = 0 for some x_piphi which are chosen (wisely).","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Finite Differences","title":"Finite Differences","text":"By discretizing the above problem, we obtain","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Finite Differences","title":"Finite Differences","text":"beginarrayl\n\t\t0= left(x_j-x_j-1right)-frach2 left(Fleft(x_jright)+Fleft(x_j-1right)right)equiv G_j(x)quad j=1cdotsm-1  \n0= x_m-x_1 equiv G_m(x) \n0= sum_ilangle x_i - x_pii phi_irangle=0\nendarray","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Finite Differences","title":"Finite Differences","text":"where x_0=x_m and h=Tm. The Jacobian of the system of equations w.r.t. (x_0T) is given by ","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Finite Differences","title":"Finite Differences","text":"mathcalJ=left(beginarrayccA_1  partial_TG  star  dendarrayright)","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Finite Differences","title":"Finite Differences","text":"where ","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Finite Differences","title":"Finite Differences","text":"A_gamma=left(beginarrayccccccc\nM_1  0  0  0  cdots  -H_1  0  \n-H_2  M_2  0  0  cdots  0  0  \n0  -H_3  M_3  0  cdots  0  0  \nvdots  cdots  ddots  ddots  ddots  vdots  vdots  \n0  cdots  cdots  ddots  ddots  0  0  \n0  cdots  cdots  0  -H_m-1  M_m-1  0  \n-gamma I  0  cdots  cdots  cdots  0  I\nendarrayright)","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Finite Differences","title":"Finite Differences","text":"with M_i = I-\tfrac h2dF(x_i) and H_i = I+frac h2dF(x_i-1).","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Finite Differences","title":"Finite Differences","text":"We solve the linear equation mathcal Jcdot sol = rhs with a bordering strategy (i.e. the linear solver is a subtype of <: AbstractBorderedLinearSolver) which in turn requires to solve A_gamma z=b where z=(xx_m). We also solve this equation with a bordering strategy but this time, it can be simplified as follows. If we write b=(fg), one gets J_c x=f and x_m=g+gamma x_1 where x_1 is the first time slice of x and J_c is the following cyclic matrix:","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Finite Differences","title":"Finite Differences","text":"J_c=left(beginarrayccccccc\nM_1  0  0  0  cdots  -H_1  \n-H_2  M_2  0  0  cdots  0  \n0  -H_3  M_3  0  cdots  0  \nvdots  cdots  ddots  ddots  ddots  vdots  \n0  cdots  cdots  ddots  ddots  0  \n0  cdots  cdots  0  -H_m-1  M_m-1  \nendarrayright)","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Finite Differences","title":"Finite Differences","text":"Our code thus provides methods to invert J_c and A_gamma using a sparse solver or a Matrix-Free solver. A preconditioner can be used. ","category":"page"},{"location":"periodicOrbitTrapeze/#Encoding-of-the-functional","page":"Finite Differences","title":"Encoding of the functional","text":"","category":"section"},{"location":"periodicOrbitTrapeze/","page":"Finite Differences","title":"Finite Differences","text":"The functional is encoded in the composite type PeriodicOrbitTrapProblem. See the link for more information, in particular on how to access the underlying functional, its jacobian and other matrices related to it like A_gamma J_c...","category":"page"},{"location":"periodicOrbitTrapeze/#Preconditioning","page":"Finite Differences","title":"Preconditioning","text":"","category":"section"},{"location":"periodicOrbitTrapeze/","page":"Finite Differences","title":"Finite Differences","text":"We strongly advise you to use a preconditioner to deal with the above linear problem. See 2d Ginzburg-Landau equation (finite differences) for an example.","category":"page"},{"location":"periodicOrbitTrapeze/#Floquet-multipliers-computation","page":"Finite Differences","title":"Floquet multipliers computation","text":"","category":"section"},{"location":"periodicOrbitTrapeze/","page":"Finite Differences","title":"Finite Differences","text":"A not very precise algorithm for computing the Floquet multipliers is provided. The method, dubbed Quick and Dirty (QaD), is not numerically very precise for large / small Floquet exponents. It allows, nevertheless, to detect bifurcations of periodic orbits. It seems to work reasonably well for the tutorials considered here. For more information, have a look at FloquetQaD.","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Finite Differences","title":"Finite Differences","text":"note: Algorithm\nA more precise algorithm, based on the periodic Schur decomposition will be implemented in the future.","category":"page"},{"location":"periodicOrbitTrapeze/#Computation-with-newton","page":"Finite Differences","title":"Computation with newton","text":"","category":"section"},{"location":"periodicOrbitTrapeze/","page":"Finite Differences","title":"Finite Differences","text":"We provide a simplified call to newton to locate the periodic orbits. Compared to the regular newton function, there is an additional option linearalgo to select one of the many ways to deal with the above linear problem. The default solver linearalgo is :BorderedLU.","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Finite Differences","title":"Finite Differences","text":"Have a look at the Continuation of periodic orbits (Finite differences) example for the Brusselator for a basic example and at 2d Ginzburg-Landau equation (finite differences) for a more advanced one. ","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Finite Differences","title":"Finite Differences","text":"The docs for this specific newton are located at newton.","category":"page"},{"location":"periodicOrbitTrapeze/#Computation-with-newton-and-deflation","page":"Finite Differences","title":"Computation with newton and deflation","text":"","category":"section"},{"location":"periodicOrbitTrapeze/","page":"Finite Differences","title":"Finite Differences","text":"We also provide a simplified call to newton to locate the periodic orbit with a deflation operator. ","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Finite Differences","title":"Finite Differences","text":"newton(probPO::PeriodicOrbitTrapProblem, orbitguess, options::NewtonPar, defOp::DeflationOperator, linearPO = :BorderedLU; kwargs...)","category":"page"},{"location":"periodicOrbitTrapeze/#Continuation","page":"Finite Differences","title":"Continuation","text":"","category":"section"},{"location":"periodicOrbitTrapeze/","page":"Finite Differences","title":"Finite Differences","text":"Have a look at the Continuation of periodic orbits (Finite differences) example for the Brusselator. We refer to continuation for more information regarding the arguments.","category":"page"},{"location":"Langmuir/#d-Langmuir–Blodgett-transfer-model-(advanced)","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"1d Langmuir–Blodgett transfer model (advanced)","text":"","category":"section"},{"location":"Langmuir/","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"1d Langmuir–Blodgett transfer model (advanced)","text":"In this tutorial, we try to replicate some of the results of the amazing paper [Köpf]. This example is quite a marvel in the realm of bifurcation analysis, featuring a harp-like bifurcation diagram. The equations of the thin film are as follows:","category":"page"},{"location":"Langmuir/","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"1d Langmuir–Blodgett transfer model (advanced)","text":"partial_t c=-partial_x^2leftpartial_x^2 c-c^3+c-mu zeta(x)right-V partial_x c","category":"page"},{"location":"Langmuir/","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"1d Langmuir–Blodgett transfer model (advanced)","text":"with boundary conditions","category":"page"},{"location":"Langmuir/","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"1d Langmuir–Blodgett transfer model (advanced)","text":"c(0)=c_0 quad partial_x x c(0)=partial_x c(L)=partial_x x c(L)=0","category":"page"},{"location":"Langmuir/","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"1d Langmuir–Blodgett transfer model (advanced)","text":"and where","category":"page"},{"location":"Langmuir/","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"1d Langmuir–Blodgett transfer model (advanced)","text":"zeta(x)=-frac12left1+tanh left(fracx-x_sl_sright)right","category":"page"},{"location":"Langmuir/","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"1d Langmuir–Blodgett transfer model (advanced)","text":"As can be seen in the reference above, the bifurcation diagram is significantly more involved as L increases. So we set up for the \"simple\" case L=50.","category":"page"},{"location":"Langmuir/","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"1d Langmuir–Blodgett transfer model (advanced)","text":"using Revise\nusing Parameters, Setfield, SparseArrays\nusing BifurcationKit, LinearAlgebra, Plots, ForwardDiff, BandedMatrices\nconst BK = BifurcationKit\n\t\n# norms\nnorminf(x) = norm(x, Inf)\nnormL2(x; r = sqrt(par.Δx / L)) = norm(x, 2) * r","category":"page"},{"location":"Langmuir/","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"1d Langmuir–Blodgett transfer model (advanced)","text":"Let us define the parameters of the model","category":"page"},{"location":"Langmuir/","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"1d Langmuir–Blodgett transfer model (advanced)","text":"# domain size\nL = 50.0\n\n# number of unknowns\nN = 390*3/2 |> Int\nΔx = L/(N+1)\nX = ((1:N) |> collect) .* Δx\n\n# define the (laplacian of) g function\nxs = 10.0; ls = 2.0\nΔg = @. tanh((X - xs)/ls) * (1 - tanh((X - xs)/ls)^2)/ls^2\n\n# define the parameters of the model\npar = (N = N, Δx = Δx, c0 = -0.9, σ = 1.0, μ = 0.5, ν = 0.08, Δg = Δg)","category":"page"},{"location":"Langmuir/#Encoding-the-PDE","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"Encoding the PDE","text":"","category":"section"},{"location":"Langmuir/","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"1d Langmuir–Blodgett transfer model (advanced)","text":"# function to enforce the boundary condition\nfunction putBC!(c, c0, N)\n\t# we put boundary conditions using ghost points\n\t# this boundary condition u''(0) = 0 = c1 -2c0 + c-1 gives c-1:\n\tc[1] = 2c0-c[3]\n\t# c(0) = c0, we would like to write x[0]\n\tc[2] = c0\n\t# the boundary conditions u'(L) = u''(L) = 0 imply the ghost points values.\n\t# c'(L) = 0 = cN+2 - cN  and c''(L) = 0 = cN+2 -2cN+1 + cN\n\tc[N+3] = c[N+2]\n\tc[N+4] = c[N+2]\n\treturn c\nend\n\n# implementation of the right hand side of the PDE\nfunction Flgvf!(out, x, p, t = 0.)\n\t@unpack c0, N, Δx, σ, μ, Δg, ν = p\n\tdx4 = Δx^4\n\tdx2 = Δx^2\n\t# we declare the residual\n\t# we enforce the BC\n\tc = similar(x, length(x) + 4)\n\tc[3:N+2] .= x\n\tputBC!(c, c0, N)\n\n\tfor i=3:N+2\n\t\tout[i-2] = -(σ * (c[i-2] - 4c[i-1] + 6c[i] - 4c[i+1] + c[i+2]) / dx4 +\n\t\t\t\t\t(c[i-1]   - 2c[i]   + c[i+1])   / (dx2) -\n\t\t\t\t\t(c[i-1]^3 - 2c[i]^3 + c[i+1]^3) / (dx2) -\n\t\t\t\t\tΔg[i-2] * μ +\n\t\t\t\t\tν * (c[i+1] - c[i-1]) / (2Δx)\n\t\t\t\t\t)\n\tend\n\treturn out\nend\nFlgvf(x, p, t = 0) = Flgvf!(similar(x), x, p, t)\n\n# compute the jacobian of the PDE at position x\n@views function JanaSP(x, p)\n\t# 63.446 μs (61 allocations: 137.97 KiB) pour N = 400\n\t# 62.807 μs (44 allocations: 168.58 KiB) pour sparse(Jana(x, p))\n\t@unpack N, Δx, σ, ν = p\n\td0  = @. (-6σ/ Δx^4 + 2/ Δx^2*(1-3x^2))\n\td0[1] += σ/ Δx^4\n\td0[end] = -(3σ/ Δx^4 - 1/ Δx^2*(1-3x[N]^2)     + ν/ (2Δx))\n\td1   = @.  (4σ/ Δx^4 - 1/ Δx^2*(1-3x[2:N]^2)   - ν/ (2Δx))\n\tdm1  = @.  (4σ/ Δx^4 - 1/ Δx^2*(1-3x[1:N-1]^2) + ν/ (2Δx))\n\td1[end] -= σ/ Δx^4\n\td2  = @.  (-σ/ Δx^4) * ones(N-2)\n\tJ = spdiagm(  0 => d0,\n\t\t\t\t  1 => d1,\n\t\t\t\t -1 => dm1,\n\t\t\t\t  2 => d2,\n\t\t\t\t -2 => d2)\n\treturn J\nend","category":"page"},{"location":"Langmuir/","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"1d Langmuir–Blodgett transfer model (advanced)","text":"It will prove useful to have access to higher derivatives as well","category":"page"},{"location":"Langmuir/","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"1d Langmuir–Blodgett transfer model (advanced)","text":"# jet to compute the normal form\njet  = BK.getJet(Flgvf, JanaSP)","category":"page"},{"location":"Langmuir/#Continuation-of-stationary-states","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"Continuation of stationary states","text":"","category":"section"},{"location":"Langmuir/","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"1d Langmuir–Blodgett transfer model (advanced)","text":"We call the Krylov-Newton method to find a stationary solution. Note that for this to work, the guess has to satisfy the boundary conditions approximately.","category":"page"},{"location":"Langmuir/","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"1d Langmuir–Blodgett transfer model (advanced)","text":"# newton iterations to refine the guess\nopt_new = NewtonPar(tol = 1e-9, verbose = true, maxIter = 50)\n\tout, = @time newton(Flgvf, JanaSP, 0X .-0.9, par, opt_new)\nplot(X, out)","category":"page"},{"location":"Langmuir/","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"1d Langmuir–Blodgett transfer model (advanced)","text":"(Image: )","category":"page"},{"location":"Langmuir/","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"1d Langmuir–Blodgett transfer model (advanced)","text":"We then continue the previous guess and find this very nice folded structure with many Hopf bifurcation points.","category":"page"},{"location":"Langmuir/","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"1d Langmuir–Blodgett transfer model (advanced)","text":"# careful here, in order to use Arpack.eig, you need rather big space \n# or compute ~100 eigenvalues\nopts_cont = ContinuationPar(\n\tdsmin = 1e-5, dsmax = 0.04, ds= -0.001, pMin = -0.01, pMax = 10.1,\n\t# we adjust theta so that the continuation steps are larger\n\ttheta = 0.4, a = 0.75, plotEveryStep = 30, maxSteps = 600,\n\tnewtonOptions = setproperties(opt_new; tol = 1e-9, maxIter = 10, verbose = false),\n\tnev = 10, saveEigenvectors = true, precisionStability = 1e-5, detectBifurcation = 3, \n\tdsminBisection = 1e-8, maxBisectionSteps = 15, nInversion = 6, tolBisectionEigenvalue = 1e-9, saveSolEveryStep = 50)\n\n\teig = EigKrylovKit(tol=1e-9, x₀ = rand(N), dim = 150)\n\n\t@time br, u1 = @time continuation(\n\t\tFlgvf, JanaSP,\n\t\tout, (@set par.ν = 0.06), (@lens _.ν ), opts_cont,\n\t\t# we form a sparse matrix for the bordered linear problem\n\t\tlinearAlgo = MatrixBLS(),\n\t\tplot = true, verbosity = 2,\n\t\trecordFromSolution = (x, p) -> normL2(x),\n\t\tplotSolution = (x, p; kwargs...) -> plot!(X, x, subplot = 3, xlabel = \"Nx = $(length(x))\", label = \"\"),\n\t\tnormC = normL2)","category":"page"},{"location":"Langmuir/","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"1d Langmuir–Blodgett transfer model (advanced)","text":"(Image: )","category":"page"},{"location":"Langmuir/","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"1d Langmuir–Blodgett transfer model (advanced)","text":"(Image: )","category":"page"},{"location":"Langmuir/#Continuation-of-Hopf-and-Fold-points","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"Continuation of Hopf and Fold points","text":"","category":"section"},{"location":"Langmuir/","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"1d Langmuir–Blodgett transfer model (advanced)","text":"Let us study the continuation of Hopf and Fold points and show that they merge at a Bogdanov-Takens bifurcation point:","category":"page"},{"location":"Langmuir/","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"1d Langmuir–Blodgett transfer model (advanced)","text":"# compute branch of Fold points from 7th bifurcation point on br\nsn_codim2, = continuation(jet[1:2]..., br, 7, (@lens _.Δx), \n\tContinuationPar(opts_cont, pMin = -2, pMax = 0.12, ds = -0.01, dsmax = 0.01, precisionStability = 1e-8, maxSteps = 325, nev=23) ; \n\tplot = true, verbosity = 3,\n\t# start the problem with information from eigen elements\n\tstartWithEigen = true,\n\t# this improves tracking the Fold points\n\td2F = jet[3],\n\t# detection of codim 2 bifurcations with bisection\n\tdetectCodim2Bifurcation = 2,\n\t# we update the Fold problem at every continuation step\n\tupdateMinAugEveryStep = 1,\n\t# compute both sides of the initial condition\n\tbothside = true\n\t)\n\t\n# compute branch of Hopf points from 5th bifurcation point on br\nhp_codim2, = continuation(jet[1:2]..., br, 5, (@lens _.Δx), ContinuationPar(opts_cont, pMax = 0.1, ds = -0.01, dsmax = 0.01, maxSteps = 230, precisionStability = 1e-8) ; \n\tplot = true, verbosity = 3,\n\t# start the problem with information from eigen elements\n\tstartWithEigen = true,\n\t# we update the Hopf problem at every continuation step\n\tupdateMinAugEveryStep = 1,\n\t# detection of codim 2 bifurcations with bisection\n\tdetectCodim2Bifurcation = 2,\n\t# this is required to detect the bifurcations\n\td2F = jet[3], d3F = jet[4],\n\t)\n\n# plot the branches\nplot(sn_codim2, branchlabel = \"Fold\")\nplot!(hp_codim2, branchlabel = \"Hopf\", plotcirclesbif=true)","category":"page"},{"location":"Langmuir/","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"1d Langmuir–Blodgett transfer model (advanced)","text":"(Image: )","category":"page"},{"location":"Langmuir/#Continuation-of-periodic-orbits-(FD)","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"Continuation of periodic orbits (FD)","text":"","category":"section"},{"location":"Langmuir/","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"1d Langmuir–Blodgett transfer model (advanced)","text":"We would like to compute the branches of periodic solutions from the Hopf points. We do this automatic branch switching as follows","category":"page"},{"location":"Langmuir/","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"1d Langmuir–Blodgett transfer model (advanced)","text":"# parameters for newton\nopt_po = NewtonPar(tol =  1e-10, verbose = true, maxIter = 50)\n\n# parameters for continuation\nopts_po_cont = ContinuationPar(dsmin = 1e-5, dsmax = 0.35, ds= 0.001,\n\tpMax = 1.0, maxSteps = 100, theta = 0.75,\n\tnewtonOptions = setproperties(opt_po; maxIter = 15, tol = 1e-6), plotEveryStep = 1)\n\nM = 100 # numbr of time sections\nbr_potrap, utrap = continuation(\n\t# arguments for branch switching\n\tjet..., br, 5,\n\t# arguments for continuation\n\topts_po_cont, PeriodicOrbitTrapProblem(M = M);\n\t# parameter value used for branching\n\tδp = 1e-5, \n\t# use deflated Newton to find non-trivial solutions\n\tusedeflation = true,\n\t# algorithm to solve linear associated with periodic orbit problem\n\tlinearPO = :FullSparseInplace,\n\t# tangent algorithm along the branch\n\ttangentAlgo = BorderedPred(),\n\tverbosity = 3, plot = true,\n\tupdateSectionEveryStep = 1,\n\trecordFromSolution = (x, p) -> normL2T(x[1:end-1], M = M),\n\tplotSolution  = (x, p; kwargs...) -> begin\n\t\t\theatmap!(reshape(x[1:end-1], N, M)'; ylabel=\"T=$(round(x[end]))\", color=:viridis, kwargs...)\n\t\t\tplot!(br, subplot=1, label=\"\")\n\t\tend,\n\tnormC = norminf)","category":"page"},{"location":"Langmuir/","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"1d Langmuir–Blodgett transfer model (advanced)","text":"and we obtain the following graph. It is interesting to note that the periodic solutions converge to an homoclinic orbit here with a very large period. (Image: )","category":"page"},{"location":"Langmuir/","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"1d Langmuir–Blodgett transfer model (advanced)","text":"We can do this for the other Hopf points as well. Note that, we have to increase the number of time sections M to improve the convergence to the homoclinic orbits.","category":"page"},{"location":"Langmuir/","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"1d Langmuir–Blodgett transfer model (advanced)","text":"(Image: )","category":"page"},{"location":"Langmuir/","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"1d Langmuir–Blodgett transfer model (advanced)","text":"Here are some examples of periodic solutions.","category":"page"},{"location":"Langmuir/","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"1d Langmuir–Blodgett transfer model (advanced)","text":"(Image: )","category":"page"},{"location":"Langmuir/","page":"1d Langmuir–Blodgett transfer model (advanced)","title":"1d Langmuir–Blodgett transfer model (advanced)","text":"[Köpf]: Köpf and Thiele, Emergence of the Bifurcation Structure of a Langmuir–Blodgett Transfer Model., 2014","category":"page"},{"location":"tutorialsODE/#Neural-mass-equation-(Hopf-aBS)","page":"Neural mass equation (Hopf aBS)","title":"Neural mass equation (Hopf aBS)","text":"","category":"section"},{"location":"tutorialsODE/","page":"Neural mass equation (Hopf aBS)","title":"Neural mass equation (Hopf aBS)","text":"Pages = [\"tutorialsODE.md\"]\nDepth = 3","category":"page"},{"location":"tutorialsODE/","page":"Neural mass equation (Hopf aBS)","title":"Neural mass equation (Hopf aBS)","text":"The following model is taken from [Cortes]:","category":"page"},{"location":"tutorialsODE/","page":"Neural mass equation (Hopf aBS)","title":"Neural mass equation (Hopf aBS)","text":"leftbeginarrayl\ntau dotE=-E+gleft(J u x E+E_0right) \ndotx=tau_D^-1(1-x)-u E x \ndotu=U E(1-u)-tau_F^-1(u-U)\nendarrayright","category":"page"},{"location":"tutorialsODE/","page":"Neural mass equation (Hopf aBS)","title":"Neural mass equation (Hopf aBS)","text":"The model is interesting because the branch of periodic solutions converges to an homoclinic orbit which is challenging to compute with our methods. We provide three different ways to compute this periodic orbits and highlight their pro / cons.","category":"page"},{"location":"tutorialsODE/","page":"Neural mass equation (Hopf aBS)","title":"Neural mass equation (Hopf aBS)","text":"It is easy to encode the ODE as follows","category":"page"},{"location":"tutorialsODE/","page":"Neural mass equation (Hopf aBS)","title":"Neural mass equation (Hopf aBS)","text":"using Revise, ForwardDiff, Parameters, Setfield, Plots, LinearAlgebra\nusing BifurcationKit\nconst BK = BifurcationKit\n\n# sup norm\nnorminf = x -> norm(x, Inf)\n\n# vector field\nfunction TMvf!(dz, z, p, t)\n\t@unpack J, α, E0, τ, τD, τF, U0 = p\n\tE, x, u = z\n\tSS0 = J * u * x * E + E0\n\tSS1 = α * log(1 + exp(SS0 / α))\n\tdz[1] = (-E + SS1) / τ\n\tdz[2] =\t(1.0 - x) / τD - u * x * E\n\tdz[3] = (U0 - u) / τF +  U0 * (1.0 - u) * E\n\tdz\nend\n\n# out of place method\nTMvf(z, p) = TMvf!(similar(z), z, p, 0)\n\n# we group the differentials together\ndTMvf = (z,p) -> ForwardDiff.jacobian(x -> TMvf(x,p), z)\njet = BK.getJet(TMvf, dTMvf)\n\n# parameter values\npar_tm = (α = 1.5, τ = 0.013, J = 3.07, E0 = -2.0, τD = 0.200, U0 = 0.3, τF = 1.5, τS = 0.007)\n\n# initial condition\nz0 = [0.238616, 0.982747, 0.367876 ]\nnothing #hide","category":"page"},{"location":"tutorialsODE/","page":"Neural mass equation (Hopf aBS)","title":"Neural mass equation (Hopf aBS)","text":"We first compute the branch of equilibria","category":"page"},{"location":"tutorialsODE/","page":"Neural mass equation (Hopf aBS)","title":"Neural mass equation (Hopf aBS)","text":"# continuation options\nopts_br = ContinuationPar(pMin = -10.0, pMax = -0.9, \n\t# parameters to have a smooth result\n\tds = 0.04, dsmax = 0.05,\n\t\t# this is to detect bifurcation points precisely\n\t\tdetectBifurcation = 3,\n\t# Optional: bisection options for locating bifurcations\n\tnInversion = 8, maxBisectionSteps = 25, nev = 3)\n\n# continuation of equilibria\nbr, = continuation(TMvf, dTMvf, z0, par_tm, (@lens _.E0), opts_br;\n\trecordFromSolution = (x, p) -> (E = x[1], x = x[2], u = x[3]),\n\ttangentAlgo = BorderedPred(),\n\tplot = true, verbosity = 0, normC = norminf)\n\nscene = plot(br, plotfold=false, markersize=3, legend=:topleft)","category":"page"},{"location":"tutorialsODE/","page":"Neural mass equation (Hopf aBS)","title":"Neural mass equation (Hopf aBS)","text":"julia> br\nBranch number of points: 72\nBranch of Equilibrium\nType of vectors: Vector{Float64}\nParameters E0 from -2.0 to -0.9\nSpecial points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1,    bp at E0 ≈ -1.46302733 ∈ (-1.46302733, -1.46302733), |δp|=4e-14, [converged], δ = ( 1,  0), step =  12, eigenelements in eig[ 13], ind_ev =   1\n- #  2,  hopf at E0 ≈ -1.85012460 ∈ (-1.85012460, -1.85012447), |δp|=1e-07, [converged], δ = ( 2,  2), step =  32, eigenelements in eig[ 33], ind_ev =   3\n- #  3,    bp at E0 ≈ -1.86522391 ∈ (-1.86522391, -1.86522391), |δp|=2e-15, [converged], δ = (-1,  0), step =  36, eigenelements in eig[ 37], ind_ev =   3\n- #  4,  hopf at E0 ≈ -1.15105934 ∈ (-1.15105942, -1.15105934), |δp|=8e-08, [converged], δ = (-2, -2), step =  65, eigenelements in eig[ 66], ind_ev =   2","category":"page"},{"location":"tutorialsODE/#Branch-of-periodic-orbits-with-finite-differences","page":"Neural mass equation (Hopf aBS)","title":"Branch of periodic orbits with finite differences","text":"","category":"section"},{"location":"tutorialsODE/","page":"Neural mass equation (Hopf aBS)","title":"Neural mass equation (Hopf aBS)","text":"We then compute the branch of periodic orbits from the last Hopf bifurcation point (on the right). We use finite differences to discretize the problem of finding periodic orbits. Obviously, this will be problematic when the period of the limit cycle grows unbounded close to the homoclinic orbit.","category":"page"},{"location":"tutorialsODE/","page":"Neural mass equation (Hopf aBS)","title":"Neural mass equation (Hopf aBS)","text":"# newton parameters\noptn_po = NewtonPar(verbose = true, tol = 1e-8,  maxIter = 10) \n\n# continuation parameters\nopts_po_cont = ContinuationPar(dsmax = 0.1, ds= -0.0001, dsmin = 1e-4, pMax = 0., pMin=-5.,\n\tmaxSteps = 110, newtonOptions = (@set optn_po.tol = 1e-7),\n\tnev = 2, precisionStability = 1e-8, detectBifurcation = 3, plotEveryStep = 10, saveSolEveryStep=1)\n\nMt = 200 # number of time sections\n\tbr_potrap, utrap = continuation(jet...,\n\t# we want to branch form the 4th bif. point\n\tbr, 4, opts_po_cont,\n\t# we want to use the Trapeze method to locate PO\n\tPeriodicOrbitTrapProblem(M = Mt);\n\t# this jacobian is specific to ODEs\n\t# it is computed using AD of the flow and\n\t# updated inplace\n\tlinearPO = :Dense,\n\t# regular continuation options\n\tverbosity = 2,\tplot = true,\n\trecordFromSolution = (x, p) -> (xtt=reshape(x[1:end-1],3,Mt); return (max = maximum(xtt[1,:]), min = minimum(xtt[1,:]), period = x[end])),\n\tplotSolution = (x, p; k...) -> begin\n\t\t# the problem prob is passed back in p:\n\t\txtt = BK.getTrajectory(p.prob, x, p.p)\n\t\tplot!(xtt.t, xtt.u[1,:]; label = \"E\", k...)\n\t\tplot!(xtt.t, xtt.u[2,:]; label = \"x\", k...)\n\t\tplot!(xtt.t, xtt.u[3,:]; label = \"u\", k...)\n\t\tplot!(br,subplot=1, putbifptlegend = false)\n\t\tend,\n\tnormC = norminf)\n\nscene = plot(br, br_potrap, markersize = 3)\nplot!(scene, br_potrap.param, br_potrap.min, label = \"\")","category":"page"},{"location":"tutorialsODE/","page":"Neural mass equation (Hopf aBS)","title":"Neural mass equation (Hopf aBS)","text":"(Image: )","category":"page"},{"location":"tutorialsODE/","page":"Neural mass equation (Hopf aBS)","title":"Neural mass equation (Hopf aBS)","text":"We plot the maximum (resp. minimum) of the limit cycle. We can see that the min converges to the smallest equilibrium indicating a homoclinic orbit.","category":"page"},{"location":"tutorialsODE/#Periodic-orbits-with-Parallel-Standard-Shooting","page":"Neural mass equation (Hopf aBS)","title":"Periodic orbits with Parallel Standard Shooting","text":"","category":"section"},{"location":"tutorialsODE/","page":"Neural mass equation (Hopf aBS)","title":"Neural mass equation (Hopf aBS)","text":"We use a different method to compute periodic orbits: we rely on a fixed point of the flow. To compute the flow, we use DifferentialEquations.jl. This way of computing periodic orbits should be more precise than the previous one. We use a particular instance called multiple shooting which is computed in parallel. This is an additional advantage compared to the previous method.","category":"page"},{"location":"tutorialsODE/","page":"Neural mass equation (Hopf aBS)","title":"Neural mass equation (Hopf aBS)","text":"using DifferentialEquations\n\n# this is the ODEProblem used with `DiffEqBase.solve`\nprobsh = ODEProblem(TMvf!, copy(z0), (0., 1000.), par_tm; atol = 1e-10, rtol = 1e-9)\n\nopts_po_cont = ContinuationPar(dsmax = 0.05, ds= -0.0001, dsmin = 1e-4, pMax = 0., pMin=-5., maxSteps = 210, newtonOptions = (@set optn_po.tol = 1e-6), nev = 25, precisionStability = 1e-8, detectBifurcation = 0, plotEveryStep = 10, saveSolEveryStep=0)\n\nbr_posh, = @time continuation(jet...,\n\tbr, 4, opts_po_cont,\n\t# this is where we tell that we want Standard Shooting\n\t# with 15 time sections\n\tShootingProblem(15, par_tm, probsh, Rodas4(), parallel = true);\n\t# this to help branching\n\tampfactor = 1.0, δp = 0.0005,\n\t# deflation helps not converging to an equilibrium instead of a PO\n\tusedeflation = true,\n\t# this linear solver is specific to ODEs\n\t# it is computed using AD of the flow and\n\t# updated inplace\n\tlinearPO = :autodiffDense,\n\t# we update the section along the branches\n\tupdateSectionEveryStep = 2,\n\t# regular continuation parameters\n\tverbosity = 2,\tplot = true,\n\trecordFromSolution = (x, p) -> (return (max = getMaximum(p.prob, x, @set par_tm.E0 = p.p), period = getPeriod(p.prob, x, @set par_tm.E0 = p.p))),\n\tplotSolution = (x, p; k...) ->\n\t\tbegin\n\t\t\txtt = BK.getTrajectory(p.prob, x, @set par_tm.E0 = p.p)\n\t\t\tplot!(xtt; legend = false, k...);\n\t\t\tplot!(br, subplot=1, putbifptlegend = false)\n\t\tend,\n\tnormC = norminf)","category":"page"},{"location":"tutorialsODE/","page":"Neural mass equation (Hopf aBS)","title":"Neural mass equation (Hopf aBS)","text":"(Image: )","category":"page"},{"location":"tutorialsODE/#References","page":"Neural mass equation (Hopf aBS)","title":"References","text":"","category":"section"},{"location":"tutorialsODE/","page":"Neural mass equation (Hopf aBS)","title":"Neural mass equation (Hopf aBS)","text":"[Cortes]: Cortes, Jesus M., Mathieu Desroches, Serafim Rodrigues, Romain Veltz, Miguel A. Muñoz, and Terrence J. Sejnowski. Short-Term Synaptic Plasticity in the Deterministic Tsodyks–Markram Model Leads to Unpredictable Network Dynamics.” Proceedings of the National Academy of Sciences 110, no. 41 (October 8, 2013): 16610–15. https://doi.org/10.1073/pnas.1316071110.","category":"page"},{"location":"EventCallback/#Event-Handling","page":"Event Handling and Callback","title":"Event Handling","text":"","category":"section"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"BifurcationKit.jl allows for detecting events along the branch of solutions. Its main use consists in detecting bifurcation points but they can be used and combined together by the user too.","category":"page"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"The events are detected during a call to br, = continuation(F, J, u0, p0, lens, contParams::ContinuationPar;kwargs...) by turning on the following flags:","category":"page"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"contParams.detectEvent = 1","category":"page"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"The event points are located by looking at the function defining the event (see below). The located event points are then returned in br.specialpoint.","category":"page"},{"location":"EventCallback/#Precise-detection-of-event-points-using-Bisection","page":"Event Handling and Callback","title":"Precise detection of event points using Bisection","text":"","category":"section"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"Note that the event points detected when detectEvent = 1 are only approximate event points. Indeed, we only signal that, in between two continuation steps which can be large, a (several) event point has been detected. Hence, we only have a rough idea of where the event is located, unless your ContinuationPar().dsmax is very small... This can be improved as follows.","category":"page"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"If you choose detectEvent = 2, a bisection algorithm is used to locate the event points more precisely. It means that we recursively track down the event. Some options in ContinuationPar control this behavior:","category":"page"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"nInversion: number of sign inversions in the bisection algorithm\nmaxBisectionSteps maximum number of bisection steps\ntolParamBisectionEvent tolerance on parameter to locate event","category":"page"},{"location":"EventCallback/#Different-event-types","page":"Event Handling and Callback","title":"Different event types","text":"","category":"section"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"The set of possible events DiscreteEvent, ContinuousEvent, SetOfEvents, PairOfEvents is detailed in the Library.","category":"page"},{"location":"EventCallback/#Built-in-events","page":"Event Handling and Callback","title":"Built-in events","text":"","category":"section"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"BifurcationKit.SaveAtEvent","category":"page"},{"location":"EventCallback/#BifurcationKit.SaveAtEvent","page":"Event Handling and Callback","title":"BifurcationKit.SaveAtEvent","text":"`SaveAtEvent(positions::Tuple)`\n\nThis event implements the detection of when the parameter values, used during continuation, equals one of the values in positions. This state is then saved in the branch.\n\nFor example, you can use it like continuation(args...; event = SaveAtEvent((1., 2., -3.)))\n\n\n\n\n\n","category":"function"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"BifurcationKit.FoldDetectEvent","category":"page"},{"location":"EventCallback/#BifurcationKit.FoldDetectEvent","page":"Event Handling and Callback","title":"BifurcationKit.FoldDetectEvent","text":"`FoldDetectEvent`\n\nThis event implements the detection of Fold points based on the p-component of the tangent vector to the continuation curve. It is designed to work with the predictor BorderedPred() that you pass to continuation with the keyword argument tangentAlgo.\n\n\n\n\n\n","category":"constant"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"BifurcationKit.BifDetectEvent","category":"page"},{"location":"EventCallback/#BifurcationKit.BifDetectEvent","page":"Event Handling and Callback","title":"BifurcationKit.BifDetectEvent","text":"`BifDetectEvent`\n\nThis event implements the detection of bifurcations points along a continuation curve. The detection is based on monitoring  the number of unstable eigenvalues. More details are given at Detection of bifurcation points.\n\n\n\n\n\n","category":"constant"},{"location":"EventCallback/#Examples","page":"Event Handling and Callback","title":"Examples","text":"","category":"section"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"We show how to use the different events. We first set up a problem as usual.","category":"page"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"using Revise, BifurcationKit, Setfield, ForwardDiff\nusing Plots\nconst BK = BifurcationKit\n####################################################################################################\n# test vector field for event detection\nfunction Feve(X, p)\n\tp1, p2, k = p\n\tx, y = X\n\tout = similar(X)\n\tout[1] = p1 + x - y - x^k/k\n\tout[2] = p1 + y + x - 2y^k/k\n\tout\nend\n\n# associated jacobian\nJeve(X, p) = ForwardDiff.jacobian(z -> Feve(z,p), X)\n\n# parameters for the vector field\npar = (p1 = -3., p2=-3., k=3)\n\n# parameters for the continuation\nopts = ContinuationPar(dsmax = 0.1, ds = 0.001, maxSteps = 128, pMin = -3., pMax = 4.0,\n     saveSolEveryStep = 1, plotEveryStep = 10,\n     newtonOptions = NewtonPar(tol = 1e-10, verbose = false, maxIter = 5),\n     # parameters specific to event detection\n     detectBifurcation = 0, detectEvent = 2, nInversion = 6, dsminBisection = 1e-9,\n     maxBisectionSteps = 15, detectFold=false)\n\n# arguments for continuation\nargs = (Feve, Jeve, -2ones(2), par, (@lens _.p1), opts)\nkwargs = (plot = true, verbosity = 3, recordFromSolution = (x,p) -> x[1],\n    linearAlgo = MatrixBLS(),)","category":"page"},{"location":"EventCallback/#Example-of-continuous-event","page":"Event Handling and Callback","title":"Example of continuous event","text":"","category":"section"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"In this first example, we build an event to detect when the parameter value is -2 or when the first component of the solution is 1.","category":"page"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"br, = continuation(args...; kwargs...,\n\tevent = BK.ContinuousEvent(2, \n\t\t(iter, state) -> (getp(state)+2, getx(state)[1]-1)),)","category":"page"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"gives","category":"page"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"julia> br\nBranch number of points: 128\nBranch of Equilibrium\nParameters p1 from -3.0 to 4.0\nSpecial points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1, userC-1 at p1 ≈ -1.99996995 ∈ (-2.00003555, -1.99996995), |δp|=7e-05, [converged], δ = ( 0,  0), step =  25, eigenelements in eig[ 25], ind_ev =   0\n- #  2, userC-1 at p1 ≈ -2.10228497 ∈ (-2.10228497, -1.99999798), |δp|=1e-01, [    guess], δ = ( 0,  0), step =  42, eigenelements in eig[ 42], ind_ev =   0\n- #  3, userC-2 at p1 ≈ -2.30841066 ∈ (-2.30881920, -2.30841066), |δp|=4e-04, [converged], δ = ( 0,  0), step =  46, eigenelements in eig[ 46], ind_ev =   0\n- #  4, userC-1 at p1 ≈ -1.99983405 ∈ (-2.00007518, -1.99983405), |δp|=2e-04, [converged], δ = ( 0,  0), step =  49, eigenelements in eig[ 49], ind_ev =   0\n- #  5, userC-2 at p1 ≈ -0.83491347 ∈ (-0.83506349, -0.83491347), |δp|=2e-04, [converged], δ = ( 0,  0), step =  61, eigenelements in eig[ 61], ind_ev =   0\n- #  6, userC-2 at p1 ≈ +1.14438624 ∈ (+1.14308305, +1.14438624), |δp|=1e-03, [converged], δ = ( 0,  0), step = 105, eigenelements in eig[105], ind_ev =   0","category":"page"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"This shows for example that the first component of the event was detected userC-1 first. This yields plot(br)","category":"page"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"(Image: )","category":"page"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"You can also name the events as follows","category":"page"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":" br, = continuation(args...; kwargs...,\n \tevent = BK.ContinuousEvent(2, \n \t\t(iter, state) -> (getp(state)+2, getx(state)[1]-1),\n \t\t(\"event1\", \"event2\")))","category":"page"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"And get:","category":"page"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"julia> br\n(Branch number of points: 128\nBranch of Equilibrium\nParameters p1 from -3.0 to 4.0\nSpecial points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1, event1 at p1 ≈ -1.99996995 ∈ (-2.00003555, -1.99996995), |δp|=7e-05, [converged], δ = ( 0,  0), step =  25, eigenelements in eig[ 25], ind_ev =   0\n- #  2, event1 at p1 ≈ -2.10228497 ∈ (-2.10228497, -1.99999798), |δp|=1e-01, [    guess], δ = ( 0,  0), step =  42, eigenelements in eig[ 42], ind_ev =   0\n- #  3, event2 at p1 ≈ -2.30841066 ∈ (-2.30881920, -2.30841066), |δp|=4e-04, [converged], δ = ( 0,  0), step =  46, eigenelements in eig[ 46], ind_ev =   0\n- #  4, event1 at p1 ≈ -1.99983405 ∈ (-2.00007518, -1.99983405), |δp|=2e-04, [converged], δ = ( 0,  0), step =  49, eigenelements in eig[ 49], ind_ev =   0\n- #  5, event2 at p1 ≈ -0.83491347 ∈ (-0.83506349, -0.83491347), |δp|=2e-04, [converged], δ = ( 0,  0), step =  61, eigenelements in eig[ 61], ind_ev =   0\n- #  6, event2 at p1 ≈ +1.14438624 ∈ (+1.14308305, +1.14438624), |δp|=1e-03, [converged], δ = ( 0,  0), step = 105, eigenelements in eig[105], ind_ev =   0","category":"page"},{"location":"EventCallback/#Example-of-discrete-event","page":"Event Handling and Callback","title":"Example of discrete event","text":"","category":"section"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"You can also use discrete events to detect a change. For example, the following detect when the parameter value equals -2:","category":"page"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"br, = continuation(args...; kwargs...,\n\tevent = BK.DiscreteEvent(1, \n\t\t(iter, state) -> getp(state)>-2))","category":"page"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"gives","category":"page"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"julia> br\nBranch number of points: 128\nBranch of Equilibrium\nParameters p1 from -3.0 to 4.0\nSpecial points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1, userD at p1 ≈ -1.99996995 ∈ (-2.00003555, -1.99996995), |δp|=7e-05, [converged], δ = ( 0,  0), step =  25, eigenelements in eig[ 25], ind_ev =   0\n- #  2, userD at p1 ≈ -2.10228497 ∈ (-2.10228497, -1.99999798), |δp|=1e-01, [    guess], δ = ( 0,  0), step =  42, eigenelements in eig[ 42], ind_ev =   0\n- #  3, userD at p1 ≈ -1.99998059 ∈ (-2.00001073, -1.99998059), |δp|=3e-05, [converged], δ = ( 0,  0), step =  49, eigenelements in eig[ 49], ind_ev =   0","category":"page"},{"location":"EventCallback/#Example-of-PairOfEvents-event","page":"Event Handling and Callback","title":"Example of PairOfEvents event","text":"","category":"section"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"Let us be a bit more creative and combine a continuous event with a discrete one:","category":"page"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"br, = continuation(args...; kwargs...,\n\tevent = BK.PairOfEvents(\n\t\tBK.ContinuousEvent(1, (iter, state) -> getp(state)),\n\t\tBK.DiscreteEvent(1, (iter, state) -> getp(state)>-2)))","category":"page"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"and obtain","category":"page"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"julia> br\n(Branch number of points: 128\nBranch of Equilibrium\nParameters p1 from -3.0 to 4.0\nSpecial points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1, userD-1 at p1 ≈ -1.99996995 ∈ (-2.00003555, -1.99996995), |δp|=7e-05, [converged], δ = ( 0,  0), step =  25, eigenelements in eig[ 25], ind_ev =   0\n- #  2, userD-1 at p1 ≈ -2.10228497 ∈ (-2.10228497, -1.99999798), |δp|=1e-01, [    guess], δ = ( 0,  0), step =  42, eigenelements in eig[ 42], ind_ev =   0\n- #  3, userD-1 at p1 ≈ -1.99998059 ∈ (-2.00001073, -1.99998059), |δp|=3e-05, [converged], δ = ( 0,  0), step =  49, eigenelements in eig[ 49], ind_ev =   0\n- #  4, userC-1 at p1 ≈ +0.00000555 ∈ (-0.00000855, +0.00000555), |δp|=1e-05, [converged], δ = ( 0,  0), step =  69, eigenelements in eig[ 69], ind_ev =   0","category":"page"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"Here userD-1 means that the first component of the discrete event was detected. Of course, you can name the event like done above.","category":"page"},{"location":"EventCallback/#Example-of-set-of-events","page":"Event Handling and Callback","title":"Example of set of events","text":"","category":"section"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"We can combine more events and chain them like we want using SetOfEvents. In this example, we show how to do bifurcation detection and event location altogether:","category":"page"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"ev1 = BK.ContinuousEvent(1, (iter, state) -> getp(state)-1)\nev2 = BK.ContinuousEvent(2, (iter, state) -> (getp(state)-2, getp(state)-2.5))\n# event to detect bifurcation\nev3 = BK.BifDetectEvent\n# we combine the events together\neve = BK.SetOfEvents(ev1, ev2, ev3)\n\nbr, = continuation(args...; kwargs...,\n\t\tevent = eve)","category":"page"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"Which gives","category":"page"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"julia> br\nBranch number of points: 132\nBranch of Equilibrium\nParameters p1 from -3.0 to 4.0\nSpecial points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1,    bp at p1 ≈ -1.13352254 ∈ (-1.13352254, -1.13351184), |δp|=1e-05, [    guess], δ = ( 1,  0), step =  33, eigenelements in eig[ 34], ind_ev =   1\n- #  2,    bp at p1 ≈ -2.32505840 ∈ (-2.32505840, -2.32505721), |δp|=1e-06, [converged], δ = (-1,  0), step =  46, eigenelements in eig[ 47], ind_ev =   1\n- #  3,  hopf at p1 ≈ -0.95278292 ∈ (-0.95406239, -0.95278292), |δp|=1e-03, [converged], δ = ( 2,  2), step =  60, eigenelements in eig[ 61], ind_ev =   2\n- #  4,  hopf at p1 ≈ +0.95484802 ∈ (+0.95357386, +0.95484802), |δp|=1e-03, [converged], δ = (-2, -2), step =  80, eigenelements in eig[ 81], ind_ev =   2\n- #  5, userC1 at p1 ≈ +1.00001539 ∈ (+0.99997148, +1.00001539), |δp|=4e-05, [converged], δ = ( 0,  0), step =  82, eigenelements in eig[ 82], ind_ev =   0\n- #  6, userC2-1 at p1 ≈ +2.00064090 ∈ (+1.99678144, +2.00064090), |δp|=4e-03, [converged], δ = ( 0,  0), step =  91, eigenelements in eig[ 91], ind_ev =   0\n- #  7,    bp at p1 ≈ +2.32505860 ∈ (+2.32505860, +2.32505861), |δp|=1e-08, [converged], δ = ( 1,  0), step =  95, eigenelements in eig[ 96], ind_ev =   1\n- #  8, userC2-1 at p1 ≈ +1.99961809 ∈ (+1.99961809, +2.00135833), |δp|=2e-03, [converged], δ = ( 0,  0), step =  99, eigenelements in eig[ 99], ind_ev =   0\n- #  9,    bp at p1 ≈ +1.13290310 ∈ (+1.13286417, +1.13290310), |δp|=4e-05, [converged], δ = (-1,  0), step = 108, eigenelements in eig[109], ind_ev =   1\n- # 10, userC2-1 at p1 ≈ +2.00114454 ∈ (+1.99694626, +2.00114454), |δp|=4e-03, [converged], δ = ( 0,  0), step = 116, eigenelements in eig[116], ind_ev =   0\n- # 11, userC2-2 at p1 ≈ +2.50216926 ∈ (+2.49360973, +2.50216926), |δp|=9e-03, [converged], δ = ( 0,  0), step = 120, eigenelements in eig[120], ind_ev =   0","category":"page"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"And ","category":"page"},{"location":"EventCallback/","page":"Event Handling and Callback","title":"Event Handling and Callback","text":"(Image: )","category":"page"},{"location":"Borderedarrays/#Bordered-Arrays","page":"Bordered arrays","title":"Bordered Arrays","text":"","category":"section"},{"location":"Borderedarrays/","page":"Bordered arrays","title":"Bordered arrays","text":"warning: Advanced usage\nYou can skip this in a first read","category":"page"},{"location":"Borderedarrays/","page":"Bordered arrays","title":"Bordered arrays","text":"Here are some informations on a composite type which is used all over the package to hold a couple (array, array) or (array, scalar) while implementing the methods described in Requested methods for Custom State. ","category":"page"},{"location":"Borderedarrays/","page":"Bordered arrays","title":"Bordered arrays","text":"BorderedArray","category":"page"},{"location":"Borderedarrays/#BifurcationKit.BorderedArray","page":"Bordered arrays","title":"BifurcationKit.BorderedArray","text":"x = BorderedArray(vec1, vec2)\n\nThis defines an array (although not <: AbstractArray) to hold two arrays or an array and a scalar. This is useful when one wants to add constraints (phase, ...) to a functional for example. It is used throughout the package for the Pseudo Arc Length Continuation, for the continuation of Fold / Hopf points, for periodic orbits... It is also used to define periodic orbits as (orbit, period). As such, it is a convenient alternative to cat, vcat and friends. We chose not make it a subtype of AbstractArray as we wish to apply the current package to general \"arrays\", see Requested methods for Custom State. Finally, it proves useful for the GPU where the operation x[end] can be slow.\n\n\n\n\n\n","category":"type"},{"location":"linearsolver/#Linear-solvers-(LS)","page":"Linear Solvers","title":"Linear solvers (LS)","text":"","category":"section"},{"location":"linearsolver/","page":"Linear Solvers","title":"Linear Solvers","text":"If you provide your own linear solver, it must be a subtype of AbstractLinearSolver otherwise BifurcationKit.jl will not recognize it. See example just below. ","category":"page"},{"location":"linearsolver/","page":"Linear Solvers","title":"Linear Solvers","text":"The linear solvers provide a way of inverting the Jacobian J or solving J * x = rhs. Such linear solver linsolve will be called like sol, success, itnumber = linsolve(J, rhs) throughout the package.","category":"page"},{"location":"linearsolver/","page":"Linear Solvers","title":"Linear Solvers","text":"Here is an example of the simplest of them (see src/LinearSolver.jl for the true implementation) to give you an idea, the backslash operator:","category":"page"},{"location":"linearsolver/","page":"Linear Solvers","title":"Linear Solvers","text":"struct DefaultLS <: AbstractLinearSolver end\n\nfunction (l::DefaultLS)(J, rhs)\n\treturn J \\ rhs, true, 1\nend","category":"page"},{"location":"linearsolver/","page":"Linear Solvers","title":"Linear Solvers","text":"Note that for newton to work, the linear solver must return 3 arguments. The first one is the result, the second one is whether the computation was successful and the third is the number of iterations required to perform the computation.","category":"page"},{"location":"linearsolver/","page":"Linear Solvers","title":"Linear Solvers","text":"You can then call it as follows (and it will be called like this in newton)","category":"page"},{"location":"linearsolver/","page":"Linear Solvers","title":"Linear Solvers","text":"ls = DefaultLS()\nls(rand(2,2), rand(2))","category":"page"},{"location":"linearsolver/#List-of-implemented-linear-solvers","page":"Linear Solvers","title":"List of implemented linear solvers","text":"","category":"section"},{"location":"linearsolver/","page":"Linear Solvers","title":"Linear Solvers","text":"Default \\ solver based on LU or Cholesky depending on the type of the Jacobian. This works for sparse matrices as well. You can create one via linsolver = DefaultLS().\nGMRES from IterativeSolvers.jl. You can create one via linsolver = GMRESIterativeSolvers() and pass appropriate options.\nGMRES from KrylovKit.jl. You can create one via linsolver = GMRESKrylovKit() and pass appropriate options.","category":"page"},{"location":"linearsolver/","page":"Linear Solvers","title":"Linear Solvers","text":"tip: Different linear solvers\nBy tuning the options of GMRESKrylovKit, you can select CG, GMRES... see KrylovKit.jl.","category":"page"},{"location":"linearsolver/","page":"Linear Solvers","title":"Linear Solvers","text":"note: Other solvers\nIt is very straightforward to implement the Conjugate Gradients from IterativeSolvers.jl by copying the interface done for gmres. Same goes for minres,... Not needing them, I did not implement this.","category":"page"},{"location":"linearsolver/#Preconditioner","page":"Linear Solvers","title":"Preconditioner","text":"","category":"section"},{"location":"linearsolver/","page":"Linear Solvers","title":"Linear Solvers","text":"Preconditioners should be considered when using Matrix Free methods such as GMRES. GMRESIterativeSolvers provides a very simple interface for using them. For GMRESKrylovKit, we implemented a left preconditioner. Note that, for GMRESKrylovKit, you are not restricted to use Vectors anymore. Finally, here are some packages to use preconditioners","category":"page"},{"location":"linearsolver/","page":"Linear Solvers","title":"Linear Solvers","text":"IncompleteLU.jl an ILU like preconditioner\nAlgebraicMultigrid.jl Algebraic Multigrid (AMG) preconditioners. This works especially well for symmetric positive definite matrices.\nPreconditioners.jl A convenient interface to conveniently called most of the above preconditioners using a single syntax.\nWe provide a preconditioner based on deflation of eigenvalues (also called preconditioner based on Leading Invariant Subspaces) using a partial Schur decomposition. There are two ways to define one i.e. PrecPartialSchurKrylovKit and PrecPartialSchurArnoldiMethod. ","category":"page"},{"location":"linearsolver/","page":"Linear Solvers","title":"Linear Solvers","text":"tip: Using Preconditioners\nApart from setting a preconditioner for a linear solver, it can be advantageous to change the preconditioner during computations, e.g. during a call to continuation or newton. This can be achieved by taking advantage of the callbacks to these methods. See the example 2d Ginzburg-Landau equation (finite differences).","category":"page"},{"location":"plotting/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"plotting/#Plotting-branches","page":"Plotting","title":"Plotting branches","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Plotting is provided by calling Plots.jl. It means that to plot a branch br, you just need to call","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"plot(br)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"where br is a branch computed after a call to br, = continuation(...). You can use the keywords provided by Plots.jl and the different backends. You can thus call","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"scatter(br)\nplot!(br, label = \"continuous line\")","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The available arguments specific to our plotting methods are","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"plotfold = true: plot the fold points with black dots\nputspecialptlegend = true: display the legend corresponding to the bifurcation points\nvars = nothing: see below\nplotstability = true: display the stability of the branch\nplotspecialpoints = true: plot the special (bifurcation) points on the branch\nbranchlabel = \"fold branch\": assign label to a branch which is printed in the legend\nlinewidthunstable: set the linewidth for the unstable part of the branch\nlinewidthstable: set the linewidth for the stable part of the branch\nplotcirclesbif = false use circles to plot bifurcation points\napplytoX = identity apply transformation applytoX to x-axis\napplytoY = identity apply transformation applytoY to y-axis","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"If you have severals branches br1, br2, you can plot them in the same figure by doing","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"plot(br1, br2)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"in place of","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"plot(br1)\nplot!(br2)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"warn: Plot of bifurcation points\nThe bifurcation points for which the bisection was successful are indicated with circles and with squares otherwise.","category":"page"},{"location":"plotting/#Choosing-Variables","page":"Plotting","title":"Choosing Variables","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"You can select which variables to plot using the keyword argument vars:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"plot(br, vars = (:param, :x))","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The available symbols are :param, :sol, :itnewton, :ds, :theta, :step and:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"x if recordFromSolution (see continuation) returns a Number.\nx1, x2,... if recordFromSolution returns a Tuple.\nthe keys of the NamedTuple returned by recordFromSolution.","category":"page"},{"location":"plotting/#Plotting-directly-using-the-field-names","page":"Plotting","title":"Plotting directly using the field names","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"You can define your own plotting functions using the internal fields of br which is of type ContResult. For example, the previous plot can be done as follows:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"plot(br.branch.param, br.branch.x)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"You can also plot the spectrum at a specific continuation step::Int by calling","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"# get the eigenvalues\neigvals = br.eig[step].eigenvals\n\n# plot them in the complex plane\nscatter(real.(eigvals), imag.(eigvals))","category":"page"},{"location":"plotting/#Plotting-bifurcation-diagrams","page":"Plotting","title":"Plotting bifurcation diagrams","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"To do this, you just need to call","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"plot(diagram)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"where diagram is a branch computed after a call to diagram, = bifurcationdiagram(...). You can use the keywords provided by Plots.jl and the different backends. You can thus call scatter(diagram). In addition to the options for plotting branches (see above), there are specific arguments available for bifurcation diagrams","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"code specify the part of the bifurcation diagram to plot. For example code = (1,1,) plots the part after the first branch of the first branch of the root branch.\nlevel = (-Inf, Inf) restrict the branching level for plotting.","category":"page"}]
}
